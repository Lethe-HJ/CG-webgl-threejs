# Promise 基础

## 目录

- [1. 什么是 Promise](#1-什么是-promise)
- [2. Promise 的基本用法](#2-promise-的基本用法)
  - [2.1 创建 Promise](#21-创建-promise)
  - [2.2 使用 then() 处理成功结果](#22-使用-then-处理成功结果)
  - [2.3 使用 catch() 处理错误](#23-使用-catch-处理错误)
  - [2.4 使用 finally()](#24-使用-finally)
- [3. Promise.resolve() 和 Promise.reject()](#3-promiseresolve-和-promisereject)
  - [3.1 Promise.resolve()](#31-promiseresolve)
  - [3.2 Promise.reject()](#32-promisereject)
- [4. Promise 链式调用](#4-promise-链式调用)
- [5. 错误处理](#5-错误处理)
  - [5.1 then 的第二个参数 vs catch](#51-then-的第二个参数-vs-catch)
  - [5.2 错误会沿着链传递](#52-错误会沿着链传递)
- [6. 实际应用示例](#6-实际应用示例)
  - [6.1 模拟网络请求](#61-模拟网络请求)
  - [6.2 封装定时器](#62-封装定时器)
  - [6.3 将回调函数转换为 Promise](#63-将回调函数转换为-promise)
- [7. 常见陷阱](#7-常见陷阱)
  - [7.1 忘记 return](#71-忘记-return)
  - [7.2 Promise 状态一旦改变就不可逆](#72-promise-状态一旦改变就不可逆)
  - [7.3 在 executor 中抛出错误](#73-在-executor-中抛出错误)

---

## 1. 什么是 Promise

Promise 是 JavaScript 中处理异步操作的一种方式，它代表一个异步操作的最终完成（或失败）及其结果值。

Promise 有三种状态：
- **pending**（进行中）：初始状态
- **fulfilled**（已成功）：操作成功完成
- **rejected**（已失败）：操作失败

```javascript
// 创建一个 Promise
const promise = new Promise((resolve, reject) => {
  // 异步操作
  setTimeout(() => {
    const success = true;
    if (success) {
      resolve('操作成功！');
    } else {
      reject('操作失败！');
    }
  }, 1000);
});

console.log(promise); // Promise { <pending> }
```

## 2. Promise 的基本用法

### 2.1 创建 Promise

```javascript
// 基本创建方式
const myPromise = new Promise((resolve, reject) => {
  // 执行异步操作
  const data = { name: 'Promise', type: 'async' };
  
  // 成功时调用 resolve
  resolve(data);
  
  // 失败时调用 reject
  // reject(new Error('Something went wrong'));
});
```

### 2.2 使用 then() 处理成功结果

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, Promise!');
  }, 1000);
});

// then() 接收成功的回调
promise.then((result) => {
  console.log(result); // 输出: Hello, Promise!
});
```

### 2.3 使用 catch() 处理错误

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('出错了！'));
  }, 1000);
});

// catch() 捕获错误
promise
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.error('捕获到错误:', error.message); // 输出: 捕获到错误: 出错了！
  });
```

### 2.4 使用 finally()

`finally()` 无论 Promise 成功还是失败都会执行。

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('成功');
  }, 1000);
});

promise
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.error(error);
  })
  .finally(() => {
    console.log('无论成功失败，都会执行'); // 总是执行
  });
```

## 3. Promise.resolve() 和 Promise.reject()

### 3.1 Promise.resolve()

快速创建一个已完成的 Promise。

```javascript
// 直接返回一个已 resolve 的 Promise
const resolvedPromise = Promise.resolve('立即成功');

resolvedPromise.then((value) => {
  console.log(value); // 输出: 立即成功
});

// 等价于
const equivalent = new Promise((resolve) => {
  resolve('立即成功');
});
```

### 3.2 Promise.reject()

快速创建一个已拒绝的 Promise。

```javascript
// 直接返回一个已 reject 的 Promise
const rejectedPromise = Promise.reject(new Error('立即失败'));

rejectedPromise.catch((error) => {
  console.error(error.message); // 输出: 立即失败
});
```

## 4. Promise 链式调用

`then()` 方法返回一个新的 Promise，可以进行链式调用。

```javascript
const promise = new Promise((resolve) => {
  resolve(1);
});

promise
  .then((value) => {
    console.log(value); // 1
    return value + 1;
  })
  .then((value) => {
    console.log(value); // 2
    return value + 1;
  })
  .then((value) => {
    console.log(value); // 3
    return value + 1;
  })
  .then((value) => {
    console.log(value); // 4
  });
```

### 链式调用中返回 Promise

```javascript
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function fetchUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: `User${id}` });
    }, 1000);
  });
}

function fetchPosts(userId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, title: 'Post 1', userId },
        { id: 2, title: 'Post 2', userId },
      ]);
    }, 1000);
  });
}

// 链式调用多个异步操作
fetchUser(1)
  .then((user) => {
    console.log('获取到用户:', user);
    return fetchPosts(user.id);
  })
  .then((posts) => {
    console.log('获取到文章:', posts);
  })
  .catch((error) => {
    console.error('发生错误:', error);
  });
```

## 5. 错误处理

### 5.1 then 的第二个参数 vs catch

```javascript
const promise = new Promise((resolve, reject) => {
  reject(new Error('错误'));
});

// 方式1: then 的第二个参数
promise.then(
  (result) => console.log(result),
  (error) => console.error('then 捕获:', error.message)
);

// 方式2: catch（推荐）
promise
  .then((result) => console.log(result))
  .catch((error) => console.error('catch 捕获:', error.message));
```

### 5.2 错误会沿着链传递

```javascript
const promise = new Promise((resolve) => {
  resolve(1);
});

promise
  .then((value) => {
    console.log(value); // 1
    throw new Error('链中抛出错误');
  })
  .then((value) => {
    console.log('这里不会执行');
  })
  .then((value) => {
    console.log('这里也不会执行');
  })
  .catch((error) => {
    console.error('最终捕获:', error.message); // 最终捕获: 链中抛出错误
  });
```

## 6. 实际应用示例

### 6.1 模拟网络请求

```javascript
function mockFetch(url) {
  return new Promise((resolve, reject) => {
    console.log(`正在请求: ${url}`);
    
    setTimeout(() => {
      if (url.includes('error')) {
        reject(new Error('请求失败'));
      } else {
        resolve({
          status: 200,
          data: { message: '请求成功', url }
        });
      }
    }, 1500);
  });
}

// 使用
mockFetch('https://api.example.com/users')
  .then((response) => {
    console.log('状态码:', response.status);
    console.log('数据:', response.data);
  })
  .catch((error) => {
    console.error('请求出错:', error.message);
  });
```

### 6.2 封装定时器

```javascript
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

// 使用
console.log('开始');
sleep(2000).then(() => {
  console.log('2秒后执行');
});
```

### 6.3 将回调函数转换为 Promise

```javascript
// 传统回调方式
function readFileCallback(filename, callback) {
  setTimeout(() => {
    if (filename) {
      callback(null, `${filename} 的内容`);
    } else {
      callback(new Error('文件名不能为空'));
    }
  }, 1000);
}

// 转换为 Promise
function readFilePromise(filename) {
  return new Promise((resolve, reject) => {
    readFileCallback(filename, (error, data) => {
      if (error) {
        reject(error);
      } else {
        resolve(data);
      }
    });
  });
}

// 使用 Promise 版本
readFilePromise('test.txt')
  .then((content) => {
    console.log('文件内容:', content);
  })
  .catch((error) => {
    console.error('读取失败:', error.message);
  });
```

## 7. 常见陷阱

### 7.1 忘记 return

```javascript
// ❌ 错误示例
const promise = Promise.resolve(1);

promise
  .then((value) => {
    Promise.resolve(value + 1); // 忘记 return
  })
  .then((value) => {
    console.log(value); // undefined
  });

// ✅ 正确示例
promise
  .then((value) => {
    return Promise.resolve(value + 1); // 记得 return
  })
  .then((value) => {
    console.log(value); // 2
  });
```

### 7.2 Promise 状态一旦改变就不可逆

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('成功');
  reject('失败'); // 这行不会生效，因为状态已经是 fulfilled
  resolve('再次成功'); // 这行也不会生效
});

promise
  .then((value) => console.log(value)) // 输出: 成功
  .catch((error) => console.error(error)); // 不会执行
```

### 7.3 在 executor 中抛出错误

```javascript
const promise = new Promise((resolve, reject) => {
  throw new Error('executor 中的错误');
});

// 等价于
const equivalent = new Promise((resolve, reject) => {
  reject(new Error('executor 中的错误'));
});

promise.catch((error) => {
  console.error(error.message); // 输出: executor 中的错误
});
```

