# Promise 高级

## 目录

- [1. 手写 Promise 实现](#1-手写-promise-实现)
  - [1.1 基础版本](#11-基础版本)
- [2. 微任务与宏任务](#2-微任务与宏任务)
  - [2.1 事件循环中的 Promise](#21-事件循环中的-promise)
  - [2.2 复杂的执行顺序](#22-复杂的执行顺序)
  - [2.3 async/await 与微任务](#23-asyncawait-与微任务)
- [3. Promise 高级模式](#3-promise-高级模式)
  - [3.1 Promise 队列](#31-promise-队列)
  - [3.2 Promise 调度器](#32-promise-调度器)
  - [3.3 Promise 管道](#33-promise-管道)
  - [3.4 Promise 分支](#34-promise-分支)
- [4. 错误处理高级模式](#4-错误处理高级模式)
  - [4.1 全局未捕获 Promise 错误处理](#41-全局未捕获-promise-错误处理)
  - [4.2 错误边界模式](#42-错误边界模式)
  - [4.3 Result 模式（类似 Rust）](#43-result-模式类似-rust)
- [5. Promise 性能优化](#5-promise-性能优化)
  - [5.1 批量处理](#51-批量处理)
  - [5.2 延迟执行](#52-延迟执行)
  - [5.3 防抖与节流](#53-防抖与节流)
- [6. Promise 与 Generator](#6-promise-与-generator)
  - [6.1 使用 Generator 实现 async/await](#61-使用-generator-实现-asyncawait)
  - [6.2 可取消的异步流程](#62-可取消的异步流程)
- [7. Promise A+ 规范要点](#7-promise-a-规范要点)
  - [7.1 术语](#71-术语)
  - [7.2 核心规则](#72-核心规则)
  - [7.3 Resolution 过程](#73-resolution-过程)

---

## 1. 手写 Promise 实现

### 1.1 基础版本

```javascript
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class MyPromise {
  constructor(executor) {
    this.state = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      if (this.state === PENDING) {
        this.state = FULFILLED;
        this.value = value;
        this.onFulfilledCallbacks.forEach((fn) => fn());
      }
    };

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onFulfilled, onRejected) {
    // 处理值穿透
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (v) => v;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : (e) => {
            throw e;
          };

    const promise2 = new MyPromise((resolve, reject) => {
      const fulfilledMicrotask = () => {
        queueMicrotask(() => {
          try {
            const x = onFulfilled(this.value);
            this.resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      };

      const rejectedMicrotask = () => {
        queueMicrotask(() => {
          try {
            const x = onRejected(this.reason);
            this.resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      };

      if (this.state === FULFILLED) {
        fulfilledMicrotask();
      } else if (this.state === REJECTED) {
        rejectedMicrotask();
      } else if (this.state === PENDING) {
        this.onFulfilledCallbacks.push(fulfilledMicrotask);
        this.onRejectedCallbacks.push(rejectedMicrotask);
      }
    });

    return promise2;
  }

  resolvePromise(promise2, x, resolve, reject) {
    if (promise2 === x) {
      return reject(new TypeError('Chaining cycle detected'));
    }

    if (x instanceof MyPromise) {
      x.then(resolve, reject);
    } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
      let called = false;
      try {
        const then = x.then;
        if (typeof then === 'function') {
          then.call(
            x,
            (y) => {
              if (called) return;
              called = true;
              this.resolvePromise(promise2, y, resolve, reject);
            },
            (r) => {
              if (called) return;
              called = true;
              reject(r);
            }
          );
        } else {
          resolve(x);
        }
      } catch (error) {
        if (called) return;
        called = true;
        reject(error);
      }
    } else {
      resolve(x);
    }
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }

  finally(callback) {
    return this.then(
      (value) => MyPromise.resolve(callback()).then(() => value),
      (reason) =>
        MyPromise.resolve(callback()).then(() => {
          throw reason;
        })
    );
  }

  static resolve(value) {
    if (value instanceof MyPromise) {
      return value;
    }
    return new MyPromise((resolve) => resolve(value));
  }

  static reject(reason) {
    return new MyPromise((_, reject) => reject(reason));
  }

  static all(promises) {
    return new MyPromise((resolve, reject) => {
      const results = [];
      let completedCount = 0;

      if (promises.length === 0) {
        resolve(results);
        return;
      }

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          (value) => {
            results[index] = value;
            completedCount++;
            if (completedCount === promises.length) {
              resolve(results);
            }
          },
          (reason) => {
            reject(reason);
          }
        );
      });
    });
  }

  static race(promises) {
    return new MyPromise((resolve, reject) => {
      promises.forEach((promise) => {
        MyPromise.resolve(promise).then(resolve, reject);
      });
    });
  }

  static allSettled(promises) {
    return new MyPromise((resolve) => {
      const results = [];
      let completedCount = 0;

      if (promises.length === 0) {
        resolve(results);
        return;
      }

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          (value) => {
            results[index] = { status: 'fulfilled', value };
            completedCount++;
            if (completedCount === promises.length) {
              resolve(results);
            }
          },
          (reason) => {
            results[index] = { status: 'rejected', reason };
            completedCount++;
            if (completedCount === promises.length) {
              resolve(results);
            }
          }
        );
      });
    });
  }

  static any(promises) {
    return new MyPromise((resolve, reject) => {
      const errors = [];
      let rejectedCount = 0;

      if (promises.length === 0) {
        reject(new AggregateError([], 'All promises were rejected'));
        return;
      }

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          (value) => {
            resolve(value);
          },
          (reason) => {
            errors[index] = reason;
            rejectedCount++;
            if (rejectedCount === promises.length) {
              reject(new AggregateError(errors, 'All promises were rejected'));
            }
          }
        );
      });
    });
  }
}

// 测试
const p = new MyPromise((resolve) => {
  setTimeout(() => resolve('success'), 1000);
});

p.then((value) => {
  console.log(value); // success
  return value + '!';
}).then((value) => {
  console.log(value); // success!
});
```

## 2. 微任务与宏任务

### 2.1 事件循环中的 Promise

```javascript
console.log('1 - 同步代码');

setTimeout(() => {
  console.log('2 - setTimeout (宏任务)');
}, 0);

Promise.resolve().then(() => {
  console.log('3 - Promise.then (微任务)');
});

queueMicrotask(() => {
  console.log('4 - queueMicrotask (微任务)');
});

console.log('5 - 同步代码');

// 输出顺序:
// 1 - 同步代码
// 5 - 同步代码
// 3 - Promise.then (微任务)
// 4 - queueMicrotask (微任务)
// 2 - setTimeout (宏任务)
```

### 2.2 复杂的执行顺序

```javascript
console.log('script start');

setTimeout(() => {
  console.log('setTimeout 1');
  Promise.resolve().then(() => {
    console.log('promise inside setTimeout');
  });
}, 0);

Promise.resolve()
  .then(() => {
    console.log('promise 1');
    setTimeout(() => {
      console.log('setTimeout inside promise');
    }, 0);
  })
  .then(() => {
    console.log('promise 2');
  });

setTimeout(() => {
  console.log('setTimeout 2');
}, 0);

console.log('script end');

// 输出顺序:
// script start
// script end
// promise 1
// promise 2
// setTimeout 1
// promise inside setTimeout
// setTimeout 2
// setTimeout inside promise
```

### 2.3 async/await 与微任务

```javascript
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end'); // 这里相当于在微任务中执行
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

async1();

new Promise((resolve) => {
  console.log('promise1');
  resolve();
}).then(() => {
  console.log('promise2');
});

console.log('script end');

// 输出顺序:
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

## 3. Promise 高级模式

### 3.1 Promise 队列

```javascript
class PromiseQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  add(promiseFactory) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        promiseFactory,
        resolve,
        reject,
      });
      this.process();
    });
  }

  async process() {
    if (this.processing) return;
    this.processing = true;

    while (this.queue.length > 0) {
      const { promiseFactory, resolve, reject } = this.queue.shift();
      try {
        const result = await promiseFactory();
        resolve(result);
      } catch (error) {
        reject(error);
      }
    }

    this.processing = false;
  }
}

// 使用
const queue = new PromiseQueue();

// 任务会按顺序执行
queue.add(() => {
  console.log('任务1开始');
  return new Promise((r) => setTimeout(() => r('任务1完成'), 1000));
}).then(console.log);

queue.add(() => {
  console.log('任务2开始');
  return new Promise((r) => setTimeout(() => r('任务2完成'), 500));
}).then(console.log);

queue.add(() => {
  console.log('任务3开始');
  return new Promise((r) => setTimeout(() => r('任务3完成'), 200));
}).then(console.log);
```

### 3.2 Promise 调度器

```javascript
class Scheduler {
  constructor(maxConcurrent = 2) {
    this.maxConcurrent = maxConcurrent;
    this.running = 0;
    this.queue = [];
  }

  add(promiseCreator) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        promiseCreator,
        resolve,
        reject,
      });
      this.run();
    });
  }

  run() {
    while (this.running < this.maxConcurrent && this.queue.length > 0) {
      const { promiseCreator, resolve, reject } = this.queue.shift();
      this.running++;

      promiseCreator()
        .then(resolve, reject)
        .finally(() => {
          this.running--;
          this.run();
        });
    }
  }
}

// 测试
const scheduler = new Scheduler(2);

const timeout = (time) =>
  new Promise((resolve) => {
    setTimeout(resolve, time);
  });

const addTask = (time, order) => {
  scheduler.add(() => timeout(time)).then(() => console.log(order));
};

addTask(1000, '1');
addTask(500, '2');
addTask(300, '3');
addTask(400, '4');

// 输出: 2 3 1 4
// 解释:
// 一开始，1、2两个任务进入队列
// 500ms时，2完成，输出2，任务3进入队列
// 800ms时，3完成，输出3，任务4进入队列
// 1000ms时，1完成，输出1
// 1200ms时，4完成，输出4
```

### 3.3 Promise 管道

```javascript
function pipe(...fns) {
  return (input) => fns.reduce((chain, fn) => chain.then(fn), Promise.resolve(input));
}

// 使用
const addOne = async (x) => {
  await new Promise((r) => setTimeout(r, 100));
  return x + 1;
};

const double = async (x) => {
  await new Promise((r) => setTimeout(r, 100));
  return x * 2;
};

const square = async (x) => {
  await new Promise((r) => setTimeout(r, 100));
  return x * x;
};

const pipeline = pipe(addOne, double, square);

pipeline(2).then(console.log); // ((2 + 1) * 2) ^ 2 = 36
```

### 3.4 Promise 分支

```javascript
function branch(condition, onTrue, onFalse) {
  return async (value) => {
    if (await condition(value)) {
      return onTrue(value);
    }
    return onFalse(value);
  };
}

// 使用
const isEven = async (n) => n % 2 === 0;
const processEven = async (n) => `${n} is even`;
const processOdd = async (n) => `${n} is odd`;

const processor = branch(isEven, processEven, processOdd);

processor(4).then(console.log); // 4 is even
processor(5).then(console.log); // 5 is odd
```

## 4. 错误处理高级模式

### 4.1 全局未捕获 Promise 错误处理

```javascript
// 浏览器环境
window.addEventListener('unhandledrejection', (event) => {
  console.error('未处理的 Promise 错误:', event.reason);
  // 阻止默认行为（在控制台打印错误）
  event.preventDefault();
});

// Node.js 环境
process.on('unhandledRejection', (reason, promise) => {
  console.error('未处理的 Promise 错误:', reason);
});

// 测试
Promise.reject(new Error('未捕获的错误'));
```

### 4.2 错误边界模式

```javascript
class AsyncErrorBoundary {
  constructor(fallback) {
    this.fallback = fallback;
  }

  async execute(asyncFn) {
    try {
      return await asyncFn();
    } catch (error) {
      console.error('捕获到错误:', error);
      if (typeof this.fallback === 'function') {
        return this.fallback(error);
      }
      return this.fallback;
    }
  }
}

// 使用
const boundary = new AsyncErrorBoundary((error) => ({
  error: true,
  message: error.message,
  data: null,
}));

async function riskyOperation() {
  throw new Error('操作失败');
}

boundary.execute(riskyOperation).then(console.log);
// { error: true, message: '操作失败', data: null }
```

### 4.3 Result 模式（类似 Rust）

```javascript
class Result {
  constructor(value, error) {
    this.value = value;
    this.error = error;
  }

  static ok(value) {
    return new Result(value, null);
  }

  static err(error) {
    return new Result(null, error);
  }

  isOk() {
    return this.error === null;
  }

  isErr() {
    return this.error !== null;
  }

  unwrap() {
    if (this.isErr()) {
      throw this.error;
    }
    return this.value;
  }

  unwrapOr(defaultValue) {
    return this.isOk() ? this.value : defaultValue;
  }

  map(fn) {
    return this.isOk() ? Result.ok(fn(this.value)) : this;
  }

  mapErr(fn) {
    return this.isErr() ? Result.err(fn(this.error)) : this;
  }
}

// 包装异步函数
async function tryCatch(asyncFn) {
  try {
    const value = await asyncFn();
    return Result.ok(value);
  } catch (error) {
    return Result.err(error);
  }
}

// 使用
async function fetchData() {
  throw new Error('网络错误');
}

const result = await tryCatch(fetchData);

if (result.isOk()) {
  console.log('成功:', result.value);
} else {
  console.log('失败:', result.error.message);
}

// 或者使用 unwrapOr
const data = result.unwrapOr({ default: true });
console.log(data); // { default: true }
```

## 5. Promise 性能优化

### 5.1 批量处理

```javascript
class BatchProcessor {
  constructor(batchFn, options = {}) {
    this.batchFn = batchFn;
    this.maxBatchSize = options.maxBatchSize || 10;
    this.maxWaitTime = options.maxWaitTime || 50;
    this.queue = [];
    this.timeout = null;
  }

  add(item) {
    return new Promise((resolve, reject) => {
      this.queue.push({ item, resolve, reject });

      if (this.queue.length >= this.maxBatchSize) {
        this.flush();
      } else if (!this.timeout) {
        this.timeout = setTimeout(() => this.flush(), this.maxWaitTime);
      }
    });
  }

  async flush() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }

    if (this.queue.length === 0) return;

    const batch = this.queue.splice(0, this.maxBatchSize);
    const items = batch.map((b) => b.item);

    try {
      const results = await this.batchFn(items);
      batch.forEach((b, i) => b.resolve(results[i]));
    } catch (error) {
      batch.forEach((b) => b.reject(error));
    }
  }
}

// 使用 - 批量获取用户
const userBatcher = new BatchProcessor(
  async (userIds) => {
    console.log(`批量获取用户: ${userIds.join(', ')}`);
    // 模拟批量 API 调用
    await new Promise((r) => setTimeout(r, 100));
    return userIds.map((id) => ({ id, name: `User${id}` }));
  },
  { maxBatchSize: 5, maxWaitTime: 10 }
);

// 这些请求会被自动批量处理
Promise.all([
  userBatcher.add(1),
  userBatcher.add(2),
  userBatcher.add(3),
  userBatcher.add(4),
  userBatcher.add(5),
]).then(console.log);
```

### 5.2 延迟执行

```javascript
function lazy(fn) {
  let promise = null;

  return () => {
    if (!promise) {
      promise = fn();
    }
    return promise;
  };
}

// 使用
const expensiveOperation = lazy(async () => {
  console.log('执行昂贵操作...');
  await new Promise((r) => setTimeout(r, 2000));
  return { data: 'expensive result' };
});

// 第一次调用会执行
expensiveOperation().then(console.log);

// 后续调用返回相同的 Promise
expensiveOperation().then(console.log);
expensiveOperation().then(console.log);

// 只会输出一次 "执行昂贵操作..."
```

### 5.3 防抖与节流

```javascript
// 防抖
function debounceAsync(fn, delay) {
  let timeoutId = null;
  let pendingPromise = null;
  let resolve = null;
  let reject = null;

  return function (...args) {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    if (!pendingPromise) {
      pendingPromise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
    }

    timeoutId = setTimeout(async () => {
      try {
        const result = await fn.apply(this, args);
        resolve(result);
      } catch (error) {
        reject(error);
      } finally {
        pendingPromise = null;
        resolve = null;
        reject = null;
      }
    }, delay);

    return pendingPromise;
  };
}

// 使用
const search = debounceAsync(async (query) => {
  console.log(`搜索: ${query}`);
  await new Promise((r) => setTimeout(r, 500));
  return [`${query} 结果1`, `${query} 结果2`];
}, 300);

// 快速连续调用，只有最后一次会执行
search('a').then(console.log);
search('ab').then(console.log);
search('abc').then(console.log);
// 只会搜索 "abc"
```

```javascript
// 节流
function throttleAsync(fn, limit) {
  let lastRun = 0;
  let pendingPromise = null;

  return async function (...args) {
    const now = Date.now();

    if (now - lastRun >= limit) {
      lastRun = now;
      return fn.apply(this, args);
    }

    if (!pendingPromise) {
      pendingPromise = new Promise((resolve) => {
        setTimeout(async () => {
          lastRun = Date.now();
          pendingPromise = null;
          resolve(await fn.apply(this, args));
        }, limit - (now - lastRun));
      });
    }

    return pendingPromise;
  };
}

// 使用
const throttledFetch = throttleAsync(async (url) => {
  console.log(`请求: ${url}`);
  return { data: url };
}, 1000);

// 1秒内只会执行一次
throttledFetch('/api/1').then(console.log);
throttledFetch('/api/2').then(console.log);
throttledFetch('/api/3').then(console.log);
```

## 6. Promise 与 Generator

### 6.1 使用 Generator 实现 async/await

```javascript
function asyncToGenerator(generatorFn) {
  return function (...args) {
    const generator = generatorFn.apply(this, args);

    return new Promise((resolve, reject) => {
      function step(key, arg) {
        let result;
        try {
          result = generator[key](arg);
        } catch (error) {
          return reject(error);
        }

        const { value, done } = result;

        if (done) {
          return resolve(value);
        }

        return Promise.resolve(value).then(
          (val) => step('next', val),
          (err) => step('throw', err)
        );
      }

      step('next');
    });
  };
}

// 使用
function* fetchUserGenerator() {
  const user = yield fetch('/api/user').then((r) => r.json());
  const posts = yield fetch(`/api/posts?userId=${user.id}`).then((r) => r.json());
  return { user, posts };
}

const fetchUser = asyncToGenerator(fetchUserGenerator);

// 等价于
async function fetchUserAsync() {
  const user = await fetch('/api/user').then((r) => r.json());
  const posts = await fetch(`/api/posts?userId=${user.id}`).then((r) => r.json());
  return { user, posts };
}
```

### 6.2 可取消的异步流程

```javascript
function* cancelableFlow() {
  try {
    console.log('步骤 1');
    yield delay(1000);

    console.log('步骤 2');
    yield delay(1000);

    console.log('步骤 3');
    yield delay(1000);

    return '完成';
  } finally {
    console.log('清理工作');
  }
}

function delay(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function runCancelable(generatorFn) {
  const generator = generatorFn();
  let cancelled = false;

  const promise = (async () => {
    let result = generator.next();

    while (!result.done) {
      if (cancelled) {
        generator.return();
        throw new Error('已取消');
      }

      try {
        const value = await result.value;
        result = generator.next(value);
      } catch (error) {
        result = generator.throw(error);
      }
    }

    return result.value;
  })();

  return {
    promise,
    cancel: () => {
      cancelled = true;
    },
  };
}

// 使用
const { promise, cancel } = runCancelable(cancelableFlow);

promise.then(console.log).catch(console.error);

// 1.5秒后取消
setTimeout(cancel, 1500);
```

## 7. Promise A+ 规范要点

### 7.1 术语

- **promise**: 是一个拥有 `then` 方法的对象或函数
- **thenable**: 是一个定义了 `then` 方法的对象或函数
- **value**: 任何 JavaScript 的合法值
- **exception**: 使用 `throw` 语句抛出的值
- **reason**: 表示 promise 被拒绝的原因

### 7.2 核心规则

```javascript
// 1. Promise 状态只能从 pending 转换为 fulfilled 或 rejected
const p1 = new Promise((resolve, reject) => {
  resolve('first');
  resolve('second'); // 无效
  reject('error'); // 无效
});

// 2. then 必须返回一个 promise
const p2 = Promise.resolve(1);
const p3 = p2.then((v) => v + 1);
console.log(p3 instanceof Promise); // true

// 3. 值穿透
Promise.resolve(1)
  .then()
  .then()
  .then((v) => console.log(v)); // 1

Promise.reject(new Error('error'))
  .then()
  .then()
  .catch((e) => console.log(e.message)); // error

// 4. then 的回调必须异步执行（微任务）
console.log('1');
Promise.resolve().then(() => console.log('2'));
console.log('3');
// 输出: 1, 3, 2
```

### 7.3 Resolution 过程

```javascript
// Promise Resolution Procedure: [[Resolve]](promise, x)

// 1. 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行
const p = Promise.resolve().then(() => p); // TypeError: Chaining cycle detected

// 2. 如果 x 是一个 Promise，则使 promise 接受 x 的状态
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(p1);
p2.then(console.log); // 1

// 3. 如果 x 是对象或函数，尝试调用 x.then
const thenable = {
  then(resolve, reject) {
    resolve(42);
  },
};
Promise.resolve(thenable).then(console.log); // 42

// 4. 如果 x 不是对象或函数，以 x 为参数执行 promise
Promise.resolve(123).then(console.log); // 123
```

