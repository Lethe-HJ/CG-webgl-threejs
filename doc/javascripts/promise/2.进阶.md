# Promise 进阶

## 目录

- [1. Promise 静态方法](#1-promise-静态方法)
  - [1.1 Promise.all()](#11-promiseall)
  - [1.2 Promise.allSettled()](#12-promiseallsettled)
  - [1.3 Promise.race()](#13-promiserace)
  - [1.4 Promise.any()](#14-promiseany)
  - [1.5 Promise.withResolvers()](#15-promisewithresolvers)
- [2. async/await 语法糖](#2-asyncawait-语法糖)
  - [2.1 基本用法](#21-基本用法)
  - [2.2 错误处理](#22-错误处理)
  - [2.3 async 函数总是返回 Promise](#23-async-函数总是返回-promise)
  - [2.4 顺序执行 vs 并行执行](#24-顺序执行-vs-并行执行)
- [3. Promise 与循环](#3-promise-与循环)
  - [3.1 for...of 顺序执行](#31-forof-顺序执行)
  - [3.2 map + Promise.all 并行执行](#32-map--promiseall-并行执行)
  - [3.3 forEach 的陷阱](#33-foreach-的陷阱)
  - [3.4 reduce 实现顺序执行](#34-reduce-实现顺序执行)
- [4. Promise 并发控制](#4-promise-并发控制)
  - [4.1 限制并发数量](#41-限制并发数量)
  - [4.2 简化版并发控制](#42-简化版并发控制)
- [5. 取消 Promise](#5-取消-promise)
  - [5.1 使用 AbortController](#51-使用-abortcontroller)
  - [5.2 自定义可取消 Promise](#52-自定义可取消-promise)
- [6. Promise 重试机制](#6-promise-重试机制)
- [7. Promise 缓存](#7-promise-缓存)

---

## 1. Promise 静态方法

### 1.1 Promise.all()

等待所有 Promise 都成功，或者任意一个失败。

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = new Promise((resolve) => {
  setTimeout(() => resolve(3), 1000);
});

// 所有都成功时
Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log(results); // [1, 2, 3]
  })
  .catch((error) => {
    console.error(error);
  });
```

**失败情况：**

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject(new Error('失败了'));
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log(results); // 不会执行
  })
  .catch((error) => {
    console.error('有一个失败:', error.message); // 有一个失败: 失败了
  });
```

**实际应用 - 并行请求：**

```javascript
async function fetchMultipleUsers(userIds) {
  const promises = userIds.map((id) =>
    fetch(`https://api.example.com/users/${id}`).then((res) => res.json())
  );

  try {
    const users = await Promise.all(promises);
    console.log('所有用户:', users);
    return users;
  } catch (error) {
    console.error('获取用户失败:', error);
    throw error;
  }
}

// 模拟使用
// fetchMultipleUsers([1, 2, 3, 4, 5]);
```

### 1.2 Promise.allSettled()

等待所有 Promise 完成（无论成功或失败），返回每个 Promise 的结果状态。

```javascript
const promise1 = Promise.resolve('成功1');
const promise2 = Promise.reject(new Error('失败'));
const promise3 = Promise.resolve('成功2');

Promise.allSettled([promise1, promise2, promise3]).then((results) => {
  console.log(results);
  // [
  //   { status: 'fulfilled', value: '成功1' },
  //   { status: 'rejected', reason: Error: 失败 },
  //   { status: 'fulfilled', value: '成功2' }
  // ]

  // 过滤成功的结果
  const successResults = results
    .filter((r) => r.status === 'fulfilled')
    .map((r) => r.value);
  console.log('成功的结果:', successResults); // ['成功1', '成功2']

  // 过滤失败的结果
  const failedResults = results
    .filter((r) => r.status === 'rejected')
    .map((r) => r.reason);
  console.log('失败的结果:', failedResults); // [Error: 失败]
});
```

### 1.3 Promise.race()

返回第一个完成的 Promise（无论成功或失败）。

```javascript
const promise1 = new Promise((resolve) => setTimeout(() => resolve('慢'), 2000));
const promise2 = new Promise((resolve) => setTimeout(() => resolve('快'), 1000));
const promise3 = new Promise((resolve) => setTimeout(() => resolve('最慢'), 3000));

Promise.race([promise1, promise2, promise3]).then((result) => {
  console.log(result); // '快' - 最先完成的
});
```

**实现超时控制：**

```javascript
function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);

  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`请求超时: ${timeout}ms`));
    }, timeout);
  });

  return Promise.race([fetchPromise, timeoutPromise]);
}

// 使用
fetchWithTimeout('https://api.example.com/data', 3000)
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error(error.message));
```

### 1.4 Promise.any()

返回第一个成功的 Promise，只有所有都失败才会 reject。

```javascript
const promise1 = Promise.reject(new Error('失败1'));
const promise2 = new Promise((resolve) => setTimeout(() => resolve('成功'), 1000));
const promise3 = Promise.reject(new Error('失败2'));

Promise.any([promise1, promise2, promise3])
  .then((result) => {
    console.log(result); // '成功' - 第一个成功的
  })
  .catch((error) => {
    console.error(error); // AggregateError: All promises were rejected
  });
```

**所有都失败的情况：**

```javascript
const promise1 = Promise.reject(new Error('失败1'));
const promise2 = Promise.reject(new Error('失败2'));
const promise3 = Promise.reject(new Error('失败3'));

Promise.any([promise1, promise2, promise3]).catch((error) => {
  console.log(error instanceof AggregateError); // true
  console.log(error.errors); // [Error: 失败1, Error: 失败2, Error: 失败3]
});
```

### 1.5 Promise.withResolvers()

ES2024 新增的方法，可以从外部控制 Promise 的 resolve 和 reject。

```javascript
// ES2024 原生方法
const { promise, resolve, reject } = Promise.withResolvers();

// 可以在任何地方调用 resolve 或 reject
setTimeout(() => {
  resolve('从外部 resolve！');
}, 1000);

promise.then(console.log); // 1秒后输出: 从外部 resolve！
```

**手动实现（兼容旧环境）：**

```javascript
// 方式1: 简单实现
function createDeferred() {
  let resolve, reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}

// 使用
const deferred = createDeferred();

// 在其他地方 resolve
setTimeout(() => {
  deferred.resolve('延迟 resolve');
}, 1000);

deferred.promise.then(console.log);
```

```javascript
// 方式2: 添加到 Promise 原型（Polyfill）
if (!Promise.withResolvers) {
  Promise.withResolvers = function () {
    let resolve, reject;
    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    return { promise, resolve, reject };
  };
}
```

**实际应用场景：**

```javascript
// 场景1: 事件驱动的异步操作
function waitForEvent(element, eventName) {
  const { promise, resolve } = Promise.withResolvers();
  element.addEventListener(eventName, resolve, { once: true });
  return promise;
}

// 使用
const button = document.querySelector('#myButton');
waitForEvent(button, 'click').then((event) => {
  console.log('按钮被点击了', event);
});
```

```javascript
// 场景2: 封装回调 API
function loadImage(src) {
  const { promise, resolve, reject } = Promise.withResolvers();
  
  const img = new Image();
  img.onload = () => resolve(img);
  img.onerror = () => reject(new Error(`加载图片失败: ${src}`));
  img.src = src;
  
  return promise;
}

// 使用
loadImage('https://example.com/image.png')
  .then((img) => document.body.appendChild(img))
  .catch(console.error);
```

```javascript
// 场景3: 实现简单的信号量/锁
class Lock {
  constructor() {
    this.locked = false;
    this.queue = [];
  }

  async acquire() {
    if (!this.locked) {
      this.locked = true;
      return;
    }

    const { promise, resolve } = Promise.withResolvers();
    this.queue.push(resolve);
    return promise;
  }

  release() {
    if (this.queue.length > 0) {
      const next = this.queue.shift();
      next();
    } else {
      this.locked = false;
    }
  }
}

// 使用
const lock = new Lock();

async function criticalSection(id) {
  await lock.acquire();
  console.log(`任务 ${id} 进入临界区`);
  await new Promise((r) => setTimeout(r, 1000));
  console.log(`任务 ${id} 离开临界区`);
  lock.release();
}

// 同时启动多个任务，但会依次执行
criticalSection(1);
criticalSection(2);
criticalSection(3);
```

```javascript
// 场景4: 超时包装器
function withTimeout(asyncFn, timeout) {
  return async function (...args) {
    const { promise: timeoutPromise, reject } = Promise.withResolvers();
    
    const timer = setTimeout(() => {
      reject(new Error(`操作超时: ${timeout}ms`));
    }, timeout);

    try {
      return await Promise.race([asyncFn(...args), timeoutPromise]);
    } finally {
      clearTimeout(timer);
    }
  };
}

// 使用
const fetchWithTimeout = withTimeout(fetch, 5000);
fetchWithTimeout('https://api.example.com/data')
  .then((res) => res.json())
  .catch(console.error);
```

## 2. async/await 语法糖

### 2.1 基本用法

```javascript
// Promise 写法
function fetchData() {
  return fetch('https://api.example.com/data')
    .then((response) => response.json())
    .then((data) => {
      console.log(data);
      return data;
    });
}

// async/await 写法
async function fetchDataAsync() {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  console.log(data);
  return data;
}
```

### 2.2 错误处理

```javascript
// 使用 try/catch
async function fetchUser(id) {
  try {
    const response = await fetch(`https://api.example.com/users/${id}`);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const user = await response.json();
    return user;
  } catch (error) {
    console.error('获取用户失败:', error.message);
    throw error; // 重新抛出或返回默认值
  }
}
```

### 2.3 async 函数总是返回 Promise

```javascript
async function returnValue() {
  return 42;
}

async function returnPromise() {
  return Promise.resolve(42);
}

// 两者等价
returnValue().then((v) => console.log(v)); // 42
returnPromise().then((v) => console.log(v)); // 42

// async 函数中抛出错误等价于返回 rejected Promise
async function throwError() {
  throw new Error('错误');
}

throwError().catch((e) => console.error(e.message)); // 错误
```

### 2.4 顺序执行 vs 并行执行

```javascript
// 模拟异步操作
function delay(ms, value) {
  return new Promise((resolve) => setTimeout(() => resolve(value), ms));
}

// ❌ 顺序执行 - 总时间 3 秒
async function sequential() {
  console.time('sequential');
  const a = await delay(1000, 'a');
  const b = await delay(1000, 'b');
  const c = await delay(1000, 'c');
  console.timeEnd('sequential'); // ~3000ms
  return [a, b, c];
}

// ✅ 并行执行 - 总时间 1 秒
async function parallel() {
  console.time('parallel');
  const [a, b, c] = await Promise.all([
    delay(1000, 'a'),
    delay(1000, 'b'),
    delay(1000, 'c'),
  ]);
  console.timeEnd('parallel'); // ~1000ms
  return [a, b, c];
}
```

## 3. Promise 与循环

### 3.1 for...of 顺序执行

```javascript
async function processSequentially(items) {
  const results = [];

  for (const item of items) {
    const result = await processItem(item);
    results.push(result);
  }

  return results;
}

// 模拟处理函数
async function processItem(item) {
  await new Promise((r) => setTimeout(r, 1000));
  return item * 2;
}

// 使用
processSequentially([1, 2, 3]).then(console.log); // [2, 4, 6] - 约3秒后
```

### 3.2 map + Promise.all 并行执行

```javascript
async function processParallel(items) {
  const promises = items.map((item) => processItem(item));
  return Promise.all(promises);
}

// 使用
processParallel([1, 2, 3]).then(console.log); // [2, 4, 6] - 约1秒后
```

### 3.3 forEach 的陷阱

```javascript
// ❌ 错误：forEach 不会等待 async 回调
async function wrongWay(items) {
  items.forEach(async (item) => {
    await processItem(item);
    console.log(item, '处理完成');
  });
  console.log('全部完成'); // 这会立即执行！
}

// ✅ 正确：使用 for...of
async function rightWay(items) {
  for (const item of items) {
    await processItem(item);
    console.log(item, '处理完成');
  }
  console.log('全部完成'); // 这会在所有处理完成后执行
}
```

### 3.4 reduce 实现顺序执行

```javascript
async function processWithReduce(items) {
  return items.reduce(async (previousPromise, item) => {
    const results = await previousPromise;
    const result = await processItem(item);
    return [...results, result];
  }, Promise.resolve([]));
}

// 使用
processWithReduce([1, 2, 3]).then(console.log); // [2, 4, 6]
```

## 4. Promise 并发控制

### 4.1 限制并发数量

```javascript
async function asyncPool(poolLimit, items, iteratorFn) {
  const results = [];
  const executing = [];

  for (const [index, item] of items.entries()) {
    const promise = Promise.resolve().then(() => iteratorFn(item, index));
    results.push(promise);

    if (poolLimit <= items.length) {
      const executingPromise = promise.then(() => {
        executing.splice(executing.indexOf(executingPromise), 1);
      });
      executing.push(executingPromise);

      if (executing.length >= poolLimit) {
        await Promise.race(executing);
      }
    }
  }

  return Promise.all(results);
}

// 使用示例
async function downloadFiles(urls) {
  const download = async (url) => {
    console.log(`开始下载: ${url}`);
    await new Promise((r) => setTimeout(r, 1000)); // 模拟下载
    console.log(`完成下载: ${url}`);
    return url;
  };

  // 最多同时下载 2 个文件
  const results = await asyncPool(2, urls, download);
  console.log('所有下载完成:', results);
}

// downloadFiles(['file1', 'file2', 'file3', 'file4', 'file5']);
```

### 4.2 简化版并发控制

```javascript
class PromisePool {
  constructor(maxConcurrent) {
    this.maxConcurrent = maxConcurrent;
    this.currentCount = 0;
    this.queue = [];
  }

  async add(promiseFactory) {
    if (this.currentCount >= this.maxConcurrent) {
      await new Promise((resolve) => this.queue.push(resolve));
    }

    this.currentCount++;

    try {
      return await promiseFactory();
    } finally {
      this.currentCount--;
      if (this.queue.length > 0) {
        const next = this.queue.shift();
        next();
      }
    }
  }
}

// 使用
const pool = new PromisePool(2);

async function task(id) {
  console.log(`任务 ${id} 开始`);
  await new Promise((r) => setTimeout(r, 1000));
  console.log(`任务 ${id} 完成`);
  return id;
}

// 添加 5 个任务，但最多同时执行 2 个
Promise.all([
  pool.add(() => task(1)),
  pool.add(() => task(2)),
  pool.add(() => task(3)),
  pool.add(() => task(4)),
  pool.add(() => task(5)),
]).then((results) => {
  console.log('所有任务完成:', results);
});
```

## 5. 取消 Promise

### 5.1 使用 AbortController

```javascript
function fetchWithAbort(url) {
  const controller = new AbortController();
  const signal = controller.signal;

  const promise = fetch(url, { signal })
    .then((response) => response.json())
    .catch((error) => {
      if (error.name === 'AbortError') {
        console.log('请求被取消');
      }
      throw error;
    });

  return {
    promise,
    cancel: () => controller.abort(),
  };
}

// 使用
const { promise, cancel } = fetchWithAbort('https://api.example.com/data');

// 2秒后取消请求
setTimeout(() => {
  cancel();
}, 2000);

promise
  .then((data) => console.log(data))
  .catch((error) => console.error(error.message));
```

### 5.2 自定义可取消 Promise

```javascript
function makeCancelable(promise) {
  let isCanceled = false;

  const wrappedPromise = new Promise((resolve, reject) => {
    promise
      .then((value) => {
        if (!isCanceled) {
          resolve(value);
        }
      })
      .catch((error) => {
        if (!isCanceled) {
          reject(error);
        }
      });
  });

  return {
    promise: wrappedPromise,
    cancel() {
      isCanceled = true;
    },
  };
}

// 使用
const slowPromise = new Promise((resolve) => {
  setTimeout(() => resolve('完成'), 5000);
});

const { promise, cancel } = makeCancelable(slowPromise);

promise.then(console.log).catch(console.error);

// 2秒后取消
setTimeout(() => {
  cancel();
  console.log('已取消');
}, 2000);
```

## 6. Promise 重试机制

```javascript
async function retry(fn, maxRetries = 3, delay = 1000) {
  let lastError;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      console.log(`第 ${i + 1} 次尝试失败，${delay}ms 后重试...`);

      if (i < maxRetries - 1) {
        await new Promise((r) => setTimeout(r, delay));
      }
    }
  }

  throw lastError;
}

// 使用示例
let attemptCount = 0;

async function unreliableOperation() {
  attemptCount++;
  console.log(`执行操作，第 ${attemptCount} 次`);

  if (attemptCount < 3) {
    throw new Error('操作失败');
  }

  return '操作成功';
}

retry(unreliableOperation, 5, 500)
  .then((result) => console.log('最终结果:', result))
  .catch((error) => console.error('所有重试都失败:', error.message));
```

### 指数退避重试

```javascript
async function retryWithExponentialBackoff(fn, maxRetries = 5, baseDelay = 1000) {
  let lastError;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      const delay = baseDelay * Math.pow(2, i); // 指数增长: 1s, 2s, 4s, 8s, 16s
      console.log(`第 ${i + 1} 次失败，${delay}ms 后重试...`);

      if (i < maxRetries - 1) {
        await new Promise((r) => setTimeout(r, delay));
      }
    }
  }

  throw lastError;
}
```

## 7. Promise 缓存

```javascript
function memoizeAsync(fn) {
  const cache = new Map();

  return async function (...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log('从缓存获取');
      return cache.get(key);
    }

    console.log('执行请求');
    const result = await fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 使用
const fetchUser = memoizeAsync(async (id) => {
  const response = await fetch(`https://api.example.com/users/${id}`);
  return response.json();
});

// 第一次调用会发请求
await fetchUser(1);

// 第二次调用从缓存获取
await fetchUser(1);
```

### 带过期时间的缓存

```javascript
function memoizeAsyncWithTTL(fn, ttl = 60000) {
  const cache = new Map();

  return async function (...args) {
    const key = JSON.stringify(args);
    const cached = cache.get(key);

    if (cached && Date.now() - cached.timestamp < ttl) {
      console.log('从缓存获取');
      return cached.value;
    }

    console.log('执行请求');
    const result = await fn.apply(this, args);
    cache.set(key, { value: result, timestamp: Date.now() });
    return result;
  };
}

// 使用 - 缓存 30 秒
const fetchUserWithCache = memoizeAsyncWithTTL(async (id) => {
  await new Promise((r) => setTimeout(r, 1000)); // 模拟请求
  return { id, name: `User${id}` };
}, 30000);
```

