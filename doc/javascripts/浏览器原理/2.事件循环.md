# 浏览器事件循环 (Event Loop)

## 目录

- [1. 什么是事件循环](#1-什么是事件循环)
- [2. 任务队列](#2-任务队列)
  - [2.1 宏任务 (Macro Task)](#21-宏任务-macro-task)
  - [2.2 微任务 (Micro Task)](#22-微任务-micro-task)
- [3. 事件循环执行机制](#3-事件循环执行机制)
  - [3.1 完整执行流程](#31-完整执行流程)
  - [3.2 执行顺序示例](#32-执行顺序示例)
- [4. 浏览器渲染时机](#4-浏览器渲染时机)
  - [4.1 渲染与事件循环的关系](#41-渲染与事件循环的关系)
  - [4.2 requestAnimationFrame](#42-requestanimationframe)
  - [4.3 requestIdleCallback](#43-requestidlecallback)
- [5. 常见面试题解析](#5-常见面试题解析)
  - [5.1 Promise 与 setTimeout](#51-promise-与-settimeout)
  - [5.2 async/await 执行顺序](#52-asyncawait-执行顺序)
  - [5.3 复杂嵌套场景](#53-复杂嵌套场景)
- [6. Node.js 事件循环对比](#6-nodejs-事件循环对比)
- [7. 实际应用场景](#7-实际应用场景)
  - [7.1 避免长任务阻塞](#71-避免长任务阻塞)
  - [7.2 任务调度优化](#72-任务调度优化)

---

## 1. 什么是事件循环

JavaScript 是单线程语言，事件循环是浏览器实现异步的核心机制。它负责协调：
- JavaScript 代码执行
- 事件处理
- 渲染更新
- 网络请求回调

```
┌─────────────────────────────────────────────────────────────────┐
│                         事件循环概览                              │
│                                                                 │
│   ┌─────────────┐                                               │
│   │  调用栈     │  ← JavaScript 代码在这里执行                    │
│   │  (Call      │                                               │
│   │   Stack)    │                                               │
│   └──────┬──────┘                                               │
│          │                                                      │
│          │ 执行完毕后                                             │
│          ▼                                                      │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐      │
│   │  微任务队列  │ ──→ │  渲染更新    │ ──→ │  宏任务队列  │      │
│   │ (Microtask) │     │ (Rendering) │     │ (Macrotask) │      │
│   └─────────────┘     └─────────────┘     └─────────────┘      │
│          ▲                                       │              │
│          └───────────────────────────────────────┘              │
│                         循环                                     │
└─────────────────────────────────────────────────────────────────┘
```

## 2. 任务队列

### 2.1 宏任务 (Macro Task)

宏任务代表一个独立的、完整的工作单元。

```javascript
// 常见的宏任务来源
const macroTasks = {
  // 1. script（整体代码）
  '主代码块': '页面加载时的 <script> 标签内容',
  
  // 2. setTimeout / setInterval
  'setTimeout': () => {
    setTimeout(() => {
      console.log('setTimeout 宏任务');
    }, 0);
  },
  
  // 3. setImmediate（Node.js 环境）
  'setImmediate': () => {
    setImmediate(() => {
      console.log('setImmediate 宏任务');
    });
  },
  
  // 4. I/O 操作
  'I/O': 'XMLHttpRequest、fetch 的回调',
  
  // 5. UI 渲染
  'UI rendering': '浏览器的渲染任务',
  
  // 6. MessageChannel
  'MessageChannel': () => {
    const channel = new MessageChannel();
    channel.port1.onmessage = () => {
      console.log('MessageChannel 宏任务');
    };
    channel.port2.postMessage('');
  },
  
  // 7. postMessage
  'postMessage': () => {
    window.postMessage('', '*');
    window.addEventListener('message', () => {
      console.log('postMessage 宏任务');
    });
  },
};
```

### 2.2 微任务 (Micro Task)

微任务是在当前宏任务执行完毕后立即执行的任务。

```javascript
// 常见的微任务来源
const microTasks = {
  // 1. Promise.then/catch/finally
  'Promise': () => {
    Promise.resolve().then(() => {
      console.log('Promise 微任务');
    });
  },
  
  // 2. async/await（await 之后的代码）
  'async/await': async () => {
    await Promise.resolve();
    console.log('await 之后是微任务');
  },
  
  // 3. queueMicrotask
  'queueMicrotask': () => {
    queueMicrotask(() => {
      console.log('queueMicrotask 微任务');
    });
  },
  
  // 4. MutationObserver
  'MutationObserver': () => {
    const observer = new MutationObserver(() => {
      console.log('MutationObserver 微任务');
    });
    observer.observe(document.body, { childList: true });
    document.body.appendChild(document.createElement('div'));
  },
  
  // 5. process.nextTick（Node.js 环境，优先级最高）
  'process.nextTick': () => {
    process.nextTick(() => {
      console.log('nextTick 微任务');
    });
  },
};
```

**微任务 vs 宏任务优先级：**

```javascript
console.log('1 - 同步代码');

setTimeout(() => {
  console.log('2 - setTimeout（宏任务）');
}, 0);

Promise.resolve().then(() => {
  console.log('3 - Promise（微任务）');
});

queueMicrotask(() => {
  console.log('4 - queueMicrotask（微任务）');
});

console.log('5 - 同步代码');

// 输出顺序：
// 1 - 同步代码
// 5 - 同步代码
// 3 - Promise（微任务）
// 4 - queueMicrotask（微任务）
// 2 - setTimeout（宏任务）
```

## 3. 事件循环执行机制

### 3.1 完整执行流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                        事件循环执行流程                               │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 1. 执行同步代码（当前宏任务）                                   │   │
│  │    - 函数调用入栈                                             │   │
│  │    - 执行完毕出栈                                             │   │
│  │    - 遇到异步任务，分发到对应队列                               │   │
│  └─────────────────────────────┬───────────────────────────────┘   │
│                                │                                    │
│                                ▼                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 2. 检查微任务队列                                             │   │
│  │    - 依次执行所有微任务                                        │   │
│  │    - 微任务中产生的新微任务也会在本轮执行                        │   │
│  │    - 直到微任务队列清空                                        │   │
│  └─────────────────────────────┬───────────────────────────────┘   │
│                                │                                    │
│                                ▼                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 3. 判断是否需要渲染（约 16.67ms 一次，60fps）                   │   │
│  │    - 执行 requestAnimationFrame 回调                          │   │
│  │    - 执行 IntersectionObserver 回调                           │   │
│  │    - 更新渲染（Style → Layout → Paint → Composite）           │   │
│  └─────────────────────────────┬───────────────────────────────┘   │
│                                │                                    │
│                                ▼                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 4. 判断是否有空闲时间                                          │   │
│  │    - 执行 requestIdleCallback 回调                            │   │
│  └─────────────────────────────┬───────────────────────────────┘   │
│                                │                                    │
│                                ▼                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 5. 从宏任务队列取出一个任务执行                                  │   │
│  │    - 回到步骤 1                                               │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**伪代码实现：**

```javascript
// 事件循环伪代码
function eventLoop() {
  while (true) {
    // 1. 执行一个宏任务（如果有）
    const macroTask = macroTaskQueue.shift();
    if (macroTask) {
      execute(macroTask);
    }
    
    // 2. 执行所有微任务
    while (microTaskQueue.length > 0) {
      const microTask = microTaskQueue.shift();
      execute(microTask);
    }
    
    // 3. 如果需要渲染
    if (shouldRender()) {
      // 3.1 执行 requestAnimationFrame 回调
      rafCallbacks.forEach(callback => callback());
      rafCallbacks = [];
      
      // 3.2 渲染更新
      render();
    }
    
    // 4. 如果有空闲时间
    if (hasIdleTime()) {
      // 执行 requestIdleCallback 回调
      idleCallbacks.forEach(callback => {
        if (hasIdleTime()) {
          callback();
        }
      });
    }
  }
}
```

### 3.2 执行顺序示例

```javascript
console.log('=== 开始 ===');

// 宏任务
setTimeout(() => {
  console.log('setTimeout 1');
  
  Promise.resolve().then(() => {
    console.log('setTimeout 1 内部的 Promise');
  });
}, 0);

setTimeout(() => {
  console.log('setTimeout 2');
}, 0);

// 微任务
Promise.resolve().then(() => {
  console.log('Promise 1');
}).then(() => {
  console.log('Promise 2');
});

queueMicrotask(() => {
  console.log('queueMicrotask');
});

console.log('=== 结束 ===');

/* 输出顺序：
=== 开始 ===
=== 结束 ===
Promise 1
queueMicrotask
Promise 2
setTimeout 1
setTimeout 1 内部的 Promise
setTimeout 2
*/
```

**执行过程分析：**

```
第一轮事件循环：
├── 宏任务：主代码块
│   ├── console.log('=== 开始 ===')
│   ├── setTimeout 1 → 放入宏任务队列
│   ├── setTimeout 2 → 放入宏任务队列
│   ├── Promise.then → 放入微任务队列
│   ├── queueMicrotask → 放入微任务队列
│   └── console.log('=== 结束 ===')
│
└── 微任务：
    ├── Promise 1 → console.log('Promise 1')
    │   └── 产生新微任务 Promise 2
    ├── queueMicrotask → console.log('queueMicrotask')
    └── Promise 2 → console.log('Promise 2')

第二轮事件循环：
├── 宏任务：setTimeout 1
│   ├── console.log('setTimeout 1')
│   └── Promise.then → 放入微任务队列
│
└── 微任务：
    └── console.log('setTimeout 1 内部的 Promise')

第三轮事件循环：
└── 宏任务：setTimeout 2
    └── console.log('setTimeout 2')
```

## 4. 浏览器渲染时机

### 4.1 渲染与事件循环的关系

```javascript
// 渲染不是每次事件循环都执行
// 浏览器会智能判断是否需要渲染（通常 60fps，约 16.67ms 一帧）

// 示例：多次修改样式，只会渲染一次
const element = document.getElementById('box');

element.style.width = '100px';
element.style.height = '100px';
element.style.background = 'red';
// 以上三次修改会被合并，只触发一次渲染

// 强制同步布局（应避免）
element.style.width = '100px';
const width = element.offsetWidth; // 强制浏览器立即计算布局
element.style.height = '100px';
const height = element.offsetHeight; // 再次强制计算
// 这会导致两次布局计算，性能较差
```

### 4.2 requestAnimationFrame

`requestAnimationFrame` 在渲染之前执行，非常适合做动画。

```javascript
// requestAnimationFrame 的执行时机
console.log('1 - 同步');

setTimeout(() => {
  console.log('2 - setTimeout');
}, 0);

requestAnimationFrame(() => {
  console.log('3 - requestAnimationFrame');
});

Promise.resolve().then(() => {
  console.log('4 - Promise');
});

console.log('5 - 同步');

/* 
大多数情况下的输出顺序：
1 - 同步
5 - 同步
4 - Promise
3 - requestAnimationFrame
2 - setTimeout

注意：rAF 和 setTimeout 的顺序可能因浏览器状态而异
*/
```

**使用 requestAnimationFrame 实现动画：**

```javascript
// 平滑动画示例
function animate(element, targetX, duration) {
  const startX = element.offsetLeft;
  const distance = targetX - startX;
  const startTime = performance.now();
  
  function step(currentTime) {
    const elapsed = currentTime - startTime;
    const progress = Math.min(elapsed / duration, 1);
    
    // 使用缓动函数
    const easeProgress = easeOutQuad(progress);
    const currentX = startX + distance * easeProgress;
    
    element.style.left = `${currentX}px`;
    
    if (progress < 1) {
      requestAnimationFrame(step);
    }
  }
  
  requestAnimationFrame(step);
}

// 缓动函数
function easeOutQuad(t) {
  return t * (2 - t);
}

// 使用
const box = document.getElementById('box');
animate(box, 500, 1000); // 1秒内移动到 x=500
```

**requestAnimationFrame vs setTimeout 动画：**

```javascript
// ❌ 使用 setTimeout 的动画（不推荐）
function animateWithTimeout(element) {
  let position = 0;
  
  function move() {
    position += 1;
    element.style.left = `${position}px`;
    
    if (position < 500) {
      setTimeout(move, 16); // 约 60fps
    }
  }
  
  move();
}
// 问题：
// 1. 时间不精确，可能与屏幕刷新不同步
// 2. 标签页不可见时仍在执行，浪费资源

// ✅ 使用 requestAnimationFrame 的动画（推荐）
function animateWithRAF(element) {
  let position = 0;
  
  function move() {
    position += 1;
    element.style.left = `${position}px`;
    
    if (position < 500) {
      requestAnimationFrame(move);
    }
  }
  
  requestAnimationFrame(move);
}
// 优势：
// 1. 与屏幕刷新同步，动画更流畅
// 2. 标签页不可见时自动暂停，节省资源
```

### 4.3 requestIdleCallback

在浏览器空闲时执行低优先级任务。

```javascript
// requestIdleCallback 的基本用法
requestIdleCallback((deadline) => {
  // deadline.timeRemaining() 返回当前帧剩余时间（毫秒）
  // deadline.didTimeout 表示是否因超时而执行
  
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    const task = tasks.shift();
    task();
  }
  
  // 如果还有任务，继续请求空闲回调
  if (tasks.length > 0) {
    requestIdleCallback(processIdleTasks);
  }
}, { timeout: 2000 }); // 最多等待 2 秒
```

**实际应用：延迟加载非关键资源**

```javascript
// 延迟加载分析脚本
function loadAnalytics() {
  const script = document.createElement('script');
  script.src = 'https://analytics.example.com/script.js';
  document.body.appendChild(script);
}

// 在浏览器空闲时加载
if ('requestIdleCallback' in window) {
  requestIdleCallback(loadAnalytics, { timeout: 5000 });
} else {
  // 降级方案
  setTimeout(loadAnalytics, 2000);
}
```

**执行时机对比：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    一帧的时间线（16.67ms）                         │
│                                                                 │
│  ┌────────┬──────────┬──────────┬────────┬─────────────────┐   │
│  │  宏任务 │  微任务   │   rAF    │  渲染   │  空闲时间        │   │
│  │        │          │          │        │  (rIC 执行)      │   │
│  └────────┴──────────┴──────────┴────────┴─────────────────┘   │
│  0ms                                                    16.67ms │
│                                                                 │
│  执行顺序：                                                       │
│  1. 宏任务（如 setTimeout 回调）                                   │
│  2. 微任务（如 Promise.then）                                     │
│  3. requestAnimationFrame                                       │
│  4. 渲染（Style → Layout → Paint → Composite）                   │
│  5. requestIdleCallback（如果有空闲时间）                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 5. 常见面试题解析

### 5.1 Promise 与 setTimeout

```javascript
console.log('start');

setTimeout(() => {
  console.log('timeout');
}, 0);

Promise.resolve().then(() => {
  console.log('promise');
});

console.log('end');

// 输出：
// start
// end
// promise
// timeout

// 解析：
// 1. 同步代码先执行：start, end
// 2. 微任务优先于宏任务：promise 先于 timeout
```

### 5.2 async/await 执行顺序

```javascript
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

async1();

new Promise((resolve) => {
  console.log('promise1');
  resolve();
}).then(() => {
  console.log('promise2');
});

console.log('script end');

/* 输出：
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
*/
```

**详细解析：**

```javascript
// await 的本质是 Promise
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

// 等价于：
function async1() {
  console.log('async1 start');
  return Promise.resolve(async2()).then(() => {
    console.log('async1 end');
  });
}

// 执行过程：
// 1. console.log('script start')
// 2. setTimeout 放入宏任务队列
// 3. 执行 async1()
//    - console.log('async1 start')
//    - 执行 async2()，console.log('async2')
//    - await 后的代码放入微任务队列
// 4. new Promise executor 同步执行
//    - console.log('promise1')
//    - .then 放入微任务队列
// 5. console.log('script end')
// 6. 执行微任务队列
//    - console.log('async1 end')
//    - console.log('promise2')
// 7. 执行宏任务
//    - console.log('setTimeout')
```

### 5.3 复杂嵌套场景

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  Promise.resolve().then(() => {
    console.log('3');
  });
  new Promise((resolve) => {
    console.log('4');
    resolve();
  }).then(() => {
    console.log('5');
  });
});

Promise.resolve().then(() => {
  console.log('6');
  setTimeout(() => {
    console.log('7');
  });
});

new Promise((resolve) => {
  console.log('8');
  resolve();
}).then(() => {
  console.log('9');
});

setTimeout(() => {
  console.log('10');
  Promise.resolve().then(() => {
    console.log('11');
  });
});

console.log('12');

/* 输出：
1
8
12
6
9
2
4
3
5
7
10
11
*/
```

**执行过程分析：**

```
第一轮事件循环（宏任务：主代码块）：
├── 同步代码：1, 8, 12
├── setTimeout A → 宏任务队列
├── Promise.then (6) → 微任务队列
├── Promise.then (9) → 微任务队列
└── setTimeout B → 宏任务队列

微任务队列执行：
├── 6 → 输出 6，setTimeout C → 宏任务队列
└── 9 → 输出 9

第二轮事件循环（宏任务：setTimeout A）：
├── 同步代码：2, 4
├── Promise.then (3) → 微任务队列
└── Promise.then (5) → 微任务队列

微任务队列执行：
├── 3 → 输出 3
└── 5 → 输出 5

第三轮事件循环（宏任务：setTimeout C）：
└── 同步代码：7

第四轮事件循环（宏任务：setTimeout B）：
├── 同步代码：10
└── Promise.then (11) → 微任务队列

微任务队列执行：
└── 11 → 输出 11
```

## 6. Node.js 事件循环对比

```
┌─────────────────────────────────────────────────────────────────┐
│                     Node.js 事件循环                              │
│                                                                 │
│   ┌───────────────────────────────────────────────────────┐    │
│   │                     timers                             │    │
│   │              setTimeout, setInterval                   │    │
│   └─────────────────────────┬─────────────────────────────┘    │
│                             │                                   │
│                             ▼                                   │
│   ┌───────────────────────────────────────────────────────┐    │
│   │                  pending callbacks                     │    │
│   │              系统操作的回调（如 TCP 错误）                │    │
│   └─────────────────────────┬─────────────────────────────┘    │
│                             │                                   │
│                             ▼                                   │
│   ┌───────────────────────────────────────────────────────┐    │
│   │                    idle, prepare                       │    │
│   │                    内部使用                             │    │
│   └─────────────────────────┬─────────────────────────────┘    │
│                             │                                   │
│                             ▼                                   │
│   ┌───────────────────────────────────────────────────────┐    │
│   │                       poll                             │    │
│   │              I/O 回调（文件、网络等）                    │    │
│   └─────────────────────────┬─────────────────────────────┘    │
│                             │                                   │
│                             ▼                                   │
│   ┌───────────────────────────────────────────────────────┐    │
│   │                       check                            │    │
│   │                   setImmediate                         │    │
│   └─────────────────────────┬─────────────────────────────┘    │
│                             │                                   │
│                             ▼                                   │
│   ┌───────────────────────────────────────────────────────┐    │
│   │                   close callbacks                      │    │
│   │              关闭事件回调（如 socket.close）             │    │
│   └───────────────────────────────────────────────────────┘    │
│                                                                 │
│   注意：每个阶段之间都会执行 process.nextTick 和 Promise 微任务   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Node.js 与浏览器的主要区别：**

```javascript
// Node.js 特有的 API
// 1. process.nextTick - 优先级最高的微任务
process.nextTick(() => {
  console.log('nextTick');
});

Promise.resolve().then(() => {
  console.log('promise');
});

// 输出：nextTick, promise
// process.nextTick 优先于 Promise

// 2. setImmediate - 在 check 阶段执行
setImmediate(() => {
  console.log('immediate');
});

setTimeout(() => {
  console.log('timeout');
}, 0);

// 输出顺序不确定，取决于事件循环启动时间
// 但在 I/O 回调中，setImmediate 总是先执行
```

## 7. 实际应用场景

### 7.1 避免长任务阻塞

```javascript
// ❌ 长任务阻塞示例
function processLargeArray(array) {
  for (let i = 0; i < array.length; i++) {
    // 耗时操作
    heavyComputation(array[i]);
  }
}
// 问题：页面会卡顿，无法响应用户操作

// ✅ 使用时间切片优化
async function processLargeArrayOptimized(array) {
  const CHUNK_SIZE = 100;
  
  for (let i = 0; i < array.length; i += CHUNK_SIZE) {
    const chunk = array.slice(i, i + CHUNK_SIZE);
    
    // 处理一小块
    chunk.forEach(item => heavyComputation(item));
    
    // 让出主线程，允许渲染和用户交互
    await new Promise(resolve => setTimeout(resolve, 0));
  }
}
```

**使用 requestIdleCallback 处理低优先级任务：**

```javascript
// 低优先级任务队列
const lowPriorityTasks = [];

function scheduleLowPriorityTask(task) {
  lowPriorityTasks.push(task);
  scheduleIdleWork();
}

function scheduleIdleWork() {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(processIdleTasks);
  } else {
    setTimeout(processIdleTasks, 1);
  }
}

function processIdleTasks(deadline) {
  while (
    lowPriorityTasks.length > 0 &&
    (deadline?.timeRemaining() > 0 || !deadline)
  ) {
    const task = lowPriorityTasks.shift();
    task();
  }
  
  if (lowPriorityTasks.length > 0) {
    scheduleIdleWork();
  }
}

// 使用
scheduleLowPriorityTask(() => {
  console.log('低优先级任务 1');
});

scheduleLowPriorityTask(() => {
  console.log('低优先级任务 2');
});
```

### 7.2 任务调度优化

```javascript
// 任务调度器
class TaskScheduler {
  constructor() {
    this.highPriorityQueue = [];  // 微任务级别
    this.normalPriorityQueue = []; // 宏任务级别
    this.lowPriorityQueue = [];    // 空闲时执行
  }
  
  // 高优先级任务（微任务）
  scheduleHighPriority(task) {
    this.highPriorityQueue.push(task);
    queueMicrotask(() => this.flushHighPriority());
  }
  
  // 普通优先级任务（宏任务）
  scheduleNormalPriority(task) {
    this.normalPriorityQueue.push(task);
    setTimeout(() => this.flushNormalPriority(), 0);
  }
  
  // 低优先级任务（空闲时）
  scheduleLowPriority(task) {
    this.lowPriorityQueue.push(task);
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() => this.flushLowPriority());
    } else {
      setTimeout(() => this.flushLowPriority(), 100);
    }
  }
  
  flushHighPriority() {
    while (this.highPriorityQueue.length > 0) {
      const task = this.highPriorityQueue.shift();
      task();
    }
  }
  
  flushNormalPriority() {
    const task = this.normalPriorityQueue.shift();
    if (task) {
      task();
      if (this.normalPriorityQueue.length > 0) {
        setTimeout(() => this.flushNormalPriority(), 0);
      }
    }
  }
  
  flushLowPriority() {
    const task = this.lowPriorityQueue.shift();
    if (task) {
      task();
      if (this.lowPriorityQueue.length > 0) {
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => this.flushLowPriority());
        } else {
          setTimeout(() => this.flushLowPriority(), 100);
        }
      }
    }
  }
}

// 使用
const scheduler = new TaskScheduler();

// 用户交互响应 - 高优先级
scheduler.scheduleHighPriority(() => {
  console.log('立即响应用户点击');
});

// 数据处理 - 普通优先级
scheduler.scheduleNormalPriority(() => {
  console.log('处理数据');
});

// 日志上报 - 低优先级
scheduler.scheduleLowPriority(() => {
  console.log('上报日志');
});
```

**Vue/React 的调度机制参考：**

```javascript
// Vue 的 nextTick 实现原理
const callbacks = [];
let pending = false;

function nextTick(cb) {
  callbacks.push(cb);
  
  if (!pending) {
    pending = true;
    // 优先使用微任务
    Promise.resolve().then(flushCallbacks);
  }
}

function flushCallbacks() {
  pending = false;
  const copies = callbacks.slice(0);
  callbacks.length = 0;
  copies.forEach(cb => cb());
}

// 使用
nextTick(() => {
  console.log('DOM 更新后执行');
});
```

