{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "## 更新类型数组\r\n\r\n```js\r\nconst vertices = new Float32Array(VERTICES_LENGTH_ALL);\r\nthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n\r\nthis.attributes.position.array = new_vertices; // 直接覆盖或者修改成员\r\n// this.attributes.position.array[0] = 0;\r\nthis.attributes.position.needsUpdate = true;\r\n```\r\n\r\n这里的`new Float32BufferAttribute` 会对vertices做深拷贝后续修改vertices无效 应该直接对`this.attributes.position.array`做修改\r\n然后再标记更新\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## THREE的类型数组\r\n\r\n+ THREE.Float64BufferAttribute \r\n+ THREE.Float32BufferAttribute\r\n+ THREE.Float16BufferAttribute \r\n+ THREE.Uint32BufferAttribute\r\n+ THREE.Int32BufferAttribute \r\n+ THREE.Uint16BufferAttribute\r\n+ THREE.Int16BufferAttribute \r\n+ THREE.Uint8ClampedBufferAttribute\r\n+ THREE.Uint8BufferAttribute \r\n+ THREE.Int8BufferAttribute\r\n\r\n其中`THREE.Uint8BufferAttribute` 和 `THREE.Uint8ClampedBufferAttribute` 都是 Three.js 中用于表示无符号 8 位整数的缓冲属性，但它们之间有一个关键的区别：\r\n\r\n1. **值的处理方式**：\r\n    - `THREE.Uint8BufferAttribute`：这种属性存储的值是普通的无符号 8 位整数，范围在 0 到 255 之间。当你将值存储在 `Uint8BufferAttribute` 中时，它们可以超出这个范围，因此可以存储负数或大于 255 的数值。这在某些情况下可能会导致不期望的结果，尤其是在图像处理等需要精确范围的任务中。\r\n    - `THREE.Uint8ClampedBufferAttribute`：相比之下，这种属性存储的值是被\"夹紧\"（clamped）到 0 到 255 范围内。这意味着如果你尝试存储小于 0 的值，它会被设置为 0；如果尝试存储大于 255 的值，它会被设置为 255。这确保了存储的值始终在合法范围内。\r\n\r\n2. **应用场景**：\r\n    - `THREE.Uint8BufferAttribute`：通常用于不需要值被限制在 0 到 255 范围内的情况。例如，它可以用于存储灰度图像的像素数据，其中像素值在 0 到 255 之间。\r\n    - `THREE.Uint8ClampedBufferAttribute`：通常用于需要确保值始终在 0 到 255 范围内的情况，特别是在颜色表示和图像处理中，以避免产生不合理的颜色或效果。\r\n\r\n总之，区别在于数据的范围和处理方式。如果你需要确保值在 0 到 255 范围内，不会溢出或产生异常，那么 `THREE.Uint8ClampedBufferAttribute` 是更安全的选择。如果你不需要这种夹紧行为，可以使用 `THREE.Uint8BufferAttribute`。选择哪个取决于你的具体应用场景和需求。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "HTTPS (超文本传输安全协议) 是基于 SSL/TLS 的 HTTP 协议。SSL/TLS 是一种提供数据传输加密、服务器认证、消息完整性和可选的客户端认证的协议。要理解 HTTPS 的工作原理和安全性，首先需要了解 SSL/TLS 的一些基本概念和步骤：\r\n\r\n1. **公钥和私钥**：\r\n   - 公钥加密，只有对应的私钥可以解密。\r\n   - 私钥加密，只有对应的公钥可以解密。\r\n\r\n2. **握手过程**：\r\n   - 客户端发起连接请求。\r\n   - 服务器回应并提供其数字证书。这个证书包含服务器的公钥和由受信任的证书颁发机构 (CA) 签名。\r\n   - 客户端验证服务器的证书（通过比较它与系统中存储的受信任 CA 列表）。\r\n   - 客户端使用服务器的公钥加密一个随机生成的“预主密钥”并将其发送给服务器。\r\n   - 服务器使用其私钥解密并获取这个“预主密钥”。\r\n   - 服务器和客户端都使用这个“预主密钥”来生成会话密钥，用于加密和解密信息。\r\n\r\n3. **数据传输过程**：服务器和客户端使用从“预主密钥”派生出的会话密钥加密和解密数据。\r\n\r\n4. **安全性**：\r\n   - **认证**：由于证书由受信任的 CA 签名，因此客户端可以验证服务器的身份。这可以防止中间人攻击。\r\n   - **加密**：数据被加密，即使被拦截，也无法被解读。\r\n   - **完整性**：SSL/TLS 使用消息摘要来确保数据在传输过程中没有被篡改。\r\n\r\n5. **为什么这是安全的**：\r\n   - 私钥从不在网络上传输。\r\n   - 即使攻击者截获了由公钥加密的“预主密钥”，他们也无法解密它，除非他们有对应的私钥。\r\n   - 即使攻击者有服务器的数字证书和公钥，他们也无法伪造服务器的身份，因为他们没有对应的私钥来解密客户端发送的“预主密钥”。\r\n\r\n然而，HTTPS 和 SSL/TLS 不是完全不可攻破的。例如，它们可能受到特定的加密算法弱点、证书颁发机构的安全问题或服务器配置错误的影响。但总体上，当正确实施和配置时，HTTPS 提供了一个高度安全的数据传输机制。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "在Three.js中，每个`Geometry`或`BufferGeometry`对象都可以有一个边界球（Bounding Sphere），这是一个简单的球体，用于包含该几何体的所有顶点。边界球在各种图形计算中很有用，例如碰撞检测、视锥裁剪或其他优化技术。\r\n\r\n`geometry.computeBoundingSphere()`方法是为了计算这个边界球。当你调用此方法时，它将遍历几何体的所有顶点，并找出一个中心点和半径，使得这个球体可以包含几何体的所有点。\r\n\r\n以下是这个方法的一些关键点：\r\n\r\n1. **中心** (`geometry.boundingSphere.center`)：这是一个`Vector3`对象，表示边界球的中心。\r\n\r\n2. **半径** (`geometry.boundingSphere.radius`)：这是一个数字，表示从边界球中心到其表面的距离。\r\n\r\n3. **何时调用**：这个方法不是自动调用的。也就是说，如果你修改了几何体的顶点并想更新边界球，你需要手动调用`computeBoundingSphere()`。但请注意，不必频繁地在每一帧调用它，因为这可能会影响性能。只在确实需要时（例如在几何体变化后）调用它。\r\n\r\n4. **用途**：边界球常用于“粗糙”的碰撞检测或距离估计。因为球体测试通常比精确的多边形测试要快得多。例如，如果两个物体的边界球都没有相交，那么这两个物体肯定没有碰撞。但如果它们的边界球相交，你可能需要进一步的测试来确定它们是否真的碰撞。\r\n\r\n总的来说，`geometry.computeBoundingSphere()`是一个在Three.js中计算和更新几何体边界球的有用方法。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## PointerEvent\r\nPointerEvent 中有两个与按钮相关的属性：button 和 buttons。\r\n\r\nbutton\r\n\r\nbutton 属性用于标识哪个按钮被按下或释放。它返回一个整数，表示按下或释放的按钮。对于鼠标事件，这些整数的意义如下：\r\n\r\n0: 主按钮（通常是左键）\r\n1: 中键（鼠标中间的滚轮按钮）\r\n2: 次按钮（通常是右键）\r\n3: 第四个按钮（通常在游戏鼠标上可见）\r\n4: 第五个按钮（同样通常在某些特殊鼠标上可见）\r\nbuttons\r\n\r\n与 button 不同，buttons 属性用于描述在事件发生时哪些按钮是被按下的状态。这是一个按位字段，不同的按钮对应的值如下：\r\n\r\n1: 主按钮（通常是左键）\r\n2: 次按钮（通常是右键）\r\n4: 中键（鼠标中间的滚轮按钮）\r\n8: 第四个按钮\r\n16: 第五个按钮\r\n因此，如果主按钮和中键都被按下，buttons 的值会是 1 + 4 = 5。\r\n\r\n这些属性特别有用，尤其当你想根据用户与设备的交互来执行不同的操作时，例如区分左键点击、右键点击或多个按钮同时被按下的情况。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 显卡\r\n\r\n集成显卡（Integrated Graphics）、核显（一个通常用于指代某些集成显卡的术语，尤其是Intel的）和独立显卡（Dedicated Graphics）是三种主要的显卡类型。以下是它们的区别和各自的优势：\r\n\r\n**集成显卡** (Integrated Graphics):\r\n\r\n定义：集成显卡是内嵌在主板或CPU中的显卡。它使用系统的RAM作为其显存。\r\n优势：\r\n成本：通常比独立显卡便宜。\r\n功耗与热量：通常比独立显卡低。\r\n空间：不需要额外的空间或插槽，因为它是集成的。\r\n足够的日常任务：对于日常办公、网页浏览和视频播放等基本任务，集成显卡已经足够。\r\n\r\n**核显** (e.g., Intel HD Graphics):\r\n\r\n定义：核显是集成显卡的一种，通常集成在CPU芯片中。尤其是在某些Intel处理器中，这种显卡被称为“核显”。\r\n优势：\r\n性能与效率：尽管核显是集成的，但在过去的几年中，它的性能已经得到了很大的提升，尤其是对于中等图形任务。\r\n快速同步内存访问：由于它与CPU集成在同一芯片上，核显可以快速地访问主存储器。\r\n\r\n核显由于集成在CPU芯片上，可以利用CPU的多级缓存，特别是L3缓存，这对于某些图形任务来说可以提供更高的性能。\r\n\r\n这种缓存共享可以为图形处理提供以下优势：\r\n\r\n数据访问速度：CPU和GPU可以更快速地共享数据，因为它们可以利用相同的缓存结构，而不是通过系统内存。\r\n低延迟：在CPU和GPU之间共享数据的延迟会减少，因为数据不需要来回传输到主内存。\r\n能效：使用缓存来共享数据通常比使用主内存更为节能。\r\n然而，对于高端图形处理任务，专用GPU（独立显卡）仍然具有明显的优势，因为它们具有专用的显存（例如GDDR6），这种显存的带宽和速度远超过常规的系统RAM和CPU的缓存。但对于集成解决方案，能够利用CPU的多级缓存是一个很大的优势，尤其是在处理轻到中等图形任务时。\r\n\r\n**独立显卡** (Dedicated Graphics):\r\n\r\n定义：独立显卡是一个单独的硬件组件，拥有自己的显存，通常插在主板上的PCIe插槽上。\r\n优势：\r\n性能：独立显卡通常提供比集成显卡更高的性能，特别是高端模型。\r\n专用显存：拥有自己的显存，不会与系统的RAM共享，这对于图形密集型任务特别有利。\r\n多重显示支持：独立显卡通常支持多个显示器。\r\n专业与游戏应用：对于专业的图形设计、3D建模、高清视频编辑和高级游戏，独立显卡是必需的。\r\n\r\n*是不是可以这样理解 独立显卡无法利用cpu的高速缓存 但核显可以 所以在处理轻到中等图形任务时核显反而可能性能更强 ?*\r\n    由于核显直接集成在CPU芯片上，它可以更直接地访问CPU的多级缓存（尤其是L3缓存），这在某些场景中可以为它提供优势。然而，即使有这个优势，核显的绝对性能仍然通常低于中高端的独立显卡。\r\n    对于轻到中等图形任务，核显可能提供了足够的性能，并且在某些特定情况下，由于能够更快地访问CPU缓存，可能会略微超过某些入门级的独立显卡。但这不意味着核显在这些场景中总是优于独立显卡。\r\n    以下是一些要考虑的点：\r\n        显存的重要性：高端独立显卡使用专用的高速显存（如GDDR6），它的带宽远远超过常规DDR4或DDR5系统RAM。这种专用显存对于高分辨率、高纹理质量的图形任务至关重要。\r\n        并行处理能力：独立显卡通常拥有更多的处理单元和更高的并行处理能力，这对于图形计算来说是非常重要的。\r\n        特定优化：许多图形软件和游戏都针对独立显卡进行了优化，因此在实际使用中，即使核显在理论上有某些优势，实际性能仍然可能落后。\r\n        所以，总的来说，虽然核显可以利用CPU的高速缓存并在某些场景中提供良好的性能，但独立显卡在大多数图形密集型任务中仍然占据优势。不过，对于轻到中等的日常任务，现代核显绝对是一个非常可靠和有效的选择。\r\n\r\n\r\n*所以另外一个我比较好奇的问题是 是cpu的多级缓存速度快 还是独立显卡的显存快*\r\n    比较CPU的多级缓存与独立显卡的显存的速度是一个有趣的问题。这两者的设计和用途有很大的区别，但为了简化比较，我们可以考虑以下几点：\r\n    访问速度：\r\n        CPU缓存：CPU的L1、L2和L3缓存被设计为高速、低延迟存储，尤其是L1和L2。它们的目标是最小化从主内存访问数据的延迟。\r\n        显卡显存：显存（如GDDR6）被设计为提供非常高的带宽，尤其是为了图形任务，这些任务通常需要大量数据并行处理。虽然显存也很快，但其主要的优势是高带宽而不是低延迟。\r\n    结论：\r\n        对于单次的小数据访问（例如，访问一个单独的数据项或指令），CPU的L1或L2缓存通常提供更低的延迟，因此“更快”。\r\n        对于大量数据的并行访问（例如，图形渲染或大规模计算），独立显卡的显存提供更高的带宽，因此在这种场景下更为高效。\r\n    用途：\r\n        由于CPU和GPU的工作负载通常有很大的区别，这两种存储类型被优化以适应它们的特定任务。CPU的多级缓存旨在快速访问经常使用的小数据片段或指令，而显存被设计为能够同时处理大量的图形数据。\r\n    总的来说，简单地问“哪个更快”可能不是一个完整的问题。更具体的问题是“在哪种工作负载下哪个更快”。但是，如果你只是好奇它们在单次访问上的速度差异，那么CPU的L1和L2缓存通常有更低的延迟。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "GPU（图形处理单元）最初是为了加速图形渲染而设计的，但随着时间的推移，它们已经发展成为高度并行的计算设备，可以执行大量的并行操作。以下是GPU能进行并行计算的原理：\r\n\r\n多处理器架构：现代GPU包含数百到数千个处理器核心。这些核心被组织成多个“流多处理器”或“计算单元”。每个流多处理器可以独立地执行指令和管理数据。\r\n\r\n数据并行性：GPU是为数据并行计算设计的，这意味着它们可以同时处理大量的数据元素。例如，在图形渲染中，每个像素或顶点都可以被并行处理。\r\n\r\n线程并行性：GPU支持大量的并行线程。这些线程被组织成线程块和线程网格，允许它们在执行时共享数据和同步。\r\n\r\n高带宽内存：为了支持高度并行的数据处理，GPU配备了高带宽的内存，这使得它们能够快速地读取和写入大量的数据。\r\n\r\nSIMD（单指令多数据流）：GPU的每个流多处理器都使用SIMD架构，这意味着在每个时钟周期内，一个指令可以被应用到多个数据元素上。\r\n\r\n灵活的执行模型：虽然GPU是为高度并行的任务设计的，但它们也支持条件执行和循环，这使得它们可以执行更复杂的计算任务。\r\n\r\n专用硬件加速：GPU还包括为特定任务（如纹理采样或深度测试）设计的专用硬件，这进一步提高了其性能。\r\n\r\n总之，GPU的并行计算能力来自其多核架构、数据和线程并行性、高带宽内存和专用硬件加速。这使得GPU非常适合执行需要大量并行处理的任务，如图形渲染、科学计算和深度学习。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## WebAssembly\r\n\r\nWebAssembly（简称Wasm）是一个为浏览器设计的低级二进制代码格式，旨在为高级语言（如C、C++和Rust）提供一个快速、效率高的目标。由于它几乎与原生代码运行速度相当，WebAssembly常常被用来加速那些对性能有高要求的Web应用。\r\n\r\n对于Web3D工程师来说，使用WebAssembly技术对图形相关的算法进行优化确实有较大的意义，特别是在以下几个场景中：\r\n\r\n1. **计算密集型任务**：一些3D图形应用，如实时光线追踪、流体模拟、粒子系统等，涉及大量计算。使用WebAssembly可以显著提高这些算法的运行速度。\r\n\r\n2. **已有的C/C++图形库**：许多成熟的3D图形库和工具都是用C或C++编写的。使用WebAssembly，可以将这些库直接编译到Web平台上，从而避免从头开始编写JavaScript实现。\r\n\r\n3. **并行计算**：虽然WebWorkers可以在Web上实现多线程，但与WebAssembly结合使用时，尤其是在进行并行计算时，可以更高效地利用多核心处理器。\r\n\r\n4. **内存控制**：与JavaScript相比，WebAssembly提供了更为精确的内存控制。这对于3D图形应用来说很重要，因为它们常常需要管理大量的资源，如纹理、模型和场景数据。\r\n\r\n5. **与其他Web技术结合**：你可以选择只将性能瓶颈部分的代码转移到WebAssembly，而保留其他部分的JavaScript代码。这种混合使用可以确保你既享受WebAssembly的性能优势，又能保留JavaScript的灵活性。\r\n\r\n总之，对于Web3D工程师来说，WebAssembly提供了一个强大的工具，用于提速图形相关的算法和任务。当你遇到性能瓶颈，或需要将已有的C/C++图形代码带到Web上时，WebAssembly都是一个值得考虑的选择。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 三维线性插值\r\n\r\n```js\r\nconst { get } = require('lodash');\r\nconst math = require('mathjs');\r\n\r\nfunction lerp(a, b, t) {\r\n    if (t === 0) return a;\r\n    return a + (b - a) * t;\r\n}\r\n\r\nfunction trilinearInterpolation(data, position) {\r\n    let [x, y, z] = position.map((v) => Math.floor(v)),\r\n        [a, b, c] = position.map((v) => v % 1);\r\n    let x0y0 = lerp(get(data, [x, y, z]), get(data, [x + 1, y, z]), a);\r\n    let x1y0 = lerp(get(data, [x, y + 1, z]), get(data, [x + 1, y + 1, z]), a);\r\n    let x0y1 = lerp(get(data, [x, y, z + 1]), get(data, [x + 1, y, z + 1]), a);\r\n    let x1y1 = lerp(get(data, [x, y + 1, z + 1]), get(data, [x + 1, y + 1, z + 1]), a);\r\n    let y0 = lerp(x0y0, x1y0, b);\r\n    let y1 = lerp(x0y1, x1y1, b);\r\n    let d = lerp(y0, y1, c);\r\n    return d;\r\n}\r\n\r\nfunction smooth(data, factor) {\r\n    let shape = math.size(data);\r\n    // factor = Array.isArray(factor) ? factor : Array(3).fill(factor);\r\n    let out_shape = math.add(math.multiply(math.subtract(shape, 1), factor), 1);\r\n    let out_data = math.zeros(out_shape);\r\n    for (let i = 0; i < out_shape[0]; i++) {\r\n        for (let j = 0; j < out_shape[1]; j++) {\r\n            for (let k = 0; k < out_shape[2]; k++) {\r\n                out_data[i][j][k] = trilinearInterpolation(data, [\r\n                    i / factor,\r\n                    j / factor,\r\n                    k / factor\r\n                ]);\r\n            }\r\n        }\r\n    }\r\n    return out_data;\r\n}\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 从点云得到等值面\r\n\r\n```js\r\n/* eslint-disable max-nested-callbacks */\r\n/* eslint-disable no-sequences */\r\nconst path = require('path');\r\nconst math = require('mathjs');\r\nconst { BaseWorker } = require('@eacomp/worker');\r\nconst isosurface = require('../../utils/surfacenets');\r\n\r\nconst ab3 = 1.8897261235859486 ** 3;\r\n// const { LoopSubdivision } = require('three-subdivide');\r\n\r\nclass IsosurfaceWorker {\r\n    constructor(port) {\r\n        const options = {};\r\n        if (process.env.PROCESS_DEBUG_ENABLE === 'yes')\r\n            options.execArgv = [`--inspect-brk=${port ?? '9007'}`];\r\n        const worker_resource = path.join(__dirname, './worker_linear_interpolation.js');\r\n        this.worker = new BaseWorker(worker_resource, options);\r\n    }\r\n\r\n    async start() {\r\n        await this.worker.start();\r\n        return this;\r\n    }\r\n\r\n    async close() {\r\n        await this.worker.close();\r\n        return this;\r\n    }\r\n\r\n    async generateSmoothData(data, factor) {\r\n        console.time('generateSmoothData');\r\n        const res = await this.worker.send('crystal.linearInterpolation', data, factor);\r\n        if (res.code !== 100) {\r\n            console.log(`晶体结构: 插值失败!`);\r\n            console.error(res.message);\r\n        }\r\n        console.timeEnd('generateSmoothData');\r\n        return res.data;\r\n    }\r\n}\r\n\r\nclass ConcaveGeometry extends THREE.BufferGeometry {\r\n    constructor() {\r\n        super();\r\n        this.type = 'ConcaveGeometry';\r\n        this.vertices = [];\r\n        this.normals = [];\r\n    }\r\n\r\n    renderGeometry(positions, cells) {\r\n        cells.forEach((face) => {\r\n            const [i1, i2, i3] = face;\r\n            const triangle = new THREE.Triangle();\r\n            const [c1, c2, c3] = [positions[i1], positions[i2], positions[i3]];\r\n            const [p1, p2, p3] = [\r\n                new THREE.Vector3().fromArray(c1),\r\n                new THREE.Vector3().fromArray(c2),\r\n                new THREE.Vector3().fromArray(c3)\r\n            ];\r\n            this.vertices.push(...c1, ...c2, ...c3);\r\n            triangle.set(p1, p2, p3);\r\n            let normal = new THREE.Vector3();\r\n            triangle.getNormal(normal);\r\n            normal = normal.toArray();\r\n            this.normals.push(...normal, ...normal, ...normal);\r\n        });\r\n        this.setAttribute('position', new THREE.Float32BufferAttribute(this.vertices, 3));\r\n        this.setAttribute('normal', new THREE.Float32BufferAttribute(this.normals, 3));\r\n    }\r\n}\r\n\r\nclass PointsPlaneShapeGeometry extends THREE.BufferGeometry {\r\n    constructor(points, config, matrix) {\r\n        super();\r\n        this.type = 'PointsPlaneShapeGeometry';\r\n        this.vertices = [];\r\n        this.normals = [];\r\n        this.matrix = matrix;\r\n        this.planeNormal = this.getNormal(config);\r\n        this.renderGeometry(points, config);\r\n    }\r\n\r\n    getNormal(config) {\r\n        const { length, dim } = config;\r\n        const normal = new THREE.Vector3();\r\n        if (dim === 0) {\r\n            if (length === 0) {\r\n                normal.fromArray([-1, 0, 0]);\r\n            } else {\r\n                normal.fromArray([-1, 0, 0]);\r\n            }\r\n        } else if (dim === 1) {\r\n            if (length === 0) {\r\n                normal.fromArray([0, 1, 0]);\r\n            } else {\r\n                normal.fromArray([0, 1, 0]);\r\n            }\r\n        } else {\r\n            if (length === 0) {\r\n                normal.fromArray([0, 0, -1]);\r\n            } else {\r\n                normal.fromArray([0, 0, -1]);\r\n            }\r\n        }\r\n        const m = new THREE.Matrix3().set(...this.matrix.flat());\r\n        return normal.applyMatrix3(m).normalize();\r\n    }\r\n\r\n    /**\r\n     * a------b\r\n     * |    / |\r\n     * | /    |\r\n     * d------c\r\n     * @param {} param0\r\n     */\r\n    createSquare([a, b, c, d]) {\r\n        const tPoints = [a, b, c, d].filter((item) => item);\r\n        if (tPoints.length === 4) {\r\n            this.createTriangles([a, b, c]);\r\n            this.createTriangles([c, d, a]);\r\n        }\r\n        if (tPoints.length === 3) {\r\n            this.createTriangles(tPoints);\r\n        }\r\n    }\r\n\r\n    createTriangles(points) {\r\n        const [a, b, c] = points;\r\n        this.vertices.push(...a.real, ...b.real, ...c.real);\r\n        const [x, y, z] = this.planeNormal;\r\n        this.normals.push(-x, -y, -z, -x, -y, -z, -x, -y, -z);\r\n    }\r\n\r\n    renderGeometry(points, config) {\r\n        const { shape2 } = config;\r\n        const [aLen, bLen] = shape2;\r\n        /**\r\n         * a\r\n         * ^\r\n         * |  6____7____8\r\n         * |  |    |    |\r\n         * |  3____4____5\r\n         * |  |    |    |\r\n         * |  |____|____|\r\n         * |  0    1    2\r\n         *  ----------------> b\r\n         */\r\n        // 每次都画1234矩形 因此aLen-1会在aLen-2时被访问到\r\n        for (let a = 0; a < aLen - 1; a += 1) {\r\n            //\r\n            for (let b = 0; b < bLen - 1; b += 1) {\r\n                const index = a * bLen + b; // 当前的二维坐标转换成一维\r\n                if (points[index] === null) continue;\r\n                const fourPoints = [\r\n                    points[index], // 点1\r\n                    points[index + bLen], // 点2\r\n                    points[index + bLen + 1], // 点3\r\n                    points[index + 1] // 点4\r\n                ];\r\n                this.createSquare(fourPoints);\r\n            }\r\n        }\r\n        this.setAttribute('position', new THREE.Float32BufferAttribute(this.vertices, 3));\r\n        this.setAttribute('normal', new THREE.Float32BufferAttribute(this.normals, 3));\r\n    }\r\n}\r\n\r\nclass CrystalIsosurface {\r\n    constructor(crystal) {\r\n        /**\r\n         * @type {Crystal}\r\n         */\r\n        this.crystal = crystal;\r\n        /**\r\n         * @type {THREE.Group}\r\n         */\r\n        this.group = new THREE.Group();\r\n        this.group.name = 'isosurfaces';\r\n        this.isosurfaces = new Map();\r\n        this.order_count = 1000;\r\n        this.order_map = {};\r\n        this.init();\r\n    }\r\n\r\n    async init() {\r\n        const latticeData = this.crystal.visualize_data.lattice;\r\n        this.lattice = this.crystal.getLatticeObject(latticeData);\r\n        this.statistics = this.getDataStatistics();\r\n        this.crystal.addToStructure(this.object, 'isosurface');\r\n        this.worker = await new IsosurfaceWorker().start();\r\n        this.getSmoothData();\r\n    }\r\n\r\n    get data() {\r\n        if (!this._data) this._data = this.crystal.charge_densities;\r\n        return this._data;\r\n    }\r\n\r\n    async getSmoothData() {\r\n        if (!this._smooth_data) {\r\n            this._smooth_data = await this.worker.generateSmoothData(this.data, 2);\r\n        }\r\n        return this._smooth_data;\r\n    }\r\n\r\n    get object() {\r\n        return this.group;\r\n    }\r\n    getDataStatistics() {\r\n        if (!this.data) return;\r\n        const [a, b, c] = math.size(this.data);\r\n        let min = Infinity,\r\n            max = -Infinity;\r\n        for (let i = 0; i < a; i++) {\r\n            for (let j = 0; j < b; j++) {\r\n                for (let k = 0; k < c; k++) {\r\n                    if (min > this.data[i][j][k]) {\r\n                        min = this.data[i][j][k];\r\n                    }\r\n                    if (max < this.data[i][j][k]) {\r\n                        max = this.data[i][j][k];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const volume = this.lattice.volume;\r\n        max = max / ab3 / volume;\r\n        min = min / ab3 / volume;\r\n        return {\r\n            min: parseFloat(min.toFixed(8)),\r\n            max: parseFloat(max.toFixed(8)),\r\n            center: parseFloat((min * 0.5).toFixed(8))\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 获取6个边界面上的点\r\n     * @param {*} data\r\n     * @param {*} shape\r\n     * @returns points[d][l]  d代表维度(0-2) l代表距离原点的距离(0-1)\r\n     */\r\n    getEdgePlanePoints(data, shape) {\r\n        const [xm, ym, zm] = shape;\r\n        const points = [[], [], []];\r\n        [0, xm - 1].forEach((x) => {\r\n            const planePointsX = [];\r\n            for (let y = 0; y < ym; y += 1)\r\n                for (let z = 0; z < zm; z += 1) {\r\n                    planePointsX.push({\r\n                        coord: [x, y, z],\r\n                        level: data[x][y][z]\r\n                    });\r\n                }\r\n            points[0].push(planePointsX);\r\n        });\r\n        [0, ym - 1].forEach((y) => {\r\n            const planePointsY = [];\r\n            for (let x = 0; x < xm; x += 1)\r\n                for (let z = 0; z < zm; z += 1) {\r\n                    planePointsY.push({\r\n                        coord: [x, y, z],\r\n                        level: data[x][y][z]\r\n                    });\r\n                }\r\n            points[1].push(planePointsY);\r\n        });\r\n        [0, zm - 1].forEach((z) => {\r\n            const planePointsZ = [];\r\n            for (let x = 0; x < xm; x += 1)\r\n                for (let y = 0; y < ym; y += 1) {\r\n                    planePointsZ.push({\r\n                        coord: [x, y, z],\r\n                        level: data[x][y][z]\r\n                    });\r\n                }\r\n            points[2].push(planePointsZ);\r\n        });\r\n        return points;\r\n    }\r\n\r\n    getPlanes(shape) {\r\n        let planes = [\r\n            { normal: [0, 0, 1], distance: 0 },\r\n            { normal: [0, 0, -1], distance: shape[2] - 1 },\r\n            { normal: [0, 1, 0], distance: 0 },\r\n            { normal: [0, -1, 0], distance: shape[1] - 1 },\r\n            { normal: [1, 0, 0], distance: 0 },\r\n            { normal: [-1, 0, 0], distance: shape[0] - 1 }\r\n        ];\r\n        planes = planes.map((item) => {\r\n            const vector3 = new THREE.Vector3().fromArray(item.normal);\r\n            return new THREE.Plane(vector3, item.distance);\r\n        });\r\n        return planes;\r\n    }\r\n\r\n    sliceSurface(surface, shape) {\r\n        console.time('sliceSurface');\r\n        this.getPlanes(shape).forEach((plane) => {\r\n            const newCells = [];\r\n            surface.cells.forEach((cell) => {\r\n                const outer = [];\r\n                const inner = [];\r\n                cell.forEach((item) => {\r\n                    const vector = new THREE.Vector3().fromArray(surface.positions[item]);\r\n                    vector.index = item;\r\n                    if (plane.distanceToPoint(vector) > 0) {\r\n                        inner.push(vector);\r\n                    } else {\r\n                        outer.push(vector);\r\n                    }\r\n                });\r\n                if (outer.length === 3) return;\r\n                if (outer.length === 0) newCells.push(cell);\r\n                if (outer.length === 1) {\r\n                    /**\r\n                     *         a\r\n                     *       /   \\\r\n                     *      /     \\\r\n                     * ----d-------f----平面\r\n                     *   /           \\\r\n                     *  b_____________c\r\n                     *\r\n                     * 平面的法向量方向向下 平面下面视为'里面'\r\n                     */\r\n                    const [a] = outer;\r\n                    const [b, c] = inner;\r\n                    const lab = new THREE.Line3(a, b);\r\n                    const lac = new THREE.Line3(a, c);\r\n                    const d = new THREE.Vector3();\r\n                    if (plane.intersectLine(lab, d) === null) return;\r\n                    const f = new THREE.Vector3();\r\n                    if (plane.intersectLine(lac, f) === null) return;\r\n                    const iD = surface.positions.push(d.toArray()) - 1;\r\n                    const iF = surface.positions.push(f.toArray()) - 1;\r\n                    newCells.push([b.index, iD, c.index], [iD, iF, c.index]);\r\n                }\r\n                if (outer.length === 2) {\r\n                    /**\r\n                     *  b_____________c\r\n                     *   \\           /\r\n                     *    \\         /\r\n                     * ----d-------f----平面\r\n                     *       \\   /\r\n                     *         a\r\n                     *\r\n                     *平面的法向量方向向下 平面下面视为'里面'\r\n                     */\r\n                    const [a] = inner;\r\n                    const [b, c] = outer;\r\n                    const lab = new THREE.Line3(a, b);\r\n                    const lac = new THREE.Line3(a, c);\r\n                    const d = new THREE.Vector3();\r\n                    if (plane.intersectLine(lab, d) === null) return;\r\n                    const f = new THREE.Vector3();\r\n                    if (plane.intersectLine(lac, f) === null) return;\r\n                    const iD = surface.positions.push(d.toArray()) - 1;\r\n                    const iF = surface.positions.push(f.toArray()) - 1;\r\n                    newCells.push([a.index, iD, iF]);\r\n                }\r\n            });\r\n            surface = { positions: surface.positions, cells: newCells };\r\n        });\r\n        console.timeEnd('sliceSurface');\r\n        return surface;\r\n    }\r\n\r\n    /**\r\n     * 生成截面\r\n     * @param {*} edgeOriginPoints\r\n     * @param {*} edgeSurfacePoints\r\n     * @param {*} level\r\n     * @param {*} config\r\n     * @param {*} shape\r\n     * @returns\r\n     */\r\n    generateCrossProfile(edgeOriginPoints, edgeSurfacePoints, level, config, shape, order) {\r\n        console.time('生成截面');\r\n        const dim = [0, 1, 2]; // 维度\r\n        const length = [0, 1]; // 距离原点长度\r\n        const group = new THREE.Group();\r\n        dim.forEach((d) => {\r\n            const [i1, i2] = [0, 1, 2].filter((item) => item !== d);\r\n            length.forEach((l) => {\r\n                // 从原始数据的边界点集中拿到电荷密度内部的规则点集\r\n                let innerPoints = edgeOriginPoints[d][l].map((item) => {\r\n                    let pick = false;\r\n                    if (level < 0 && item.level < 0) pick = item.level < level;\r\n                    if (level > 0 && item.level > 0) pick = item.level > level;\r\n                    if (!pick) return null;\r\n                    return {\r\n                        offset: item.coord, // 三个索引指示的位置\r\n                        real: this.gridToXyz(item.coord, shape)\r\n                    };\r\n                });\r\n                /**\r\n                 *  _____ _____ _____\r\n                 * |   p |     |  p  |\r\n                 * |p    |     |     |\r\n                 * x—————x——p——x—————p\r\n                 * |  p  |     |     |\r\n                 * |    p|     |     |\r\n                 * x—————z—————z—————p\r\n                 * | p p |     |   p |\r\n                 * |     | p   |     |\r\n                 * x—————x—————x—————\r\n                 * z是edgeOriginPoints中的点 分布在中心且坐标为为整数\r\n                 * p是edgeSurfacePoints中的点 分布在外围 坐标不为整数\r\n                 * 将p点映射到其所属网格的左下角整数坐标x上 依此构造三角面\r\n                 * 最后再将该点坐标给还原成p点实际坐标\r\n                 */\r\n                // 将点映射到左下角最接近的网格中 每个网格单位为1\r\n                edgeSurfacePoints[d][l].forEach((coord) => {\r\n                    const offset = coord.map((item, index) => {\r\n                        let newItem = Math.ceil(item);\r\n                        // 处理负数\r\n                        if (newItem < 0) newItem += shape[index];\r\n                        return newItem;\r\n                    });\r\n                    const index = offset[i2] + offset[i1] * shape[i2];\r\n                    innerPoints[index] = {\r\n                        offset,\r\n                        real: this.gridToXyz(coord, shape)\r\n                    };\r\n                });\r\n                const mesh = this.createPointsShape(innerPoints, {\r\n                    ...config,\r\n                    shape,\r\n                    dim: d,\r\n                    length: l\r\n                });\r\n                // mesh.renderOrder = order;\r\n                group.add(mesh);\r\n            });\r\n        });\r\n        console.timeEnd('生成截面');\r\n        return group;\r\n    }\r\n\r\n    /**\r\n     * 获取表面在边界上的点\r\n     * @param {*} surface\r\n     * @param {*} shape\r\n     * @returns\r\n     */\r\n    getSurfaceEdgePoints(surface, shape) {\r\n        const { positions, cells } = surface;\r\n        const edgePoints = [\r\n            [[], []],\r\n            [[], []],\r\n            [[], []]\r\n        ];\r\n        const visitedPosition = new Map();\r\n        cells.forEach((cell) => {\r\n            cell.forEach((index) => {\r\n                // 这个点已经被访问过了\r\n                if (visitedPosition.has(index)) return;\r\n                const position = positions[index];\r\n                position.forEach((value, index) => {\r\n                    if (value === 0) {\r\n                        // 将该点标记为已经被访问过\r\n                        visitedPosition.set(index, null);\r\n                        edgePoints[index][0].push(position);\r\n                    }\r\n                    if (value === shape[index] - 1) {\r\n                        // 将该点标记为已经被访问过\r\n                        visitedPosition.set(index, null);\r\n                        edgePoints[index][1].push(position);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return edgePoints;\r\n    }\r\n\r\n    async createSurface(config, order) {\r\n        console.time('compute isosurface');\r\n        const meshes = [];\r\n        let { level, color, opacity, visible, mode } = config;\r\n        level = level * this.lattice.volume * ab3;\r\n        const levels = [level, -1 * level].filter((item) => {\r\n            if (mode === 'Positive' && item < 0) return false;\r\n            if (mode === 'Negative' && item > 0) return false;\r\n            return true;\r\n        });\r\n        let data = await this.getSmoothData();\r\n        const shape = math.size(data);\r\n        const edgeOriginPoints = this.getEdgePlanePoints(data, shape);\r\n        const [xm, ym, zm] = shape;\r\n        levels.forEach((level, index) => {\r\n            console.time('isosurface');\r\n            console.log(`calculation isosurface ${level}`);\r\n            let surface = isosurface.surfaceNets(\r\n                shape.map((item) => item + 2),\r\n                (x, y, z) => data[(x - 1 + xm) % xm][(y - 1 + ym) % ym][(z - 1 + zm) % zm] - level\r\n            );\r\n            if (!surface.positions.length) return;\r\n            console.timeEnd('isosurface');\r\n            // 减去1因为前面向三个轴正方形各增加了2\r\n\r\n            surface.positions = surface.positions.map((position) => math.subtract(position, 1));\r\n            surface = this.sliceSurface(surface, shape);\r\n            const edgeSurfacePoints = this.getSurfaceEdgePoints(surface, shape);\r\n            const group = this.generateCrossProfile(\r\n                edgeOriginPoints,\r\n                edgeSurfacePoints,\r\n                level,\r\n                config,\r\n                shape,\r\n                order\r\n            );\r\n            let { positions, cells } = surface;\r\n            meshes.push(group);\r\n            positions = positions.map((position) => this.gridToXyz(position, shape));\r\n            let geometry = new ConcaveGeometry();\r\n            geometry.renderGeometry(positions, cells);\r\n            console.time('smooth modify');\r\n            // geometry = LoopSubdivision.modify(geometry, 1);\r\n            console.timeEnd('smooth modify');\r\n            const material = new THREE.MeshLambertMaterial({\r\n                reflectivity: 0.7,\r\n                color: color[index],\r\n                side: THREE.DoubleSide,\r\n                transparent: true,\r\n                opacity: 1 - opacity\r\n                // depthTest: true,\r\n                // depthWrite: false\r\n            });\r\n            const mesh = new THREE.Mesh(geometry, material);\r\n            // mesh.renderOrder = order;\r\n            mesh.visible = visible;\r\n            group.add(mesh);\r\n        });\r\n        console.timeEnd('compute isosurface');\r\n        return meshes;\r\n    }\r\n\r\n    gridToXyz(position, shape) {\r\n        const _position = position.map((item, index) => item / (shape[index] - 1));\r\n        return math.multiply(_position, this.lattice.matrix);\r\n    }\r\n\r\n    createPointsShape(points, config) {\r\n        let { length, dim, shape, opacity } = config;\r\n        const shape2 = shape.filter((_, index) => index !== dim); // 二维shape\r\n        const geometry = new PointsPlaneShapeGeometry(\r\n            points,\r\n            { shape2, length, dim },\r\n            this.lattice.matrix\r\n        );\r\n        const material = new THREE.MeshLambertMaterial({\r\n            color: 'yellow',\r\n            side: THREE.DoubleSide,\r\n            transparent: true,\r\n            opacity: 1 - opacity\r\n            // depthTest: true,\r\n            // depthWrite: false\r\n        });\r\n        return new THREE.Mesh(geometry, material);\r\n    }\r\n\r\n    createPoints(vertices, index, size = 2) {\r\n        const colorMap = [\r\n            '#313695',\r\n            '#4575b4',\r\n            '#74add1',\r\n            '#abd9e9',\r\n            '#e0f3f8',\r\n            '#ffffbf',\r\n            '#fee090',\r\n            '#fdae61',\r\n            '#f46d43',\r\n            '#d73027',\r\n            '#a50026'\r\n        ].reverse();\r\n        const color = colorMap[index % (colorMap.length - 1)];\r\n        vertices = vertices.map(([x, y, z]) => {\r\n            return math.multiply([x, y, z], this.lattice.matrix);\r\n        });\r\n        vertices = vertices.flat();\r\n        const geometry = new THREE.BufferGeometry();\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n        const material = new THREE.PointsMaterial({ color, size });\r\n        const mesh = new THREE.Points(geometry, material);\r\n        this.group.add(mesh);\r\n    }\r\n\r\n    createLines(vertices, color = 'black') {\r\n        const points = vertices.map(([x, y, z]) => {\r\n            const array = math.multiply([x, y, z], this.lattice.matrix);\r\n            return new THREE.Vector3().fromArray(array);\r\n        });\r\n        const geometry = new THREE.BufferGeometry().setFromPoints(points);\r\n        const material = new THREE.LineBasicMaterial({ color, size: 10 });\r\n        const mesh = new THREE.Line(geometry, material);\r\n        this.group.add(mesh);\r\n    }\r\n\r\n    clear() {\r\n        this.group.clear();\r\n        this.isosurfaces.clear();\r\n    }\r\n\r\n    async create(_config, order) {\r\n        console.log('order = ', order);\r\n        const meshes = await this.createSurface(_config, order);\r\n        this.isosurfaces.set(_config.id, {\r\n            id: _config.id,\r\n            config: _config,\r\n            meshes\r\n        });\r\n        meshes.forEach((mesh) => {\r\n            if (mesh) this.group.add(mesh);\r\n        });\r\n        return meshes;\r\n    }\r\n\r\n    delete(id) {\r\n        const surface = this.isosurfaces.get(id);\r\n        this.group.remove(...surface.meshes.filter((mesh) => mesh));\r\n        this.isosurfaces.delete(id);\r\n    }\r\n\r\n    async update(id, prop, value, surface) {\r\n        surface.config[prop] = value;\r\n        switch (prop) {\r\n            case 'opacity':\r\n                surface.meshes.forEach((obj) => {\r\n                    const meshes = [];\r\n                    if (obj instanceof THREE.Group) {\r\n                        meshes.push(...obj.children);\r\n                    } else meshes.push(obj);\r\n                    meshes.forEach((mesh) => {\r\n                        mesh.material.opacity = 1 - value;\r\n                    });\r\n                });\r\n                break;\r\n            case 'color':\r\n                surface.meshes.forEach((obj, index) => {\r\n                    obj.children.forEach((mesh) => {\r\n                        mesh.material.color = new THREE.Color(value[index]);\r\n                    });\r\n                });\r\n                break;\r\n            case 'visible':\r\n                surface.meshes.forEach((group) => {\r\n                    group.visible = value;\r\n                    group.children.forEach((_group) => {\r\n                        _group.visible = value;\r\n                    });\r\n                });\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    getAllIsoSurfaces() {\r\n        const list = [];\r\n        this.isosurfaces.forEach((item) => {\r\n            list.push(item.config);\r\n        });\r\n        return list;\r\n    }\r\n\r\n    async setIsosurfaces(data) {\r\n        if (data.operate === 'create') {\r\n            const config = data.value;\r\n            this.order_map[config.id] = this.order_count;\r\n            await this.create(config, this.order_count);\r\n            this.order_count--;\r\n        } else if (data.operate === 'update') {\r\n            const { id, params } = data;\r\n            const surface = this.isosurfaces.get(id);\r\n            if (['level', 'mode'].includes(params[0].prop)) {\r\n                const config = surface.config;\r\n                params.forEach(({ prop, value }) => {\r\n                    config[prop] = value;\r\n                });\r\n                this.delete(id);\r\n                const meshes = await this.create(config, this.order_map[id]);\r\n                meshes.forEach((mesh) => {\r\n                    if (mesh) mesh.visible = config.visible;\r\n                });\r\n            } else {\r\n                const { prop, value } = params[0];\r\n                await this.update(id, prop, value, surface);\r\n            }\r\n        } else if (data.operate === 'delete') {\r\n            data.value.forEach((item) => this.delete(item));\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    CrystalIsosurface\r\n};\r\n\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 法线贴图\r\n```js\r\nclass AnnulusShaderMaterial extends THREE.ShaderMaterial {\r\n    static annulus_texture;\r\n    constructor() {\r\n        super({\r\n            vertexShader: vertex_shader,\r\n            fragmentShader: normal_map_fragment_shader,\r\n            vertexColors: true,\r\n            uniforms: { customTexture: { value: null } }\r\n        });\r\n        this.setTexture();\r\n    }\r\n\r\n    setTexture() {\r\n        if (isUndefined(AnnulusShaderMaterial.annulus_texture)) {\r\n            const circle_texture_path = path.resolve(__dirname, './resource/annulus.png');\r\n            AnnulusShaderMaterial.annulus_texture = new THREE.TextureLoader().load(circle_texture_path);\r\n        }\r\n        this.uniforms.customTexture.value = AnnulusShaderMaterial.annulus_texture;\r\n    }\r\n}\r\n\r\n```\r\n\r\n```glsl\r\n    // vertex_shader\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n        vColor = vec4(color, 1.0);\r\n        // 模型空间到世界空间的转换: 使用modelMatrix将顶点从模型空间转换到世界空间。这里的\r\n        // position是顶点在模型空间中的位置。\r\n        vPosition = (modelMatrix * vec4(position, 1.0)).xyz;\r\n        // 法线变换: 使用normalMatrix来变换顶点的法线向量。将法线向量从模型空间转换到世界空间。\r\n        vNormal = normalize(normalMatrix * normal);\r\n        // 模型-视图-投影变换\r\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\r\n    }\r\n```\r\n\r\n\r\n```glsl\r\n    // normal_map_fragment_shader\r\n    uniform sampler2D customTexture;\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec4 vColor;  // 接收自顶点着色器的颜色\r\n\r\n    void main() {\r\n        vec3 toCamera = normalize(cameraPosition - vPosition);\r\n        \r\n        // 计算面向摄像机方向的“右”和“上”向量\r\n        vec3 up = vec3(0.0, 1.0, 0.0); // 世界坐标系中的上方向\r\n        vec3 right = normalize(cross(toCamera, up));\r\n\r\n        // 法线贴图，将球体的法线用于纹理贴图\r\n        vec2 uv = vec2(dot(right, vNormal), dot(up, vNormal));\r\n        uv = uv * 0.5 + 0.5; // 转换uv到[0,1]范围\r\n\r\n        // 将纹理放大0.1倍 使得外边缘完全覆盖住球的颜色\r\n        float scale = 1.1; // 这个值表示放大纹理的程度\r\n        uv = uv * 2.0 - 1.0; // 转换uv到[-1,1]范围\r\n        uv = uv / scale; // 缩放\r\n        uv = uv * 0.5 + 0.5; // 转换uv回到[0,1]范围\r\n\r\n\r\n        vec4 texColor = texture2D(customTexture, uv);\r\n        // 这里假设纹理的alpha通道代表了十字架的形状\r\n        // 当alpha为1时，使用贴图颜色；当alpha为0时，使用顶点颜色\r\n        gl_FragColor = mix(vColor, texColor, texColor.a);\r\n    }\r\n```"
            ],
            "outputs": []
        }
    ]
}