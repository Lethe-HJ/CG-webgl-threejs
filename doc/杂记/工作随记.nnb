{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "## 更新类型数组\r\n\r\n```js\r\nconst vertices = new Float32Array(VERTICES_LENGTH_ALL);\r\nthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n\r\nthis.attributes.position.array = new_vertices; // 直接覆盖或者修改成员\r\n// this.attributes.position.array[0] = 0;\r\nthis.attributes.position.needsUpdate = true;\r\n```\r\n\r\n这里的`new Float32BufferAttribute` 会对vertices做深拷贝后续修改vertices无效 应该直接对`this.attributes.position.array`做修改\r\n然后再标记更新\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## THREE的类型数组\r\n\r\n+ THREE.Float64BufferAttribute \r\n+ THREE.Float32BufferAttribute\r\n+ THREE.Float16BufferAttribute \r\n+ THREE.Uint32BufferAttribute\r\n+ THREE.Int32BufferAttribute \r\n+ THREE.Uint16BufferAttribute\r\n+ THREE.Int16BufferAttribute \r\n+ THREE.Uint8ClampedBufferAttribute\r\n+ THREE.Uint8BufferAttribute \r\n+ THREE.Int8BufferAttribute\r\n\r\n其中`THREE.Uint8BufferAttribute` 和 `THREE.Uint8ClampedBufferAttribute` 都是 Three.js 中用于表示无符号 8 位整数的缓冲属性，但它们之间有一个关键的区别：\r\n\r\n1. **值的处理方式**：\r\n    - `THREE.Uint8BufferAttribute`：这种属性存储的值是普通的无符号 8 位整数，范围在 0 到 255 之间。当你将值存储在 `Uint8BufferAttribute` 中时，它们可以超出这个范围，因此可以存储负数或大于 255 的数值。这在某些情况下可能会导致不期望的结果，尤其是在图像处理等需要精确范围的任务中。\r\n    - `THREE.Uint8ClampedBufferAttribute`：相比之下，这种属性存储的值是被\"夹紧\"（clamped）到 0 到 255 范围内。这意味着如果你尝试存储小于 0 的值，它会被设置为 0；如果尝试存储大于 255 的值，它会被设置为 255。这确保了存储的值始终在合法范围内。\r\n\r\n2. **应用场景**：\r\n    - `THREE.Uint8BufferAttribute`：通常用于不需要值被限制在 0 到 255 范围内的情况。例如，它可以用于存储灰度图像的像素数据，其中像素值在 0 到 255 之间。\r\n    - `THREE.Uint8ClampedBufferAttribute`：通常用于需要确保值始终在 0 到 255 范围内的情况，特别是在颜色表示和图像处理中，以避免产生不合理的颜色或效果。\r\n\r\n总之，区别在于数据的范围和处理方式。如果你需要确保值在 0 到 255 范围内，不会溢出或产生异常，那么 `THREE.Uint8ClampedBufferAttribute` 是更安全的选择。如果你不需要这种夹紧行为，可以使用 `THREE.Uint8BufferAttribute`。选择哪个取决于你的具体应用场景和需求。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "HTTPS (超文本传输安全协议) 是基于 SSL/TLS 的 HTTP 协议。SSL/TLS 是一种提供数据传输加密、服务器认证、消息完整性和可选的客户端认证的协议。要理解 HTTPS 的工作原理和安全性，首先需要了解 SSL/TLS 的一些基本概念和步骤：\r\n\r\n1. **公钥和私钥**：\r\n   - 公钥加密，只有对应的私钥可以解密。\r\n   - 私钥加密，只有对应的公钥可以解密。\r\n\r\n2. **握手过程**：\r\n   - 客户端发起连接请求。\r\n   - 服务器回应并提供其数字证书。这个证书包含服务器的公钥和由受信任的证书颁发机构 (CA) 签名。\r\n   - 客户端验证服务器的证书（通过比较它与系统中存储的受信任 CA 列表）。\r\n   - 客户端使用服务器的公钥加密一个随机生成的“预主密钥”并将其发送给服务器。\r\n   - 服务器使用其私钥解密并获取这个“预主密钥”。\r\n   - 服务器和客户端都使用这个“预主密钥”来生成会话密钥，用于加密和解密信息。\r\n\r\n3. **数据传输过程**：服务器和客户端使用从“预主密钥”派生出的会话密钥加密和解密数据。\r\n\r\n4. **安全性**：\r\n   - **认证**：由于证书由受信任的 CA 签名，因此客户端可以验证服务器的身份。这可以防止中间人攻击。\r\n   - **加密**：数据被加密，即使被拦截，也无法被解读。\r\n   - **完整性**：SSL/TLS 使用消息摘要来确保数据在传输过程中没有被篡改。\r\n\r\n5. **为什么这是安全的**：\r\n   - 私钥从不在网络上传输。\r\n   - 即使攻击者截获了由公钥加密的“预主密钥”，他们也无法解密它，除非他们有对应的私钥。\r\n   - 即使攻击者有服务器的数字证书和公钥，他们也无法伪造服务器的身份，因为他们没有对应的私钥来解密客户端发送的“预主密钥”。\r\n\r\n然而，HTTPS 和 SSL/TLS 不是完全不可攻破的。例如，它们可能受到特定的加密算法弱点、证书颁发机构的安全问题或服务器配置错误的影响。但总体上，当正确实施和配置时，HTTPS 提供了一个高度安全的数据传输机制。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "在Three.js中，每个`Geometry`或`BufferGeometry`对象都可以有一个边界球（Bounding Sphere），这是一个简单的球体，用于包含该几何体的所有顶点。边界球在各种图形计算中很有用，例如碰撞检测、视锥裁剪或其他优化技术。\r\n\r\n`geometry.computeBoundingSphere()`方法是为了计算这个边界球。当你调用此方法时，它将遍历几何体的所有顶点，并找出一个中心点和半径，使得这个球体可以包含几何体的所有点。\r\n\r\n以下是这个方法的一些关键点：\r\n\r\n1. **中心** (`geometry.boundingSphere.center`)：这是一个`Vector3`对象，表示边界球的中心。\r\n\r\n2. **半径** (`geometry.boundingSphere.radius`)：这是一个数字，表示从边界球中心到其表面的距离。\r\n\r\n3. **何时调用**：这个方法不是自动调用的。也就是说，如果你修改了几何体的顶点并想更新边界球，你需要手动调用`computeBoundingSphere()`。但请注意，不必频繁地在每一帧调用它，因为这可能会影响性能。只在确实需要时（例如在几何体变化后）调用它。\r\n\r\n4. **用途**：边界球常用于“粗糙”的碰撞检测或距离估计。因为球体测试通常比精确的多边形测试要快得多。例如，如果两个物体的边界球都没有相交，那么这两个物体肯定没有碰撞。但如果它们的边界球相交，你可能需要进一步的测试来确定它们是否真的碰撞。\r\n\r\n总的来说，`geometry.computeBoundingSphere()`是一个在Three.js中计算和更新几何体边界球的有用方法。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## PointerEvent\r\nPointerEvent 中有两个与按钮相关的属性：button 和 buttons。\r\n\r\nbutton\r\n\r\nbutton 属性用于标识哪个按钮被按下或释放。它返回一个整数，表示按下或释放的按钮。对于鼠标事件，这些整数的意义如下：\r\n\r\n0: 主按钮（通常是左键）\r\n1: 中键（鼠标中间的滚轮按钮）\r\n2: 次按钮（通常是右键）\r\n3: 第四个按钮（通常在游戏鼠标上可见）\r\n4: 第五个按钮（同样通常在某些特殊鼠标上可见）\r\nbuttons\r\n\r\n与 button 不同，buttons 属性用于描述在事件发生时哪些按钮是被按下的状态。这是一个按位字段，不同的按钮对应的值如下：\r\n\r\n1: 主按钮（通常是左键）\r\n2: 次按钮（通常是右键）\r\n4: 中键（鼠标中间的滚轮按钮）\r\n8: 第四个按钮\r\n16: 第五个按钮\r\n因此，如果主按钮和中键都被按下，buttons 的值会是 1 + 4 = 5。\r\n\r\n这些属性特别有用，尤其当你想根据用户与设备的交互来执行不同的操作时，例如区分左键点击、右键点击或多个按钮同时被按下的情况。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 显卡\r\n\r\n集成显卡（Integrated Graphics）、核显（一个通常用于指代某些集成显卡的术语，尤其是Intel的）和独立显卡（Dedicated Graphics）是三种主要的显卡类型。以下是它们的区别和各自的优势：\r\n\r\n**集成显卡** (Integrated Graphics):\r\n\r\n定义：集成显卡是内嵌在主板或CPU中的显卡。它使用系统的RAM作为其显存。\r\n优势：\r\n成本：通常比独立显卡便宜。\r\n功耗与热量：通常比独立显卡低。\r\n空间：不需要额外的空间或插槽，因为它是集成的。\r\n足够的日常任务：对于日常办公、网页浏览和视频播放等基本任务，集成显卡已经足够。\r\n\r\n**核显** (e.g., Intel HD Graphics):\r\n\r\n定义：核显是集成显卡的一种，通常集成在CPU芯片中。尤其是在某些Intel处理器中，这种显卡被称为“核显”。\r\n优势：\r\n性能与效率：尽管核显是集成的，但在过去的几年中，它的性能已经得到了很大的提升，尤其是对于中等图形任务。\r\n快速同步内存访问：由于它与CPU集成在同一芯片上，核显可以快速地访问主存储器。\r\n\r\n核显由于集成在CPU芯片上，可以利用CPU的多级缓存，特别是L3缓存，这对于某些图形任务来说可以提供更高的性能。\r\n\r\n这种缓存共享可以为图形处理提供以下优势：\r\n\r\n数据访问速度：CPU和GPU可以更快速地共享数据，因为它们可以利用相同的缓存结构，而不是通过系统内存。\r\n低延迟：在CPU和GPU之间共享数据的延迟会减少，因为数据不需要来回传输到主内存。\r\n能效：使用缓存来共享数据通常比使用主内存更为节能。\r\n然而，对于高端图形处理任务，专用GPU（独立显卡）仍然具有明显的优势，因为它们具有专用的显存（例如GDDR6），这种显存的带宽和速度远超过常规的系统RAM和CPU的缓存。但对于集成解决方案，能够利用CPU的多级缓存是一个很大的优势，尤其是在处理轻到中等图形任务时。\r\n\r\n**独立显卡** (Dedicated Graphics):\r\n\r\n定义：独立显卡是一个单独的硬件组件，拥有自己的显存，通常插在主板上的PCIe插槽上。\r\n优势：\r\n性能：独立显卡通常提供比集成显卡更高的性能，特别是高端模型。\r\n专用显存：拥有自己的显存，不会与系统的RAM共享，这对于图形密集型任务特别有利。\r\n多重显示支持：独立显卡通常支持多个显示器。\r\n专业与游戏应用：对于专业的图形设计、3D建模、高清视频编辑和高级游戏，独立显卡是必需的。\r\n\r\n*是不是可以这样理解 独立显卡无法利用cpu的高速缓存 但核显可以 所以在处理轻到中等图形任务时核显反而可能性能更强 ?*\r\n    由于核显直接集成在CPU芯片上，它可以更直接地访问CPU的多级缓存（尤其是L3缓存），这在某些场景中可以为它提供优势。然而，即使有这个优势，核显的绝对性能仍然通常低于中高端的独立显卡。\r\n    对于轻到中等图形任务，核显可能提供了足够的性能，并且在某些特定情况下，由于能够更快地访问CPU缓存，可能会略微超过某些入门级的独立显卡。但这不意味着核显在这些场景中总是优于独立显卡。\r\n    以下是一些要考虑的点：\r\n        显存的重要性：高端独立显卡使用专用的高速显存（如GDDR6），它的带宽远远超过常规DDR4或DDR5系统RAM。这种专用显存对于高分辨率、高纹理质量的图形任务至关重要。\r\n        并行处理能力：独立显卡通常拥有更多的处理单元和更高的并行处理能力，这对于图形计算来说是非常重要的。\r\n        特定优化：许多图形软件和游戏都针对独立显卡进行了优化，因此在实际使用中，即使核显在理论上有某些优势，实际性能仍然可能落后。\r\n        所以，总的来说，虽然核显可以利用CPU的高速缓存并在某些场景中提供良好的性能，但独立显卡在大多数图形密集型任务中仍然占据优势。不过，对于轻到中等的日常任务，现代核显绝对是一个非常可靠和有效的选择。\r\n\r\n\r\n*所以另外一个我比较好奇的问题是 是cpu的多级缓存速度快 还是独立显卡的显存快*\r\n    比较CPU的多级缓存与独立显卡的显存的速度是一个有趣的问题。这两者的设计和用途有很大的区别，但为了简化比较，我们可以考虑以下几点：\r\n    访问速度：\r\n        CPU缓存：CPU的L1、L2和L3缓存被设计为高速、低延迟存储，尤其是L1和L2。它们的目标是最小化从主内存访问数据的延迟。\r\n        显卡显存：显存（如GDDR6）被设计为提供非常高的带宽，尤其是为了图形任务，这些任务通常需要大量数据并行处理。虽然显存也很快，但其主要的优势是高带宽而不是低延迟。\r\n    结论：\r\n        对于单次的小数据访问（例如，访问一个单独的数据项或指令），CPU的L1或L2缓存通常提供更低的延迟，因此“更快”。\r\n        对于大量数据的并行访问（例如，图形渲染或大规模计算），独立显卡的显存提供更高的带宽，因此在这种场景下更为高效。\r\n    用途：\r\n        由于CPU和GPU的工作负载通常有很大的区别，这两种存储类型被优化以适应它们的特定任务。CPU的多级缓存旨在快速访问经常使用的小数据片段或指令，而显存被设计为能够同时处理大量的图形数据。\r\n    总的来说，简单地问“哪个更快”可能不是一个完整的问题。更具体的问题是“在哪种工作负载下哪个更快”。但是，如果你只是好奇它们在单次访问上的速度差异，那么CPU的L1和L2缓存通常有更低的延迟。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "GPU（图形处理单元）最初是为了加速图形渲染而设计的，但随着时间的推移，它们已经发展成为高度并行的计算设备，可以执行大量的并行操作。以下是GPU能进行并行计算的原理：\r\n\r\n多处理器架构：现代GPU包含数百到数千个处理器核心。这些核心被组织成多个“流多处理器”或“计算单元”。每个流多处理器可以独立地执行指令和管理数据。\r\n\r\n数据并行性：GPU是为数据并行计算设计的，这意味着它们可以同时处理大量的数据元素。例如，在图形渲染中，每个像素或顶点都可以被并行处理。\r\n\r\n线程并行性：GPU支持大量的并行线程。这些线程被组织成线程块和线程网格，允许它们在执行时共享数据和同步。\r\n\r\n高带宽内存：为了支持高度并行的数据处理，GPU配备了高带宽的内存，这使得它们能够快速地读取和写入大量的数据。\r\n\r\nSIMD（单指令多数据流）：GPU的每个流多处理器都使用SIMD架构，这意味着在每个时钟周期内，一个指令可以被应用到多个数据元素上。\r\n\r\n灵活的执行模型：虽然GPU是为高度并行的任务设计的，但它们也支持条件执行和循环，这使得它们可以执行更复杂的计算任务。\r\n\r\n专用硬件加速：GPU还包括为特定任务（如纹理采样或深度测试）设计的专用硬件，这进一步提高了其性能。\r\n\r\n总之，GPU的并行计算能力来自其多核架构、数据和线程并行性、高带宽内存和专用硬件加速。这使得GPU非常适合执行需要大量并行处理的任务，如图形渲染、科学计算和深度学习。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## WebAssembly\r\n\r\nWebAssembly（简称Wasm）是一个为浏览器设计的低级二进制代码格式，旨在为高级语言（如C、C++和Rust）提供一个快速、效率高的目标。由于它几乎与原生代码运行速度相当，WebAssembly常常被用来加速那些对性能有高要求的Web应用。\r\n\r\n对于Web3D工程师来说，使用WebAssembly技术对图形相关的算法进行优化确实有较大的意义，特别是在以下几个场景中：\r\n\r\n1. **计算密集型任务**：一些3D图形应用，如实时光线追踪、流体模拟、粒子系统等，涉及大量计算。使用WebAssembly可以显著提高这些算法的运行速度。\r\n\r\n2. **已有的C/C++图形库**：许多成熟的3D图形库和工具都是用C或C++编写的。使用WebAssembly，可以将这些库直接编译到Web平台上，从而避免从头开始编写JavaScript实现。\r\n\r\n3. **并行计算**：虽然WebWorkers可以在Web上实现多线程，但与WebAssembly结合使用时，尤其是在进行并行计算时，可以更高效地利用多核心处理器。\r\n\r\n4. **内存控制**：与JavaScript相比，WebAssembly提供了更为精确的内存控制。这对于3D图形应用来说很重要，因为它们常常需要管理大量的资源，如纹理、模型和场景数据。\r\n\r\n5. **与其他Web技术结合**：你可以选择只将性能瓶颈部分的代码转移到WebAssembly，而保留其他部分的JavaScript代码。这种混合使用可以确保你既享受WebAssembly的性能优势，又能保留JavaScript的灵活性。\r\n\r\n总之，对于Web3D工程师来说，WebAssembly提供了一个强大的工具，用于提速图形相关的算法和任务。当你遇到性能瓶颈，或需要将已有的C/C++图形代码带到Web上时，WebAssembly都是一个值得考虑的选择。"
            ],
            "outputs": []
        }
    ]
}