# threejs中的射线拾取原理

---

### **1. 核心流程概述**
射线拾取的整个过程分为以下几个步骤：
1. **屏幕坐标转换**：将鼠标的2D屏幕坐标转换为3D空间中的一条射线（Ray）。
2. **射线与物体求交**：计算这条射线与场景中所有可交互物体的交点。
3. **筛选最近交点**：从所有交点中找出距离摄像机最近的物体，作为拾取结果。

---

### **2. 详细步骤解析**

#### **2.1 屏幕坐标 → 3D射线（Ray）**
Three.js需要将鼠标的2D像素坐标转换为3D世界空间中的一条射线，射线的起点是摄像机位置，方向指向鼠标点击的3D方向。

**关键代码**（摘自`Raycaster`类）：
```javascript
// 鼠标坐标归一化（NDC坐标系：[-1, 1]）
const mouseNDC = new THREE.Vector2(
    (mouseX / window.innerWidth) * 2 - 1,
    -(mouseY / window.innerHeight) * 2 + 1
);

// 通过摄像机和NDC坐标生成射线
raycaster.setFromCamera(mouseNDC, camera);
```

**数学原理**：
1. **归一化设备坐标（NDC）**：  
   将鼠标坐标从屏幕坐标系（`[0, width]` x `[0, height]`）转换为WebGL的NDC坐标系（`[-1, 1]` x `[-1, 1]`），Y轴需要反转（因为屏幕坐标原点在左上角，而WebGL在左下角）。

2. **生成射线**：  
   通过摄像机的投影矩阵（`projectionMatrix`）和视图矩阵（`modelViewMatrix`）的逆矩阵，将NDC坐标转换为世界空间中的射线方向：
   ```javascript
   // 伪代码：Three.js内部实现
   const origin = camera.position;
   const direction = mouseNDC
       .unproject(camera)               // 逆投影到相机近裁剪面
       .sub(camera.position)            // 计算方向向量
       .normalize();                    // 单位化
   ```

---

#### **2.2 射线与物体求交**
Three.js会遍历场景中的所有物体，检查射线是否与物体的几何体（`BufferGeometry`）相交。支持的几何体包括：`Mesh`、`Line`、`Points`等。

**求交算法**：
- **对于三角面片（Mesh）**：使用**Möller-Trumbore算法**（一种高效的射线-三角形相交算法）。  
- **对于球体/立方体**：使用包围盒（`Box3`）或包围球（`Sphere`）的快速近似检测。

**关键代码**：
```javascript
// Three.js内部对Mesh的射线相交检测
const intersection = ray.intersectTriangle(
    vertexA, vertexB, vertexC,      // 三角形的三个顶点
    false,                          // 是否背面剔除
    new THREE.Vector3()             // 存储交点的输出
);
```

**Möller-Trumbore算法简述**：  
通过解线性方程组计算射线与三角形的交点，利用向量叉乘和点乘优化计算：
1. 计算射线方向与三角形两条边的叉乘（确定共面性）。
2. 使用重心坐标（Barycentric Coordinates）判断交点是否在三角形内。

---

#### **2.3 筛选最近交点**
Three.js会收集所有相交的物体，并按**交点距离摄像机的深度（Z值）**排序，返回最近的物体。

**关键代码**：
```javascript
// 对所有相交结果按距离排序
intersections.sort((a, b) => a.distance - b.distance);
const closest = intersections[0];
```

---

### **3. 性能优化机制**
为了提高拾取效率，Three.js采用了以下优化策略：
1. **层级剔除（Hierarchy Culling）**：  
   使用`BVH`（Bounding Volume Hierarchy）或简单的`BoundinSphere`快速排除不可能相交的物体。
2. **按需检测**：  
   通过`raycaster.params`指定检测的物体类型（如仅检测`Mesh`）：
   ```javascript
   raycaster.params.Points = false; // 忽略点云物体
   ```
3. **GPU加速**：  
   某些高级库（如`GPU-Picker`）会使用着色器在GPU端完成拾取（通过颜色编码）。

---

### **4. 实际应用示例**
```javascript
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onClick(event) {
    // 1. 转换鼠标坐标到NDC
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // 2. 生成射线
    raycaster.setFromCamera(mouse, camera);

    // 3. 检测相交物体
    const intersects = raycaster.intersectObjects(scene.children, true);

    // 4. 处理最近交点
    if (intersects.length > 0) {
        console.log("Clicked object:", intersects[0].object);
    }
}

window.addEventListener('click', onClick);
```

---

### **5. 关键数据结构**
- **`Raycaster`类**：核心拾取工具，管理射线和求交逻辑。
- **`Ray`**：表示3D射线的起点和方向。
- **`Intersection`对象**：存储交点信息，包括：
  - `object`：被击中的物体。
  - `distance`：交点距离摄像机的距离。
  - `point`：交点坐标（世界空间）。
  - `uv`：纹理坐标（用于精确贴图交互）。

---

# MT算法讲解

### **Möller-Trumbore 算法详解**

Möller-Trumbore 算法（简称 **MT算法**）是一种高效的**射线-三角形相交检测算法**，由 Tomas Möller 和 Ben Trumbore 在 1997 年提出。它被广泛应用于 3D 图形学中的光线追踪（Ray Tracing）、碰撞检测（Collision Detection）以及 Three.js 等引擎的射线拾取（Raycasting）功能。

该算法的核心优势在于：
1. **直接计算交点**，无需预计算三角形所在平面方程。
2. **仅需一次求解线性方程组**，计算量小，效率高。
3. **返回交点的重心坐标（Barycentric Coordinates）**，可用于插值计算纹理坐标、法线等信息。

---

## **1. 算法输入与输出**
### **输入参数**
- **射线（Ray）**：
  - 起点 $$\mathbf{O}$$（`ray.origin`）。
  - 方向 $$\mathbf{D}$$（`ray.direction`，**单位向量**）。
- **三角形三个顶点**：
  - $$\mathbf{V_0}, \mathbf{V_1}, \mathbf{V_2}$$。

### **输出结果**
- **是否相交（`true/false`）**。
- 如果相交，返回：
  - 交点距离 $$t$$（沿射线的参数）。
  - 交点在该三角形上的**重心坐标  $$(u, v)$$**。

---

## **2. 数学推导**
MT算法的核心思想是**将射线方程和三角形参数方程联立求解**。

### **(1) 射线的参数方程**
射线上的任意一点可表示为：
$$\mathbf{R}(t) = \mathbf{O} + t \mathbf{D}, \quad t \geq 0$$

### **(2) 三角形的参数方程（重心坐标表示）**
三角形内的任意一点可表示为：
$$\mathbf{T}(u, v) = \mathbf{V_0} + u (\mathbf{V_1} - \mathbf{V_0}) + v (\mathbf{V_2} - \mathbf{V_0})$$
其中：
- $$u \geq 0$$, $$v \geq 0$$, $$u + v \leq 1$$（保证点在三角形内）。
- $$(\mathbf{V_1} - \mathbf{V_0})$$ 和 $$(\mathbf{V_2} - \mathbf{V_0})$$ 是两条边向量。

### **(3) 联立方程求交点**
令 $$\mathbf{R}(t) = \mathbf{T}(u, v)$$，得到：
$$\mathbf{O} + t \mathbf{D} = \mathbf{V_0} + u (\mathbf{V_1} - \mathbf{V_0}) + v (\mathbf{V_2} - \mathbf{V_0})$$
整理后：
$$\mathbf{O} - \mathbf{V_0} = -t \mathbf{D} + u (\mathbf{V_1} - \mathbf{V_0}) + v (\mathbf{V_2} - \mathbf{V_0})$$
写成矩阵形式：
$$\begin{bmatrix} 
-\mathbf{D} & \mathbf{V_1} - \mathbf{V_0} & \mathbf{V_2} - \mathbf{V_0} 
\end{bmatrix} 
\begin{bmatrix} 
t 
u 
v 
\end{bmatrix} 
= \mathbf{O} - \mathbf{V_0}$$
即：
$$\mathbf{A} \mathbf{x} = \mathbf{b}$$
其中：
- $$\mathbf{A} = \begin{bmatrix} -\mathbf{D} & \mathbf{E_1} & \mathbf{E_2} \end{bmatrix}$$（$$\mathbf{E_1} = \mathbf{V_1} - \mathbf{V_0}$$, $$\mathbf{E_2} = \mathbf{V_2} - \mathbf{V_0}$$）。
- $$\mathbf{x} = \begin{bmatrix} t \\ u \\ v \end{bmatrix}$$。
- $$\mathbf{b} = \mathbf{O} - \mathbf{V_0}$$。

### **(4) 使用克莱姆法则（Cramer's Rule）求解**
解该线性方程组，可以使用**克莱姆法则**：
$$t = \frac{\det(\mathbf{A_t})}{\det(\mathbf{A})}, \quad
u = \frac{\det(\mathbf{A_u})}{\det(\mathbf{A})}, \quad
v = \frac{\det(\mathbf{A_v})}{\det(\mathbf{A})}$$
其中：
- $$\mathbf{A_t}$$：用 $$\mathbf{b}$$ 替换 $$\mathbf{A}$$ 的第 1 列。
- $$\mathbf{A_u}$$：用 $$\mathbf{b}$$ 替换 $$\mathbf{A}$$ 的第 2 列。
- $$\mathbf{A_v}$$：用 $$\mathbf{b}$$ 替换 $$\mathbf{A}$$ 的第 3 列。
- $$\det(\mathbf{A})$$ 为矩阵 $$\mathbf{A}$$ 的行列式。

### **(5) 向量叉乘优化计算**
MT算法采用向量叉乘来高效计算行列式：
1. 定义：
   $$\mathbf{P} = \mathbf{D} \times \mathbf{E_2}$$

   $$\mathbf{Q} = \mathbf{T} \times \mathbf{E_1}, \quad \text{其中} \quad \mathbf{T} = \mathbf{O} - \mathbf{V_0}$$

2. 计算行列式：
   $$\det(\mathbf{A}) = \mathbf{E_1} \cdot \mathbf{P}$$
   
   $$t = \frac{\mathbf{E_2} \cdot \mathbf{Q}}{\det(\mathbf{A})}, \quad
   u = \frac{\mathbf{T} \cdot \mathbf{P}}{\det(\mathbf{A})}, \quad
   v = \frac{\mathbf{D} \cdot \mathbf{Q}}{\det(\mathbf{A})}$$

### **(6) 相交条件判断**
最终，交点有效的条件是：
1. $$\det(\mathbf{A}) \neq 0$$（避免除零错误）。
2. $$t \geq 0$$（交点在射线正方向上）。
3. $$u \geq 0$$, $$v \geq 0$$, $$u + v \leq 1$$（交点在三角形内部）。

---

## **3. 伪代码实现**
```python
def rayTriangleIntersect(O, D, V0, V1, V2):
    E1 = V1 - V0
    E2 = V2 - V0
    P = cross(D, E2)
    det = dot(E1, P)
    
    # 如果行列式接近0，射线与三角形平行
    if abs(det) < epsilon:
        return False, None
    
    inv_det = 1.0 / det
    T = O - V0
    
    # 计算u参数
    u = dot(T, P) * inv_det
    if u < 0 or u > 1:
        return False, None
    
    # 计算v参数
    Q = cross(T, E1)
    v = dot(D, Q) * inv_det
    if v < 0 or u + v > 1:
        return False, None
    
    # 计算t参数
    t = dot(E2, Q) * inv_det
    if t < 0:
        return False, None
    
    return True, (t, u, v)
```

---

## **4. 在 Three.js 中的应用**
Three.js 的 `Raycaster` 类在检测 `Mesh` 物体时，底层使用了 MT算法（见 `Ray.intersectTriangle` 方法）：
```javascript
// Three.js 源码中的简化实现
function intersectTriangle(ray, a, b, c, backfaceCulling, target) {
    const edge1 = subVectors(b, a);
    const edge2 = subVectors(c, a);
    const normal = crossVectors(edge1, edge2);

    // 背面剔除（backfaceCulling）
    const DdN = dot(ray.direction, normal);
    if (backfaceCulling && DdN >= 0) return null;

    // MT算法核心计算
    const P = crossVectors(ray.direction, edge2);
    const det = dot(edge1, P);
    if (det === 0) return null;

    const invDet = 1 / det;
    const T = subVectors(ray.origin, a);
    const u = dot(T, P) * invDet;
    if (u < 0 || u > 1) return null;

    const Q = crossVectors(T, edge1);
    const v = dot(ray.direction, Q) * invDet;
    if (v < 0 || u + v > 1) return null;

    const t = dot(edge2, Q) * invDet;
    if (t < 0) return null;

    return { distance: t, point: ray.at(t), uv: [u, v] };
}
```

---

## **5. 性能优化**
MT算法已经非常高效，但在大规模场景（如数百万三角形）中仍需优化：
1. **BVH加速**：使用 Bounding Volume Hierarchy（层次包围盒）减少检测的三角形数量。
2. **SIMD加速**：利用现代CPU的SIMD指令（如SSE/AVX）并行计算多个三角形。
3. **GPU计算**：在着色器中实现射线-三角形相交检测（用于光线追踪）。

---

## **6. 总结**
Möller-Trumbore 算法的核心是：
1. **联立射线和三角形方程**，用线性代数求解 $$(t, u, v)$$。
2. **利用向量叉乘和点乘优化行列式计算**，避免显式求逆矩阵。
3. **检查 $$t \geq 0$$、$$u \geq 0$$、$$v \geq 0$$、$$u + v \leq 1$$** 确认交点有效性。

它是 Three.js 射线拾取、光线追踪、碰撞检测等功能的数学基础，理解其原理对于优化 3D 交互至关重要。
