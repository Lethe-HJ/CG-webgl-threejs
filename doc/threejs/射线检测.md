# threejs中的射线拾取原理

---

### **1. 核心流程概述**
射线拾取的整个过程分为以下几个步骤：
1. **屏幕坐标转换**：将鼠标的2D屏幕坐标转换为3D空间中的一条射线（Ray）。
2. **射线与物体求交**：计算这条射线与场景中所有可交互物体的交点。
3. **筛选最近交点**：从所有交点中找出距离摄像机最近的物体，作为拾取结果。

---

### **2. 详细步骤解析**

#### **2.1 屏幕坐标 → 3D射线（Ray）**
Three.js需要将鼠标的2D像素坐标转换为3D世界空间中的一条射线，射线的起点是摄像机位置，方向指向鼠标点击的3D方向。

**关键代码**（摘自`Raycaster`类）：
```javascript
// 鼠标坐标归一化（NDC坐标系：[-1, 1]）
const mouseNDC = new THREE.Vector2(
    (mouseX / window.innerWidth) * 2 - 1,
    -(mouseY / window.innerHeight) * 2 + 1
);

// 通过摄像机和NDC坐标生成射线
raycaster.setFromCamera(mouseNDC, camera);
```

**数学原理**：
1. **归一化设备坐标（NDC）**：  
   将鼠标坐标从屏幕坐标系（`[0, width]` x `[0, height]`）转换为WebGL的NDC坐标系（`[-1, 1]` x `[-1, 1]`），Y轴需要反转（因为屏幕坐标原点在左上角，而WebGL在左下角）。

2. **生成射线**：  
   通过摄像机的投影矩阵（`projectionMatrix`）和视图矩阵（`modelViewMatrix`）的逆矩阵，将NDC坐标转换为世界空间中的射线方向：
   ```javascript
   // 伪代码：Three.js内部实现
   const origin = camera.position;
   const direction = mouseNDC
       .unproject(camera)               // 逆投影到相机近裁剪面
       .sub(camera.position)            // 计算方向向量
       .normalize();                    // 单位化
   ```

---

#### **2.2 射线与物体求交**
Three.js会遍历场景中的所有物体，检查射线是否与物体的几何体（`BufferGeometry`）相交。支持的几何体包括：`Mesh`、`Line`、`Points`等。

**求交算法**：
- **对于三角面片（Mesh）**：使用**Möller-Trumbore算法**（一种高效的射线-三角形相交算法）。  
- **对于球体/立方体**：使用包围盒（`Box3`）或包围球（`Sphere`）的快速近似检测。

**关键代码**：
```javascript
// Three.js内部对Mesh的射线相交检测
const intersection = ray.intersectTriangle(
    vertexA, vertexB, vertexC,      // 三角形的三个顶点
    false,                          // 是否背面剔除
    new THREE.Vector3()             // 存储交点的输出
);
```

**Möller-Trumbore算法简述**：  
通过解线性方程组计算射线与三角形的交点，利用向量叉乘和点乘优化计算：
1. 计算射线方向与三角形两条边的叉乘（确定共面性）。
2. 使用重心坐标（Barycentric Coordinates）判断交点是否在三角形内。
[MT算法详解](../图形学/MT算法.md)
---

#### **2.3 筛选最近交点**
Three.js会收集所有相交的物体，并按**交点距离摄像机的深度（Z值）**排序，返回最近的物体。

**关键代码**：
```javascript
// 对所有相交结果按距离排序
intersections.sort((a, b) => a.distance - b.distance);
const closest = intersections[0];
```

---

### **3. 性能优化机制**
为了提高拾取效率，Three.js采用了以下优化策略：
1. **层级剔除（Hierarchy Culling）**：  
   使用`BVH`（Bounding Volume Hierarchy）或简单的`BoundinSphere`快速排除不可能相交的物体。
2. **按需检测**：  
   通过`raycaster.params`指定检测的物体类型（如仅检测`Mesh`）：
   ```javascript
   raycaster.params.Points = false; // 忽略点云物体
   ```
3. **GPU加速**：  
   某些高级库（如`GPU-Picker`）会使用着色器在GPU端完成拾取（通过颜色编码）。

---

### **4. 实际应用示例**
```javascript
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onClick(event) {
    // 1. 转换鼠标坐标到NDC
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // 2. 生成射线
    raycaster.setFromCamera(mouse, camera);

    // 3. 检测相交物体
    const intersects = raycaster.intersectObjects(scene.children, true);

    // 4. 处理最近交点
    if (intersects.length > 0) {
        console.log("Clicked object:", intersects[0].object);
    }
}

window.addEventListener('click', onClick);
```

---

### **5. 关键数据结构**
- **`Raycaster`类**：核心拾取工具，管理射线和求交逻辑。
- **`Ray`**：表示3D射线的起点和方向。
- **`Intersection`对象**：存储交点信息，包括：
  - `object`：被击中的物体。
  - `distance`：交点距离摄像机的距离。
  - `point`：交点坐标（世界空间）。
  - `uv`：纹理坐标（用于精确贴图交互）。

---

