# OpenGL

Before starting our journey we should first define what OpenGL actually is. OpenGL is mainly considered an API (an Application Programming Interface) that provides us with a large set of functions that we can use to <u title="操控">manipulate</u> graphics and images. However, OpenGL by itself is not an API, but <u title="仅仅">merely</u> a <u title="规范">specification</u>, developed and <u title="维护">maintained</u> by the Khronos Group.

> 在开始我们的旅程之前，我们应该首先定义 OpenGL 到底是什么。OpenGL 主要被认为是一个 API（应用程序编程接口），它为我们提供了大量可用于操作图形和图像的函数。然而，OpenGL 本身并不是一个 API，而只是一个规范，由 Khronos Group 开发和维护。

The OpenGL specification specifies <u title="明确地">exactly</u> what the result/output of each function should be and how it should perform. It is then up to the developers implementing this specification to <u title="提出">come up with</u> a solution of how this function should operate. Since the OpenGL specification does not give us implementation details, the actual developed versions of OpenGL are allowed to have different implementations, <u title="只要">as long as</u> their results <u title="符合">comply with</u> the specification (and are <u title="因此">thus</u> the same to the user).

> OpenGL 规范准确指定了每个函数的结果/输出应该是什么以及它应该如何执行。然后由实现此规范的开发人员提出此函数应如何运行的解决方案。由于 OpenGL 规范没有为我们提供实现细节，因此允许实际开发的 OpenGL 版本具有不同的实现，只要它们的结果符合规范（因此对用户来说是相同的）。

The people developing the actual OpenGL libraries are usually the graphics card <u title="制造商">manufacturers</u>. Each graphics card that you buy supports specific versions of OpenGL which are the versions of OpenGL developed <u title="特地">specifically</u> for that card (series). When using an Apple system the OpenGL library is maintained by Apple themselves and under Linux there exists a combination of graphic suppliers' versions and <u title="爱好者">hobbyists</u>' <u title="改编">adaptations</u> of these libraries. This also means that whenever OpenGL is showing <u title="奇怪的">weird</u> behavior that it shouldn't, this is most likely the fault of the graphics cards manufacturers (or whoever developed/maintained the library).

> 开发实际 OpenGL 库的人通常是显卡制造商。您购买的每张显卡都支持特定版本的 OpenGL，这些版本是专门为该卡（系列）开发的 OpenGL 版本。当使用 Apple 系统时，OpenGL 库由 Apple 自己维护，在 Linux 下，存在图形供应商版本和业余爱好者对这些库的改编的组合。这也意味着，每当 OpenGL 出现它不应该出现的奇怪行为时，这很可能是显卡制造商（或开发/维护库的人）的错。

Since most implementations are built by graphics card manufacturers, whenever there is a bug in the implementation this is usually solved by updating your video card drivers; those drivers include the newest versions of OpenGL that your card supports. This is one of the reasons why it's always advised to <u title="偶尔">occasionally</u> update your graphic drivers.

> 由于大多数实现都是由显卡制造商构建的，因此每当实现中出现错误时，通常可以通过更新显卡驱动程序来解决;这些驱动程序包括您的卡支持的最新版本的 OpenGL。这就是为什么总是建议偶尔更新图形驱动程序的原因之一。

Khronos publicly <u title="托管">hosts</u> all specification documents for all the OpenGL versions. The interested reader can find the OpenGL specification of version 3.3 (which is what we'll be using) here which is a good read if you want to <u title="深入研究">delve into</u> the details of OpenGL (note how they mostly just describe results and not implementations). The specifications also provide a great reference for finding the exact workings of its functions.

> Khronos 公开托管所有 OpenGL 版本的所有规范文档。有兴趣的读者可以在这里找到 3.3 版的 OpenGL 规范（我们将使用），如果您想深入研究 OpenGL 的细节，这是一本很好的读物（请注意它们大多只是描述结果而不是实现）。这些规范还为查找其功能的确切工作原理提供了很好的参考。

## Core-profile vs Immediate mode 核心配置文件与即时模式

In the old days, using OpenGL meant developing in immediate mode (often referred to as the fixed function pipeline) which was an easy-to-use method for drawing graphics. Most of the <u title="功能">functionality</u> of OpenGL was hidden inside the library and developers did not have much control over how OpenGL does its calculations. Developers eventually got hungry for more flexibility and over time the specifications became more flexible as a result; developers gained more control over their graphics. The immediate mode is really easy to use and understand, but it is also extremely inefficient. For that reason the specification started to deprecate immediate mode functionality from version 3.2 <u title="向前">onwards</u> and started motivating developers to develop in OpenGL's core-profile mode, which is a division of OpenGL's specification that removed all old deprecated functionality.

> 在过去，使用 OpenGL 意味着以即时模式（通常称为固定函数管道）进行开发，这是一种易于使用的图形绘制方法。OpenGL 的大部分功能都隐藏在库中，开发人员对 OpenGL 如何进行计算没有太多控制权。开发人员最终渴望获得更大的灵活性，随着时间的推移，规范因此变得更加灵活;开发人员可以更好地控制其图形。即时模式确实易于使用和理解，但效率也非常低。出于这个原因，该规范从 3.2 版开始弃用即时模式功能，并开始激励开发人员在 OpenGL 的核心配置文件模式下进行开发，这是 OpenGL 规范的一个分支，删除了所有旧的不推荐使用的功能。

When using OpenGL's core-profile, OpenGL forces us to use modern practices. Whenever we try to use one of OpenGL's deprecated functions, OpenGL raises an error and stops drawing. The advantage of learning the modern <u title="方法">approach</u> is that it is very flexible and efficient. However, it's also more difficult to learn. The immediate mode abstracted quite a lot from the actual operations OpenGL performed and while it was easy to learn, it was hard to grasp how OpenGL actually operates. The modern approach requires the developer to truly understand OpenGL and graphics programming and while it is a bit difficult, it allows for much more flexibility, more efficiency and most importantly: a much better understanding of graphics programming.

> 在使用 OpenGL 的核心配置文件时，OpenGL 迫使我们使用现代实践。每当我们尝试使用 OpenGL 已弃用的函数之一时，OpenGL 都会引发错误并停止绘制。学习现代方法的优势在于它非常灵活和高效。但是，学习起来也比较困难。即时模式从OpenGL执行的实际操作中抽象出很多东西，虽然它很容易学习，但很难掌握OpenGL的实际操作方式。现代方法要求开发人员真正了解 OpenGL 和图形编程，虽然这有点困难，但它允许更大的灵活性、更高的效率，最重要的是：更好地理解图形编程。

This is also the reason why this book is <u title="面向">geared</u> at core-profile OpenGL version 3.3. Although it is more difficult, it is greatly worth the effort.

> 这也是本书面向核心配置文件 OpenGL 3.3 版的原因。虽然比较困难，但付出努力是非常值得的。

As of today, higher versions of OpenGL are available to choose from (at the time of writing 4.6) at which you may ask: why do I want to learn OpenGL 3.3 when OpenGL 4.6 is out? The answer to that question is relatively simple. All future versions of OpenGL starting from 3.3 add extra useful features to OpenGL without changing OpenGL's core mechanics; the newer versions just <u title="引入">introduce</u> <u title="稍微地">slightly</u> more efficient or more useful ways to accomplish the same tasks. The result is that all concepts and techniques remain the same over the modern OpenGL versions so it is perfectly valid to learn OpenGL 3.3. Whenever you're ready and/or more experienced you can easily use specific functionality from more recent OpenGL versions.

> 截至今天，OpenGL 的更高版本可供选择（在撰写 4.6 时），您可能会问：为什么当 OpenGL 4.6 发布时，我还要学习 OpenGL 3.3？这个问题的答案相对简单。从 3.3 开始，所有未来的 OpenGL 版本都会在不改变 OpenGL 核心机制的情况下为 OpenGL 添加额外的有用功能;较新的版本只是引入了更有效或更有用的方法来完成相同的任务。其结果是，所有概念和技术在现代 OpenGL 版本中保持不变，因此学习 OpenGL 3.3 是完全有效的。只要您准备好和/或更有经验，您就可以轻松使用最新 OpenGL 版本中的特定功能。

When using functionality from the most recent version of OpenGL, only the most modern graphics cards will be able to run your application. This is often why most developers generally target lower versions of OpenGL and optionally enable higher version functionality.

> 使用最新版本的 OpenGL 中的功能时，只有最现代的显卡才能运行您的应用程序。这通常是为什么大多数开发人员通常以 OpenGL 的较低版本为目标，并可以选择启用更高版本的功能。

In some chapters you'll find more modern features which are noted down as such.
> 在某些章节中，您会发现更多现代功能，这些功能被记录下来。

## Extensions 扩展

A great feature of OpenGL is its support of extensions. Whenever a graphics company comes up with a new technique or a new large optimization for rendering this is often found in an extension implemented in the drivers. If the hardware an application runs on supports such an extension the developer can use the functionality provided by the extension for more advanced or efficient graphics. This way, a graphics developer can still use these new rendering techniques without having to wait for OpenGL to include the functionality in its future versions, simply by checking if the extension is supported by the graphics card. Often, when an extension is popular or very useful it eventually becomes part of future OpenGL versions.

> OpenGL 的一大特点是它支持扩展。每当图形公司提出一种新技术或新的大型渲染优化时，这通常会在驱动程序中实现的扩展中找到。如果运行应用程序的硬件支持此类扩展，则开发人员可以使用扩展提供的功能来获得更高级或更高效的图形。这样一来，图形开发人员仍然可以使用这些新的渲染技术，而不必等待 OpenGL 在其未来的版本中包含这些功能，只需检查图形卡是否支持扩展即可。通常，当一个扩展很流行或非常有用时，它最终会成为未来 OpenGL 版本的一部分。

The developer has to query whether any of these extensions are available before using them (or use an OpenGL extension library). This allows the developer to do things better or more efficient, based on whether an extension is available:

> 开发人员在使用这些扩展之前必须查询它们中的任何一个是否可用（或使用 OpenGL 扩展库）。这允许开发人员根据扩展是否可用来做得更好或更高效：

```c
if(GL_ARB_extension_name)
{
    // Do cool new and modern stuff supported by hardware
}
else
{
    // Extension not supported: do it the old way
}
```

With OpenGL version 3.3 we rarely need an extension for most techniques, but wherever it is necessary proper instructions are provided.

> 在 OpenGL 3.3 版本中，我们很少需要对大多数技术进行扩展，但只要有必要，就会提供适当的说明。

## State machine 状态机

OpenGL is by itself a large state machine: a collection of variables that define how OpenGL should currently operate. The state of OpenGL is commonly referred to as the OpenGL context. When using OpenGL, we often change its state by setting some options, manipulating some buffers and then render using the current context.

> OpenGL 本身就是一个大型状态机：定义 OpenGL 当前应如何运行的变量集合。OpenGL 的状态通常称为 OpenGL 上下文。在使用 OpenGL 时，我们经常通过设置一些选项、操作一些缓冲区，然后使用当前上下文进行渲染来改变其状态。

Whenever we tell OpenGL that we now want to draw lines instead of triangles for example, we change the state of OpenGL by changing some context variable that sets how OpenGL should draw. As soon as we change the context by telling OpenGL it should draw lines, the next drawing commands will now draw lines instead of triangles.

> 假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。

When working in OpenGL we will come across several state-changing functions that change the context and several state-using functions that perform some operations based on the current state of OpenGL. As long as you keep in mind that OpenGL is basically one large state machine, most of its functionality will make more sense.

> 当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。

## Objects 对象

The OpenGL libraries are written in C and allows for many <u title="派生">derivations</u> in other languages, but in its core it remains a C-library. Since many of C's language-constructs do not translate that well to other higher-level languages, OpenGL was developed with several abstractions in mind. One of those abstractions are objects in OpenGL.

> OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。

An object in OpenGL is a collection of options that represents a subset of OpenGL's state. For example, we could have an object that represents the settings of the drawing window; we could then set its size, how many colors it supports and so on. One could visualize an object as a C-like struct:

> 在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：

```c
struct object_name {
    float  option1;
    int    option2;
    char[] name;
};
```

Whenever we want to use objects it generally looks something like this (with OpenGL's context visualized as a large struct):

> 每当我们想使用对象时，它通常看起来像这样（OpenGL 的上下文可视化为一个大结构）：

```c
// The State of OpenGL
struct OpenGL_Context {
  	...
  	object_name* object_Window_Target;
  	...  	
};
```

```c
// create object
unsigned int objectId = 0;
glGenObject(1, &objectId);
// bind/assign object to context
glBindObject(GL_WINDOW_TARGET, objectId);
// set options of object currently bound to GL_WINDOW_TARGET
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH,  800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
// set context target back to default
glBindObject(GL_WINDOW_TARGET, 0);
```

This little piece of code is a workflow you'll frequently see when working with OpenGL. We first create an object and store a reference to it as an id (the real object's data is stored behind the scenes). Then we bind the object (using its id) to the target location of the context (the location of the example window object target is defined as GL_WINDOW_TARGET). Next we set the window options and finally we un-bind the object by setting the current object id of the window target to 0. The options we set are stored in the object referenced by objectId and restored as soon as we bind the object back to GL_WINDOW_TARGET.

> 这一小段代码是您在使用 OpenGL 时经常看到的工作流。我们首先创建一个对象，并将对它的引用存储为 id（真实对象的数据存储在幕后）。然后，我们将对象（使用其 id）绑定到上下文的目标位置（示例窗口对象目标的位置定义为 GL_WINDOW_TARGET）。接下来，我们设置窗口选项，最后通过将窗口目标的当前对象 ID 设置为0 来取消绑定对象。我们设置的选项存储在 objectId 引用的对象中，并在我们将对象绑定回 GL_WINDOW_TARGET 后立即恢复。

The code samples provided so far are only approximations of how OpenGL operates; throughout the book you will come across enough actual examples.

> 到目前为止提供的代码示例只是 OpenGL 运行方式的近似值;在整本书中，你会遇到足够多的实际例子

The great thing about using these objects is that we can define more than one object in our application, set their options and whenever we start an operation that uses OpenGL's state, we bind the object with our preferred settings. There are objects for example that act as container objects for 3D model data (a house or a character) and whenever we want to draw one of them, we bind the object containing the model data that we want to draw (we first created and set options for these objects). Having several objects allows us to specify many models and whenever we want to draw a specific model, we simply bind the corresponding object before drawing without setting all their options again.

> 使用这些对象的好处在于，我们可以在应用程序中定义多个对象，设置它们的选项，每当我们启动使用 OpenGL 状态的操作时，我们都会将对象与我们的首选设置绑定。例如，有些对象充当 3D 模型数据（房屋或角色）的容器对象，每当我们想要绘制其中一个对象时，我们都会绑定包含要绘制的模型数据的对象（我们首先为这些对象创建并设置选项）。拥有多个对象允许我们指定许多模型，每当我们想要绘制特定模型时，我们只需在绘制之前绑定相应的对象，而无需再次设置它们的所有选项。

## Let's get started 让我们开始吧

You now learned a bit about OpenGL as a specification and a library, how OpenGL <u title="大致地">approximately</u> operates <u title="在后台">under the hood</u> and a few custom <u title="技巧">tricks</u> that OpenGL uses. Don't worry if you didn't get all of it; throughout the book we'll walk through each step and you'll see enough examples to really get a grasp of OpenGL.

> 现在，您了解了 OpenGL 作为规范和库的一些知识，OpenGL 如何在后台大致运行，以及 OpenGL 使用的一些自定义技巧。如果您没有得到所有的东西，请不要担心;在整本书中，我们将逐步介绍每个步骤，您将看到足够多的示例来真正掌握 OpenGL。