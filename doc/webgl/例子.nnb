{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "### 1 示例 百叶窗特效\r\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n  attribute vec4 aPosition;\r\n  varying vec4 vPosition;\r\n  void main() {\r\n    vPosition = aPosition;\r\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\r\n    gl_PointSize = 10.0;\r\n  }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n  precision lowp float;\r\n  uniform float uHeight;\r\n  varying vec4 vPosition;\r\n  uniform float list[5]; // 声明一个数组变量\r\n\r\n  void main() {\r\n    for(int i = 0; i < 5; i++) {\r\n      if (vPosition.y > list[i + 1] && vPosition.y < list[i]) {\r\n        if (vPosition.y > uHeight - float(i) * 0.5) {\r\n          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n        }\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const uHeight = gl.getUniformLocation(program, 'uHeight');\r\n  const uList = gl.getUniformLocation(program,'list');\r\n\r\n  gl.uniform1fv(uList, [1.0, 0.5, 0.0, -0.5, -1.0]);\r\n  const points = new Float32Array([\r\n    -1.0, -1.0,\r\n    1.0, -1.0,\r\n    -1.0,  1.0,\r\n    1.0,  1.0,\r\n  ])\r\n  \r\n  const buffer = gl.createBuffer();\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n  gl.enableVertexAttribArray(aPosition)\r\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\r\n\r\n  let value = 1;\r\n  function run() {\r\n    value -= 0.01;\r\n\r\n    gl.uniform1f(uHeight, value);\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n\r\n    requestAnimationFrame(run)\r\n  }\r\n  run();\r\n`;\r\nconst { renderWebgl } = require(\"../../src/display.js\");\r\nrenderWebgl(vertex_code, fragment_code, js_code);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "Error",
                                "message": "Cannot find module 'uuid'\nRequire stack:\n- d:\\workspace\\CG-webgl-threejs\\src\\display.js\n- <repl>",
                                "stack": "    at Function.Module._resolveFilename (node:internal/modules/cjs/loader:1142:15)\n    at Function.Module._resolveFilename.sharedData.moduleResolveFilenameHook.installedValue [as _resolveFilename] (c:\\Users\\hujing1\\.vscode\\extensions\\donjayamanne.typescript-notebook-2.0.6\\resources\\scripts\\node_modules\\@cspotcode\\source-map-support\\source-map-support.js:679:30)\n    at Function.Module._load (node:internal/modules/cjs/loader:983:27)\n    at Function._._load (c:\\Users\\hujing1\\.vscode\\extensions\\donjayamanne.typescript-notebook-2.0.6\\out\\extension\\server\\index.js:2:115372)\n    at Module.require (node:internal/modules/cjs/loader:1230:19)\n    at require (node:internal/modules/helpers:179:18)\n    at renderWebgl (d:\\workspace\\CG-webgl-threejs\\src\\display.js:62:26)\n    at <Cell 2> [64, 11]\n    at <Cell 2> [65, 46]\n    at Script.runInContext (node:vm:148:12)"
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2 示例 淡入淡出特效\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n  attribute vec4 aPosition;\r\n  void main() {\r\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\r\n    gl_PointSize = 10.0;\r\n  }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n  precision lowp float;\r\n  uniform float uOpacity;\r\n  void main() {\r\n    gl_FragColor = vec4(1.0,0.0,0.0,uOpacity);\r\n  }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const uOpacity = gl.getUniformLocation(program, 'uOpacity');\r\n\r\n  const points = new Float32Array([\r\n    -1.0, -1.0,\r\n    1.0, -1.0,\r\n    -1.0,  1.0,\r\n    1.0,  1.0,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n  gl.enableVertexAttribArray(aPosition)\r\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\r\n\r\n  let value = 0;\r\n  function run() {\r\n    value += 0.01;\r\n    gl.uniform1f(uOpacity, value);\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n    requestAnimationFrame(run)\r\n  }\r\n  run();\r\n`;\r\nconst { renderWebgl } = require(\"../../src/display.js\");\r\nrenderWebgl(vertex_code, fragment_code, js_code);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "Error",
                                "message": "Cannot find module 'uuid'\nRequire stack:\n- d:\\workspace\\CG-webgl-threejs\\src\\display.js\n- <repl>",
                                "stack": "    at Function.Module._resolveFilename (node:internal/modules/cjs/loader:1142:15)\n    at Function.Module._resolveFilename.sharedData.moduleResolveFilenameHook.installedValue [as _resolveFilename] (c:\\Users\\hujing1\\.vscode\\extensions\\donjayamanne.typescript-notebook-2.0.6\\resources\\scripts\\node_modules\\@cspotcode\\source-map-support\\source-map-support.js:679:30)\n    at Function.Module._load (node:internal/modules/cjs/loader:983:27)\n    at Function._._load (c:\\Users\\hujing1\\.vscode\\extensions\\donjayamanne.typescript-notebook-2.0.6\\out\\extension\\server\\index.js:2:115372)\n    at Module.require (node:internal/modules/cjs/loader:1230:19)\n    at require (node:internal/modules/helpers:179:18)\n    at renderWebgl (d:\\workspace\\CG-webgl-threejs\\src\\display.js:62:26)\n    at <Cell 4> [49, 11]\n    at <Cell 4> [50, 46]\n    at Script.runInContext (node:vm:148:12)"
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n  attribute vec4 aPosition;\r\n  varying vec4 vPosition;\r\n  void main() {\r\n    vPosition = aPosition;\r\n\r\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\r\n    gl_PointSize = 10.0;\r\n  }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n  precision lowp float;\r\n  uniform float uHeight;\r\n  varying vec4 vPosition;\r\n\r\n  void main() {\r\n    // 向上卷 vPosition.y > uHeight   uHeight 的取值范围 -1.0 1.0\r\n    // 向下卷 vPosition.y < uHeight   uHeight 的取值范围 -1.0 1.0\r\n    // 向左卷 vPosition.x < uHeight   uHeight 的取值范围 -1.0 1.0\r\n    // 向右卷 vPosition.x > uHeight   uHeight 的取值范围 -1.0 1.0\r\n    // 左下-右上\r\n    // vPosition.x > uHeight && vPosition.y > uHeight\r\n    // uHeight 从 -1.0 到 1.0\r\n\r\n    if (vPosition.y > uHeight) {\r\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n    } else {\r\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);\r\n    }\r\n  }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const uHeight = gl.getUniformLocation(program, 'uHeight');\r\n\r\n  const points = new Float32Array([\r\n    -1.0, -1.0,\r\n    1.0, -1.0,\r\n    -1.0,  1.0,\r\n    1.0,  1.0,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n  gl.enableVertexAttribArray(aPosition)\r\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\r\n  \r\n  let value = -1;\r\n  function run() {\r\n    value += 0.01;\r\n    gl.uniform1f(uHeight, value);\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n    requestAnimationFrame(run)\r\n  }\r\n  run();\r\n`;\r\n\r\nconst { renderWebgl } = require(\"../../src/display.js\");\r\nrenderWebgl(vertex_code, fragment_code, js_code);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"69458310-bf31-11ee-a6c0-b1d9d1362f8a\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('69458310-bf31-11ee-a6c0-b1d9d1362f8a');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  varying vec4 vPosition;\\n  void main() {\\n    vPosition = aPosition;\\n\\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  precision lowp float;\\n  uniform float uHeight;\\n  varying vec4 vPosition;\\n\\n  void main() {\\n    // 向上卷 vPosition.y > uHeight   uHeight 的取值范围 -1.0 1.0\\n    // 向下卷 vPosition.y < uHeight   uHeight 的取值范围 -1.0 1.0\\n    // 向左卷 vPosition.x < uHeight   uHeight 的取值范围 -1.0 1.0\\n    // 向右卷 vPosition.x > uHeight   uHeight 的取值范围 -1.0 1.0\\n    // 左下-右上\\n    // vPosition.x > uHeight && vPosition.y > uHeight\\n    // uHeight 从 -1.0 到 1.0\\n\\n    if (vPosition.y > uHeight) {\\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n    } else {\\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);\\n    }\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const uHeight = gl.getUniformLocation(program, 'uHeight');",
                                "",
                                "  const points = new Float32Array([",
                                "    -1.0, -1.0,",
                                "    1.0, -1.0,",
                                "    -1.0,  1.0,",
                                "    1.0,  1.0,",
                                "  ])",
                                "",
                                "  const buffer = gl.createBuffer();",
                                "",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)",
                                "  ",
                                "  let value = -1;",
                                "  function run() {",
                                "    value += 0.01;",
                                "    gl.uniform1f(uHeight, value);",
                                "    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);",
                                "    requestAnimationFrame(run)",
                                "  }",
                                "  run();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 图形圆角"
            ],
            "outputs": []
        },
        {
            "language": "html",
            "source": [
                "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>Title</title>\r\n  <script src=\"../lib/index.js\"></script>\r\n  <style>\r\n    * {\r\n      margin: 0;\r\n      padding: 0;\r\n    }\r\n\r\n    canvas{\r\n      margin: 50px auto 0;\r\n      display: block;\r\n      background: yellow;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n  <canvas id=\"canvas\" width=\"400\" height=\"400\">\r\n    此浏览器不支持canvas\r\n  </canvas>\r\n</body>\r\n</html>\r\n<script>\r\n\r\n  const ctx = document.getElementById('canvas')\r\n\r\n  const gl = ctx.getContext('webgl')\r\n\r\n  // 创建着色器源码\r\n  const VERTEX_SHADER_SOURCE = `\r\n    // 只传递顶点数据\r\n    attribute vec4 aPosition;\r\n    varying vec4 vPosition;\r\n    void main() {\r\n      gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\r\n      vPosition = aPosition;\r\n      gl_PointSize = 10.0;\r\n    }\r\n  `; // 顶点着色器\r\n\r\n  const FRAGMENT_SHADER_SOURCE = `\r\n    precision lowp float;\r\n    uniform float radius;\r\n    uniform float w;\r\n    uniform float h;\r\n    varying vec4 vPosition;\r\n\r\n    void setColor(float x, float y, vec2 target) {\r\n      float d = distance(vec2(target), vec2(x, y));\r\n\r\n      if (d > radius) {\r\n        discard;\r\n      } else {\r\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n      }\r\n    }\r\n\r\n    void main() {\r\n      float x = vPosition.x;\r\n      float y = vPosition.y;\r\n\r\n      // 左上\r\n      vec2 topLeft = vec2(-w + radius, h - radius);\r\n\r\n      // 右上\r\n      vec2 topRight = vec2(w - radius, h - radius);\r\n\r\n      // 左下\r\n      vec2 bottomLeft = vec2(-w + radius, -h + radius);\r\n\r\n      // 右下\r\n      vec2 bottomRight = vec2(w - radius, -h + radius);\r\n\r\n      if (x < topLeft.x && y > topLeft.y) {\r\n\r\n        setColor(x, y, topLeft);\r\n\r\n      } else if (x > topRight.x && y > topRight.y) {\r\n\r\n        setColor(x, y, topRight);\r\n\r\n      } else if (x < bottomLeft.x && y < bottomLeft.y) {\r\n\r\n        setColor(x, y, bottomLeft);\r\n\r\n      } else if (x > bottomRight.x && y < bottomRight.y) {\r\n\r\n        setColor(x, y, bottomRight);\r\n\r\n      } else {\r\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n      }\r\n    }\r\n  `; // 片元着色器\r\n\r\n  const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)\r\n\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const radius = gl.getUniformLocation(program, 'radius');\r\n  const w = gl.getUniformLocation(program, 'w');\r\n  const h = gl.getUniformLocation(program, 'h');\r\n\r\n  const size = 0.5;\r\n  const points = new Float32Array([\r\n    -size, -size,\r\n     size, -size,\r\n    -size,  size,\r\n     size,  size,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n  gl.enableVertexAttribArray(aPosition)\r\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\r\n\r\n  gl.uniform1f(radius, 0.1);\r\n  gl.uniform1f(w, size);\r\n  gl.uniform1f(h, size);\r\n\r\n  const start = () => {\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n\r\n    requestAnimationFrame(start)\r\n  }\r\n\r\n  start();\r\n\r\n</script>\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 绘制圆环\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "  // 创建着色器源码\r\n  const vertex_code = /*glsl */ `\r\n    void main() {\r\n      gl_Position = vec4(0.0,0.0,0.0,1.0);\r\n      gl_PointSize = 100.0;\r\n    }\r\n  `; // 顶点着色器\r\n\r\n  const fragment_code = /*glsl */ `\r\n    precision lowp float;\r\n\r\n    // float distanceSelf(vec3 a, vec3 b) {\r\n    //   float x = a.x - b.x;\r\n    //   float y = a.y - b.y;\r\n    //   float z = a.z - b.z;\r\n    //\r\n    //   float v = x * x + y * y + z * z;\r\n    //\r\n    //   return sqrt(v);\r\n    // }\r\n\r\n    float distanceSelf(vec2 a, vec2 b) {\r\n      float x = a.x - b.x;\r\n      float y = a.y - b.y;\r\n\r\n      float v = x * x + y * y;\r\n\r\n      return sqrt(v);\r\n    }\r\n\r\n    void main() {\r\n      // 计算距离\r\n      // float dis = distance(gl_PointCoord, vec2(0.5,0.5));\r\n      float dis = distanceSelf(gl_PointCoord, vec2(0.5,0.5));\r\n\r\n      if (dis > 0.5 || (dis < 0.4 && dis > 0.3) || dis < 0.2) {\r\n        discard;\r\n      }\r\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n    }\r\n  `; // 片元着色器\r\n\r\nconst js_code = /*js*/ `\r\n  gl.drawArrays(gl.POINTS, 0, 1);\r\n`\r\n\r\n  const { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require(\"path\");\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code, libs);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          { // 限制变量定义域",
                                "              function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {\r",
                                "  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r",
                                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r",
                                "\r",
                                "  gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE); // 指定顶点着色器的源码\r",
                                "  gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE); // 指定片元着色器的源码\r",
                                "\r",
                                "  // 编译着色器\r",
                                "  gl.compileShader(vertexShader);\r",
                                "  gl.compileShader(fragmentShader);\r",
                                "\r",
                                "  // 创建一个程序对象\r",
                                "  const program = gl.createProgram();\r",
                                "\r",
                                "  gl.attachShader(program, vertexShader);\r",
                                "  gl.attachShader(program, fragmentShader);\r",
                                "\r",
                                "  gl.linkProgram(program);\r",
                                "\r",
                                "  gl.useProgram(program);\r",
                                "\r",
                                "  return program;\r",
                                "}\r",
                                "\r",
                                "// 平移矩阵\r",
                                "function getTranslateMatrix(x = 0, y = 0, z = 0) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1.0, 0.0, 0.0, 0.0,\r",
                                "    0.0, 1.0, 0.0, 0.0,\r",
                                "    0.0, 0.0, 1.0, 0.0,\r",
                                "    x  , y  , z  , 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 缩放矩阵\r",
                                "function getScaleMatrix(x = 1, y = 1, z = 1) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x  , 0.0, 0.0, 0.0,\r",
                                "    0.0, y  , 0.0, 0.0,\r",
                                "    0.0, 0.0, z  , 0.0,\r",
                                "    0.0, 0.0, 0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 绕z轴旋转的旋转矩阵\r",
                                "function getRotateMatrix(deg) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    Math.cos(deg),  Math.sin(deg), 0.0,0.0,\r",
                                "    -Math.sin(deg), Math.cos(deg), 0.0,0.0,\r",
                                "    0.0,            0.0,           1.0,0.0,\r",
                                "    0.0,            0.0,           0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 矩阵复合函数\r",
                                "function mixMatrix(A, B) {\r",
                                "  const result = new Float32Array(16);\r",
                                "\r",
                                "  for (let i = 0; i < 4; i++) {\r",
                                "    result[i] =\r",
                                "      A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3];\r",
                                "    result[i + 4] =\r",
                                "      A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7];\r",
                                "    result[i + 8] =\r",
                                "      A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11];\r",
                                "    result[i + 12] =\r",
                                "      A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15];\r",
                                "  }\r",
                                "\r",
                                "  return result;\r",
                                "}\r",
                                "\r",
                                "// 归一化函数\r",
                                "function normalized(arr) {\r",
                                "  let sum = 0;\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    sum += arr[i] * arr[i];\r",
                                "  }\r",
                                "\r",
                                "  const middle = Math.sqrt(sum);\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    arr[i] = arr[i] / middle;\r",
                                "  }\r",
                                "}\r",
                                "\r",
                                "// 叉积函数 获取法向量\r",
                                "function cross(a, b) {\r",
                                "  return new Float32Array([\r",
                                "    a[1] * b[2] - a[2] * b[1],\r",
                                "    a[2] * b[0] - a[0] * b[2],\r",
                                "    a[0] * b[1] - a[1] * b[0],\r",
                                "  ]);\r",
                                "}\r",
                                "\r",
                                "// 点积函数 获取投影长度\r",
                                "function dot(a, b) {\r",
                                "  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r",
                                "}\r",
                                "\r",
                                "// 向量差\r",
                                "function minus(a, b) {\r",
                                "  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);\r",
                                "}\r",
                                "\r",
                                "// 视图矩阵获取\r",
                                "function getViewMatrix(\r",
                                "  eyex,\r",
                                "  eyey,\r",
                                "  eyez,\r",
                                "  lookAtx,\r",
                                "  lookAty,\r",
                                "  lookAtz,\r",
                                "  upx,\r",
                                "  upy,\r",
                                "  upz\r",
                                ") {\r",
                                "  // 视点\r",
                                "  const eye = new Float32Array([eyex, eyey, eyez]);\r",
                                "  // 目标点\r",
                                "  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\r",
                                "  // 上方向\r",
                                "  const up = new Float32Array([upx, upy, upz]);\r",
                                "\r",
                                "  // 确定z轴\r",
                                "  const z = minus(eye, lookAt);\r",
                                "\r",
                                "  normalized(z);\r",
                                "  normalized(up);\r",
                                "\r",
                                "  // 确定x轴\r",
                                "  const x = cross(z, up);\r",
                                "\r",
                                "  normalized(x);\r",
                                "  // 确定y轴\r",
                                "  const y = cross(x, z);\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x[0],       y[0],       z[0],       0,\r",
                                "    x[1],       y[1],       z[1],       0,\r",
                                "    x[2],       y[2],       z[2],       0,\r",
                                "    -dot(x,eye),-dot(y,eye),-dot(z,eye),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取正射投影矩阵\r",
                                "function getOrtho(l, r, t, b, n, f) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    2 / (r - l), 0,           0,           0,\r",
                                "    0,           2/(t-b),     0,           0,\r",
                                "    0,           0,           -2/(f-n),    0,\r",
                                "    -(r+l)/(r-l),-(t+b)/(t-b),-(f+n)/(f-n),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "\r",
                                "// 获取透视投影矩阵\r",
                                "function getPerspective(fov, aspect, far, near) {\r",
                                "  fov = (fov * Math.PI) / 180;\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1/(aspect*Math.tan(fov / 2)), 0,                   0,                      0,\r",
                                "    0,                            1/(Math.tan(fov/2)), 0,                      0,\r",
                                "    0,                            0,                   -(far+near)/(far-near), -(2*far*near)/(far-near),\r",
                                "    0,                            0,                   -1,                     0,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "function distanceSelf(a, b) {\r",
                                "  const x = a[0] - b[0];\r",
                                "  const y = a[1] - b[1];\r",
                                "  const z = a[2] - b[2];\r",
                                "\r",
                                "  const v = x * x + y * y + z * z;\r",
                                "\r",
                                "  return Math.sqrt(v);\r",
                                "}\r",
                                "",
                                "          }",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"452ef120-c67d-11ee-9b98-5f8c44c97abf\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('452ef120-c67d-11ee-9b98-5f8c44c97abf');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    void main() {\\n      gl_Position = vec4(0.0,0.0,0.0,1.0);\\n      gl_PointSize = 100.0;\\n    }\\n  \"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    precision lowp float;\\n\\n    // float distanceSelf(vec3 a, vec3 b) {\\n    //   float x = a.x - b.x;\\n    //   float y = a.y - b.y;\\n    //   float z = a.z - b.z;\\n    //\\n    //   float v = x * x + y * y + z * z;\\n    //\\n    //   return sqrt(v);\\n    // }\\n\\n    float distanceSelf(vec2 a, vec2 b) {\\n      float x = a.x - b.x;\\n      float y = a.y - b.y;\\n\\n      float v = x * x + y * y;\\n\\n      return sqrt(v);\\n    }\\n\\n    void main() {\\n      // 计算距离\\n      // float dis = distance(gl_PointCoord, vec2(0.5,0.5));\\n      float dis = distanceSelf(gl_PointCoord, vec2(0.5,0.5));\\n\\n      if (dis > 0.5 || (dis < 0.4 && dis > 0.3) || dis < 0.2) {\\n        discard;\\n      }\\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n  \"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  gl.drawArrays(gl.POINTS, 0, 1);",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 绘制半透明物体\r\n\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n    attribute vec4 aPosition;\r\n    attribute vec4 aNormal;\r\n    varying vec4 vColor;\r\n\r\n    uniform mat4 mat;\r\n    void main() {\r\n      // 定义点光源的颜色\r\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\r\n\r\n      // 点光源的位置\r\n      vec3 uPointLightPosition = vec3(-5.0,6.0,10.0);\r\n\r\n      // 环境光\r\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\r\n\r\n      // 物体表面的颜色\r\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\r\n\r\n      // 顶点的世界坐标\r\n      vec4 vertexPosition = mat * aPosition;\r\n\r\n      // 点光源的方向\r\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\r\n\r\n      // 环境反射\r\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\r\n\r\n      // 计算入射角 光线方向和法线方向的点积\r\n      float dotDeg = dot(lightDirection, vec3(aNormal));\r\n\r\n      // 漫反射光的颜色\r\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\r\n\r\n      gl_Position = vertexPosition;\r\n      vColor = vec4(ambient + diffuseColor, 0.5);\r\n    }\r\n  `; // 顶点着色器\r\n\r\nconst fragment_code = /*glsl */ `\r\n    precision lowp float;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `; // 片元着色器\r\n\r\nconst js_code = /*js*/ `\r\n\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const aNormal = gl.getAttribLocation(program, 'aNormal');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n\r\n  const vertices = new Float32Array([\r\n    // 0123\r\n    1, 1, 1,\r\n    -1, 1, 1,\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    // 0345\r\n    1, 1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    // 0156\r\n    1, 1, 1,\r\n    1, 1, -1,\r\n    -1, 1,-1,\r\n    -1, 1,1,\r\n    // 1267\r\n    -1, 1, 1,\r\n    -1,1, -1,\r\n    -1, -1,-1,\r\n    -1,-1,1,\r\n    // 2347\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    -1,-1,-1,\r\n    // 4567\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    -1, 1,-1,\r\n    -1,-1,-1,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n\r\n  // 法向量\r\n  const normals = new Float32Array([\r\n    0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,\r\n    0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,\r\n    -1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,\r\n    1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,\r\n    0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,\r\n    0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,\r\n  ])\r\n  const normalBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aNormal)\r\n\r\n  const indeces = new Uint8Array([\r\n    0,1,2,0,2,3,\r\n    4,5,6,4,6,7,\r\n    8,9,10,8,10,11,\r\n    12,13,14,12,14,15,\r\n    16,17,18,16,18,19,\r\n    20,21,22,20,22,23,\r\n  ])\r\n  const indexBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);\r\n\r\n  gl.enable(gl.BLEND);\r\n\r\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n  const vm = getViewMatrix(3,3,5,0.0,0.0,0.0,0.0,0.6,0.0);\r\n  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\r\n\r\n  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));\r\n  gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);\r\n  `;\r\n\r\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require(\"path\");\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code, libs);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          { // 限制变量定义域",
                                "              function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {\r",
                                "  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r",
                                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r",
                                "\r",
                                "  gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE); // 指定顶点着色器的源码\r",
                                "  gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE); // 指定片元着色器的源码\r",
                                "\r",
                                "  // 编译着色器\r",
                                "  gl.compileShader(vertexShader);\r",
                                "  gl.compileShader(fragmentShader);\r",
                                "\r",
                                "  // 创建一个程序对象\r",
                                "  const program = gl.createProgram();\r",
                                "\r",
                                "  gl.attachShader(program, vertexShader);\r",
                                "  gl.attachShader(program, fragmentShader);\r",
                                "\r",
                                "  gl.linkProgram(program);\r",
                                "\r",
                                "  gl.useProgram(program);\r",
                                "\r",
                                "  return program;\r",
                                "}\r",
                                "\r",
                                "// 平移矩阵\r",
                                "function getTranslateMatrix(x = 0, y = 0, z = 0) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1.0, 0.0, 0.0, 0.0,\r",
                                "    0.0, 1.0, 0.0, 0.0,\r",
                                "    0.0, 0.0, 1.0, 0.0,\r",
                                "    x  , y  , z  , 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 缩放矩阵\r",
                                "function getScaleMatrix(x = 1, y = 1, z = 1) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x  , 0.0, 0.0, 0.0,\r",
                                "    0.0, y  , 0.0, 0.0,\r",
                                "    0.0, 0.0, z  , 0.0,\r",
                                "    0.0, 0.0, 0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 绕z轴旋转的旋转矩阵\r",
                                "function getRotateMatrix(deg) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    Math.cos(deg),  Math.sin(deg), 0.0,0.0,\r",
                                "    -Math.sin(deg), Math.cos(deg), 0.0,0.0,\r",
                                "    0.0,            0.0,           1.0,0.0,\r",
                                "    0.0,            0.0,           0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 矩阵复合函数\r",
                                "function mixMatrix(A, B) {\r",
                                "  const result = new Float32Array(16);\r",
                                "\r",
                                "  for (let i = 0; i < 4; i++) {\r",
                                "    result[i] =\r",
                                "      A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3];\r",
                                "    result[i + 4] =\r",
                                "      A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7];\r",
                                "    result[i + 8] =\r",
                                "      A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11];\r",
                                "    result[i + 12] =\r",
                                "      A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15];\r",
                                "  }\r",
                                "\r",
                                "  return result;\r",
                                "}\r",
                                "\r",
                                "// 归一化函数\r",
                                "function normalized(arr) {\r",
                                "  let sum = 0;\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    sum += arr[i] * arr[i];\r",
                                "  }\r",
                                "\r",
                                "  const middle = Math.sqrt(sum);\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    arr[i] = arr[i] / middle;\r",
                                "  }\r",
                                "}\r",
                                "\r",
                                "// 叉积函数 获取法向量\r",
                                "function cross(a, b) {\r",
                                "  return new Float32Array([\r",
                                "    a[1] * b[2] - a[2] * b[1],\r",
                                "    a[2] * b[0] - a[0] * b[2],\r",
                                "    a[0] * b[1] - a[1] * b[0],\r",
                                "  ]);\r",
                                "}\r",
                                "\r",
                                "// 点积函数 获取投影长度\r",
                                "function dot(a, b) {\r",
                                "  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r",
                                "}\r",
                                "\r",
                                "// 向量差\r",
                                "function minus(a, b) {\r",
                                "  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);\r",
                                "}\r",
                                "\r",
                                "// 视图矩阵获取\r",
                                "function getViewMatrix(\r",
                                "  eyex,\r",
                                "  eyey,\r",
                                "  eyez,\r",
                                "  lookAtx,\r",
                                "  lookAty,\r",
                                "  lookAtz,\r",
                                "  upx,\r",
                                "  upy,\r",
                                "  upz\r",
                                ") {\r",
                                "  // 视点\r",
                                "  const eye = new Float32Array([eyex, eyey, eyez]);\r",
                                "  // 目标点\r",
                                "  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\r",
                                "  // 上方向\r",
                                "  const up = new Float32Array([upx, upy, upz]);\r",
                                "\r",
                                "  // 确定z轴\r",
                                "  const z = minus(eye, lookAt);\r",
                                "\r",
                                "  normalized(z);\r",
                                "  normalized(up);\r",
                                "\r",
                                "  // 确定x轴\r",
                                "  const x = cross(z, up);\r",
                                "\r",
                                "  normalized(x);\r",
                                "  // 确定y轴\r",
                                "  const y = cross(x, z);\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x[0],       y[0],       z[0],       0,\r",
                                "    x[1],       y[1],       z[1],       0,\r",
                                "    x[2],       y[2],       z[2],       0,\r",
                                "    -dot(x,eye),-dot(y,eye),-dot(z,eye),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取正射投影矩阵\r",
                                "function getOrtho(l, r, t, b, n, f) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    2 / (r - l), 0,           0,           0,\r",
                                "    0,           2/(t-b),     0,           0,\r",
                                "    0,           0,           -2/(f-n),    0,\r",
                                "    -(r+l)/(r-l),-(t+b)/(t-b),-(f+n)/(f-n),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "\r",
                                "// 获取透视投影矩阵\r",
                                "function getPerspective(fov, aspect, far, near) {\r",
                                "  fov = (fov * Math.PI) / 180;\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1/(aspect*Math.tan(fov / 2)), 0,                   0,                      0,\r",
                                "    0,                            1/(Math.tan(fov/2)), 0,                      0,\r",
                                "    0,                            0,                   -(far+near)/(far-near), -(2*far*near)/(far-near),\r",
                                "    0,                            0,                   -1,                     0,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "function distanceSelf(a, b) {\r",
                                "  const x = a[0] - b[0];\r",
                                "  const y = a[1] - b[1];\r",
                                "  const z = a[2] - b[2];\r",
                                "\r",
                                "  const v = x * x + y * y + z * z;\r",
                                "\r",
                                "  return Math.sqrt(v);\r",
                                "}\r",
                                "",
                                "          }",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"011b0130-c67e-11ee-9b98-5f8c44c97abf\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('011b0130-c67e-11ee-9b98-5f8c44c97abf');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    attribute vec4 aNormal;\\n    varying vec4 vColor;\\n\\n    uniform mat4 mat;\\n    void main() {\\n      // 定义点光源的颜色\\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\\n\\n      // 点光源的位置\\n      vec3 uPointLightPosition = vec3(-5.0,6.0,10.0);\\n\\n      // 环境光\\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\\n\\n      // 物体表面的颜色\\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\\n\\n      // 顶点的世界坐标\\n      vec4 vertexPosition = mat * aPosition;\\n\\n      // 点光源的方向\\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\\n\\n      // 环境反射\\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\\n\\n      // 计算入射角 光线方向和法线方向的点积\\n      float dotDeg = dot(lightDirection, vec3(aNormal));\\n\\n      // 漫反射光的颜色\\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\\n\\n      gl_Position = vertexPosition;\\n      vColor = vec4(ambient + diffuseColor, 0.5);\\n    }\\n  \"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    precision lowp float;\\n    varying vec4 vColor;\\n\\n    void main() {\\n      gl_FragColor = vColor;\\n    }\\n  \"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const aNormal = gl.getAttribLocation(program, 'aNormal');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "",
                                "  const vertices = new Float32Array([",
                                "    // 0123",
                                "    1, 1, 1,",
                                "    -1, 1, 1,",
                                "    -1,-1, 1,",
                                "    1,-1, 1,",
                                "    // 0345",
                                "    1, 1, 1,",
                                "    1,-1, 1,",
                                "    1,-1,-1,",
                                "    1, 1,-1,",
                                "    // 0156",
                                "    1, 1, 1,",
                                "    1, 1, -1,",
                                "    -1, 1,-1,",
                                "    -1, 1,1,",
                                "    // 1267",
                                "    -1, 1, 1,",
                                "    -1,1, -1,",
                                "    -1, -1,-1,",
                                "    -1,-1,1,",
                                "    // 2347",
                                "    -1,-1, 1,",
                                "    1,-1, 1,",
                                "    1,-1,-1,",
                                "    -1,-1,-1,",
                                "    // 4567",
                                "    1,-1,-1,",
                                "    1, 1,-1,",
                                "    -1, 1,-1,",
                                "    -1,-1,-1,",
                                "  ])",
                                "",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "",
                                "  // 法向量",
                                "  const normals = new Float32Array([",
                                "    0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,",
                                "    0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,",
                                "    -1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,",
                                "    1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,",
                                "    0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,",
                                "    0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,",
                                "  ])",
                                "  const normalBuffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aNormal)",
                                "",
                                "  const indeces = new Uint8Array([",
                                "    0,1,2,0,2,3,",
                                "    4,5,6,4,6,7,",
                                "    8,9,10,8,10,11,",
                                "    12,13,14,12,14,15,",
                                "    16,17,18,16,18,19,",
                                "    20,21,22,20,22,23,",
                                "  ])",
                                "  const indexBuffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);",
                                "  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);",
                                "",
                                "  gl.enable(gl.BLEND);",
                                "",
                                "  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);",
                                "",
                                "  const vm = getViewMatrix(3,3,5,0.0,0.0,0.0,0.0,0.6,0.0);",
                                "  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);",
                                "",
                                "  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));",
                                "  gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);",
                                "  ",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}