{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "## 1. 初识webgl与canvas\r\n\r\n### 1.1 介绍canvas\r\n\r\n`<canvas></canvas>`  是HTML5新增的一个 DOM 元素\r\n用途：显示 二维 和 三维 的图像\r\n二维图形可以使用 （ Canvas API 或 WebGL API）绘制\r\n三维图形使用 WebGL API 绘制\r\n\r\ncanvas api绘图主要通过 `CanvasRenderingContext2D` 接口完成 `canvas.getContext('2d')`\r\n\r\n \r\nWebGL API绘图主要通过 `WebGLRenderingContext` 接口完成 `canvas.getContext('webgl')` 或 `canvas.getContext('webgl2')`\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 1.2 示例 清空画布\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "require(\"node-kernel\").display.html(/*html*/ `\n  <canvas id=\"canvas1\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n  </canvas>\n  <script>\n  {\n    const ctx = document.getElementById('canvas1')\n    const gl = ctx.getContext('webgl');\n    gl.clearColor(1.0,0.0,0.0,1.0); // red 1.0  green 0.0 blue 0.0 alpha 1.0\n gl.clear(gl.COLOR_BUFFER_BIT);\n }\n\n </script>\n`);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "  <canvas id=\"canvas1\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "  </canvas>",
                                "  <script>",
                                "  {",
                                "    const ctx = document.getElementById('canvas1')",
                                "    const gl = ctx.getContext('webgl');",
                                "    gl.clearColor(1.0,0.0,0.0,1.0); // red 1.0  green 0.0 blue 0.0 alpha 1.0",
                                " gl.clear(gl.COLOR_BUFFER_BIT);",
                                " }",
                                "",
                                " </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "gl.clearColor与gl.clear\r\n\r\n`gl.clearColor(r,g,b,a)` 指定清空 `<canvas>` 的颜⾊，接收四个参数（取值区间为 0.0~1.0）\r\n `gl.clear(buffer)`\r\n\r\nbuffer\r\n* `gl.COLOR_BUFFER_BIT` 清空颜色缓存 搭配`gl.clearColor(r,g,b,a)`使用\r\n* `gl.DEPTH_BUFFER_BIT` 清空深度缓冲区 搭配`gl.clearDepth(1.0)`使用\r\n* `gl.STENCIL_BUFFER_BIT` 清空模板缓冲区 搭配`gl.clearStencil(0)`使用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 1.3 示例 画一个点\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1:uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n    // 必须要存在 main 函数\n    void main() {\n        // 要绘制的点的坐标\n        gl_Position = vec4(0.0,0.0,0.0,1.0); // (x/w, y/w, z/w)\n        // 点的大小\n        gl_PointSize = 30.0;\n    }\n`.replace(/\\n/g, \"\\\\n\"); // 顶点着色器\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n    void main() {\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n`.replace(/\\n/g, \"\\\\n\"); // 片元着色器\n\nconst js = /*js*/ `\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    \n    gl.shaderSource(vertexShader, \"${VERTEX_SHADER_SOURCE}\") // 指定顶点着色器的源码\n    gl.shaderSource(fragmentShader, \"${FRAGMENT_SHADER_SOURCE}\") // 指定片元着色器的源码\n    \n    // 编译着色器\n    gl.compileShader(vertexShader)\n    gl.compileShader(fragmentShader)\n    \n    // 创建一个程序对象\n    const program = gl.createProgram();\n    \n    gl.attachShader(program, vertexShader)\n    gl.attachShader(program, fragmentShader)\n    \n    gl.linkProgram(program)\n    \n    gl.useProgram(program)\n\n    // 执行绘制\n\n    gl.drawArrays(gl.POINTS, 0, 1);\n`;\nconst html = /*html*/ `\n    <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n    </canvas>\n    <script>\n      { // 限制变量定义域\n        ${js}\n      }\n    </script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "    <canvas id=\"2635f090-a885-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "    </canvas>",
                                "    <script>",
                                "      { // 限制变量定义域",
                                "        ",
                                "    const ctx = document.getElementById('2635f090-a885-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "",
                                "    const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "    gl.shaderSource(vertexShader, \"\\n    // 必须要存在 main 函数\\n    void main() {\\n        // 要绘制的点的坐标\\n        gl_Position = vec4(0.0,0.0,0.0,1.0); // (x/w, y/w, z/w)\\n        // 点的大小\\n        gl_PointSize = 30.0;\\n    }\\n\") // 指定顶点着色器的源码",
                                "    gl.shaderSource(fragmentShader, \"\\n    void main() {\\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\") // 指定片元着色器的源码",
                                "    ",
                                "    // 编译着色器",
                                "    gl.compileShader(vertexShader)",
                                "    gl.compileShader(fragmentShader)",
                                "    ",
                                "    // 创建一个程序对象",
                                "    const program = gl.createProgram();",
                                "    ",
                                "    gl.attachShader(program, vertexShader)",
                                "    gl.attachShader(program, fragmentShader)",
                                "    ",
                                "    gl.linkProgram(program)",
                                "    ",
                                "    gl.useProgram(program)",
                                "",
                                "    // 执行绘制",
                                "",
                                "    gl.drawArrays(gl.POINTS, 0, 1);",
                                "",
                                "      }",
                                "    </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 1.4 canvas坐标系示意图\r\n\r\n![canvas坐标系示意图](image-9.png)\r\n\r\n### 1.5 webgl三维坐标系示意图\r\n\r\n![webgl三维坐标系示意图](image-10.png)\r\n\r\n### 1.6 右手坐标系\r\n\r\n![右手坐标系](image-12.png)\r\n\r\n### 1.7 webgl的绘图区域\r\n\r\n![绘图区域](image-11.png)\r\n\r\n关于旋转方向 如下图所示的方向规定为相对于该旋转轴的旋转正方向\r\n \r\n\r\n![关于旋转方向](image-13.png)\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 1.8 示例 画一个移动的点\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n  attribute vec4 aPosition;\n  void main() {\n    gl_Position = aPosition; \n    gl_PointSize = 30.0;\n  }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst js = /*js*/ `\n\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n    const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\");\n\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n\n    let x = 0;\n    setInterval(() => {\n      x+=0.1;\n      if(x>1.0) x=0;\n      gl.vertexAttrib1f(aPosition, x);\n      gl.drawArrays(gl.POINTS, 0, 1);\n    }, 200);\n`;\nconst html = /*html*/ `\n    <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n    </canvas>\n    <script>\n    function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {\n      const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    \n      gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE) // 指定顶点着色器的源码\n      gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE) // 指定片元着色器的源码\n    \n      // 编译着色器\n      gl.compileShader(vertexShader)\n      gl.compileShader(fragmentShader)\n    \n      // 创建一个程序对象\n      const program = gl.createProgram();\n    \n      gl.attachShader(program, vertexShader)\n      gl.attachShader(program, fragmentShader)\n    \n      gl.linkProgram(program)\n    \n      gl.useProgram(program)\n    \n      return program;\n    }\n    </script>\n    <script>\n      { // 限制变量定义域\n        ${js}\n      }\n    </script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "    <canvas id=\"31804270-a885-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "    </canvas>",
                                "    <script>",
                                "    function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {",
                                "      const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "      gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE) // 指定顶点着色器的源码",
                                "      gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE) // 指定片元着色器的源码",
                                "    ",
                                "      // 编译着色器",
                                "      gl.compileShader(vertexShader)",
                                "      gl.compileShader(fragmentShader)",
                                "    ",
                                "      // 创建一个程序对象",
                                "      const program = gl.createProgram();",
                                "    ",
                                "      gl.attachShader(program, vertexShader)",
                                "      gl.attachShader(program, fragmentShader)",
                                "    ",
                                "      gl.linkProgram(program)",
                                "    ",
                                "      gl.useProgram(program)",
                                "    ",
                                "      return program;",
                                "    }",
                                "    </script>",
                                "    <script>",
                                "      { // 限制变量定义域",
                                "        ",
                                "",
                                "    const ctx = document.getElementById('31804270-a885-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "    const program = initShader(gl, \"\\n  attribute vec4 aPosition;\\n  void main() {\\n    gl_Position = aPosition; \\n    gl_PointSize = 30.0;\\n  }\\n\", \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\");",
                                "",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "",
                                "    let x = 0;",
                                "    setInterval(() => {",
                                "      x+=0.1;",
                                "      if(x>1.0) x=0;",
                                "      gl.vertexAttrib1f(aPosition, x);",
                                "      gl.drawArrays(gl.POINTS, 0, 1);",
                                "    }, 200);",
                                "",
                                "      }",
                                "    </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "注意: attribute 变量只能在顶点着色器中使用，不能在片元着色器中使用\r\n\r\n `gl.vertexAttrib1f(location, v0)`\r\n\r\n `gl.vertexAttrib2f(location, v0, v1)`\r\n\r\n `gl.vertexAttrib3f(location, v0, v1, v2)`\r\n\r\n `gl.vertexAttrib4f(location, v0, v1, v2, v3)`\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 1.9 示例 通过鼠标点击绘制不同颜色的点\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n    uniform vec4 uPosition;\n    attribute vec4 aPosition;\n    void main() {\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n    gl_PointSize = 10.0;\n    }\n  `.replace(/\\n/g, \"\\\\n\"); // 顶点着色器\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n    precision mediump float;\n    uniform vec2 uColor;\n    void main() {\n    gl_FragColor = vec4(uColor.r, uColor.g, 0.0,1.0); // vec4\n    }\n  `.replace(/\\n/g, \"\\\\n\"); // 片元着色器\n\nconst js = /*js*/ `\n  const ctx = document.getElementById('${canvas_id}')\n\n  const gl = ctx.getContext('webgl')\n\n  const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\")\n\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const uColor = gl.getUniformLocation(program, 'uColor')\n\n  const points = []\n  ctx.onclick = function(ev) {\n    // 坐标\n    const x = ev.clientX\n    const y = ev.clientY\n\n    const domPosition = ev.target.getBoundingClientRect();\n\n    const domx = x - domPosition.left\n    const domy = y - domPosition.top;\n    const halfWidth = ctx.offsetWidth / 2\n    const halfHeight = ctx.offsetHeight / 2\n\n    const clickX = (domx - halfWidth) / halfWidth\n    const clickY = (halfHeight - domy) / halfHeight\n\n    points.push({\n    clickX, clickY\n    })\n\n    for (let i = 0; i < points.length; i++) {\n    gl.vertexAttrib2f(aPosition, points[i].clickX, points[i].clickY)\n    gl.uniform2f(uColor, points[i].clickX, points[i].clickY)\n    gl.drawArrays(gl.POINTS, 0, 1);\n    }\n  }\n  `;\nconst html = /*html*/ `\n  <style>\n    * {\n    margin: 0;\n    padding: 0;\n    }\n\n    canvas{\n    margin: 50px auto 0;\n    display: block;\n    background: yellow;\n    }\n  </style>\n  <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n  </canvas>\n  <script>\n    {\n      ${js}\n    }\n  </script>\n`;\ndisplay.html(html);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "  <style>",
                                "    * {",
                                "    margin: 0;",
                                "    padding: 0;",
                                "    }",
                                "",
                                "    canvas{",
                                "    margin: 50px auto 0;",
                                "    display: block;",
                                "    background: yellow;",
                                "    }",
                                "  </style>",
                                "  <canvas id=\"350c0140-a885-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "  </canvas>",
                                "  <script>",
                                "    {",
                                "      ",
                                "  const ctx = document.getElementById('350c0140-a885-11ee-b016-59e07913fb20')",
                                "",
                                "  const gl = ctx.getContext('webgl')",
                                "",
                                "  const program = initShader(gl, \"\\n    uniform vec4 uPosition;\\n    attribute vec4 aPosition;\\n    void main() {\\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n    gl_PointSize = 10.0;\\n    }\\n  \", \"\\n    precision mediump float;\\n    uniform vec2 uColor;\\n    void main() {\\n    gl_FragColor = vec4(uColor.r, uColor.g, 0.0,1.0); // vec4\\n    }\\n  \")",
                                "",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const uColor = gl.getUniformLocation(program, 'uColor')",
                                "",
                                "  const points = []",
                                "  ctx.onclick = function(ev) {",
                                "    // 坐标",
                                "    const x = ev.clientX",
                                "    const y = ev.clientY",
                                "",
                                "    const domPosition = ev.target.getBoundingClientRect();",
                                "",
                                "    const domx = x - domPosition.left",
                                "    const domy = y - domPosition.top;",
                                "    const halfWidth = ctx.offsetWidth / 2",
                                "    const halfHeight = ctx.offsetHeight / 2",
                                "",
                                "    const clickX = (domx - halfWidth) / halfWidth",
                                "    const clickY = (halfHeight - domy) / halfHeight",
                                "",
                                "    points.push({",
                                "    clickX, clickY",
                                "    })",
                                "",
                                "    for (let i = 0; i < points.length; i++) {",
                                "    gl.vertexAttrib2f(aPosition, points[i].clickX, points[i].clickY)",
                                "    gl.uniform2f(uColor, points[i].clickX, points[i].clickY)",
                                "    gl.drawArrays(gl.POINTS, 0, 1);",
                                "    }",
                                "  }",
                                "  ",
                                "    }",
                                "  </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                " `gl.uniform1f(location, v0)`\n\n `gl.uniform2f(location, v0, v1)`\n\n `gl.uniform3f(location, v0, v1, v2)`\n\n `gl.uniform4f(location, v0, v1, v2, v3)`\n\n参数介绍:\n\n    location: \n      指定 uniform变量的存储位置 \n    v0,v1,v2,v3：\n      传入的四个分量的值\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.0 示例 使用缓冲区绘制点\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "多缓冲区\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n  attribute vec4 aPosition;\n  attribute float aPointSize;\n  void main() {\n    gl_Position = aPosition;\n    gl_PointSize = aPointSize;\n  }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst js = /*js*/ `\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n\n    const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\");\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    const points = new Float32Array([\n      -0.5, -0.5,\n      0.5, -0.5,\n      0.0,  0.5,\n    ]);\n    const buffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  \n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  \n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  \n    gl.enableVertexAttribArray(aPosition);\n\n    const size = new Float32Array([\n      10.0, // 10.0\n      20.0, // 20.0\n      30.0, // 30.0\n    ]);\n\n    const sizeBuffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n  \n    gl.bufferData(gl.ARRAY_BUFFER, size, gl.STATIC_DRAW);\n  \n    gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, 0, 0);\n  \n    gl.enableVertexAttribArray(aPointSize);\n\n    \n    gl.drawArrays(gl.POINTS, 0, 3);\n`;\nconst html = /*html*/ `\n    <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n    </canvas>\n    <script>\n      { // 限制变量定义域\n        ${js}\n      }\n    </script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "    <canvas id=\"55ee9580-a885-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "    </canvas>",
                                "    <script>",
                                "      { // 限制变量定义域",
                                "        ",
                                "    const ctx = document.getElementById('55ee9580-a885-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "",
                                "    const program = initShader(gl, \"\\n  attribute vec4 aPosition;\\n  attribute float aPointSize;\\n  void main() {\\n    gl_Position = aPosition;\\n    gl_PointSize = aPointSize;\\n  }\\n\", \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\");",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const points = new Float32Array([",
                                "      -0.5, -0.5,",
                                "      0.5, -0.5,",
                                "      0.0,  0.5,",
                                "    ]);",
                                "    const buffer = gl.createBuffer();",
                                "",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPosition);",
                                "",
                                "    const size = new Float32Array([",
                                "      10.0, // 10.0",
                                "      20.0, // 20.0",
                                "      30.0, // 30.0",
                                "    ]);",
                                "",
                                "    const sizeBuffer = gl.createBuffer();",
                                "",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);",
                                "  ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, size, gl.STATIC_DRAW);",
                                "  ",
                                "    gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, 0, 0);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPointSize);",
                                "",
                                "    ",
                                "    gl.drawArrays(gl.POINTS, 0, 3);",
                                "",
                                "      }",
                                "    </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "数据偏移\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n  attribute vec4 aPosition;\n  attribute float aPointSize;\n  void main() {\n    gl_Position = aPosition;\n    gl_PointSize = aPointSize;\n  }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst js = /*js*/ `\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n\n    const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\");\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    const aPointSize = gl.getAttribLocation(program, 'aPointSize');\n  \n    const points = new Float32Array([\n    -0.5, -0.5, 10.0, // 10.0\n    0.5, -0.5, 20.0, // 20.0\n    0.0,  0.5, 30.0, // 30.0\n    ])\n  \n    const buffer = gl.createBuffer();\n  \n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  \n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  \n    const BYTES = points.BYTES_PER_ELEMENT;\n  \n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 3, 0);\n  \n    gl.enableVertexAttribArray(aPosition)\n  \n    gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, BYTES * 3, BYTES * 2);\n  \n    gl.enableVertexAttribArray(aPointSize)\n  \n    gl.drawArrays(gl.POINTS, 0, 3);\n`;\nconst html = /*html*/ `\n    <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n    </canvas>\n    <script>\n      { // 限制变量定义域\n        ${js}\n      }\n    </script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "    <canvas id=\"59292710-a885-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "    </canvas>",
                                "    <script>",
                                "      { // 限制变量定义域",
                                "        ",
                                "    const ctx = document.getElementById('59292710-a885-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "",
                                "    const program = initShader(gl, \"\\n  attribute vec4 aPosition;\\n  attribute float aPointSize;\\n  void main() {\\n    gl_Position = aPosition;\\n    gl_PointSize = aPointSize;\\n  }\\n\", \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\");",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const aPointSize = gl.getAttribLocation(program, 'aPointSize');",
                                "  ",
                                "    const points = new Float32Array([",
                                "    -0.5, -0.5, 10.0, // 10.0",
                                "    0.5, -0.5, 20.0, // 20.0",
                                "    0.0,  0.5, 30.0, // 30.0",
                                "    ])",
                                "  ",
                                "    const buffer = gl.createBuffer();",
                                "  ",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  ",
                                "    const BYTES = points.BYTES_PER_ELEMENT;",
                                "  ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 3, 0);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "  ",
                                "    gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, BYTES * 3, BYTES * 2);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPointSize)",
                                "  ",
                                "    gl.drawArrays(gl.POINTS, 0, 3);",
                                "",
                                "      }",
                                "    </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "缓冲区对象是WebGL系统中的一块内存区域，可以一次性地向缓冲区对象中填充大量的顶点数据，然后将这些数据保存在其中，供顶点着色器使用\r\n在 webgl 中，需要处理⼤量的相同类型数据，所以引入类型化数组，这样程序就可以预知到数组中的数据类型， 提⾼性能。\r\n\r\n类型化数组类型\r\n* Int8Array: 8位整型\r\n* UInt8Array: 8位无符号整型\r\n* Int16Array: 16位整型\r\n* UInt16Array:16位无符号整型\r\n* Int32Array:32位整型\r\n* UInt32Array:32位无符号整型\r\n* Float32Array: 单精度32位浮点型\r\n* Float64Array: 双精度64位浮点型\r\n\r\n#### 缓冲区对象相关的api\r\n\r\n`gl.createBuffer` 创建缓冲区对象\r\n\r\n`gl.bindBuffer(target, buffer)` 绑定缓冲区对象\r\n* buffer: 已经创建好的缓冲区对象\r\n* target：可以是如下两种 \r\n  + gl. ARRAY_BUFFER: 表示缓冲区存储的是顶点的数据\r\n  + gl. ELEMENT_ARRAY_BUFFER: 表示缓冲区存储的是顶点的索引值\r\n\r\n`gl.bufferData(target, data, type)` 写入数据到缓冲区\r\n* target: 类型同 gl.bindBuffer 中的 target\r\n* data: 写⼊缓冲区的顶点数据，如程序中的 points\r\n* type: 表示如何使⽤缓冲区对象中的数据，分为以下⼏类\r\n  + gl. STATIC_DRAW: 写⼊⼀次，多次绘制\r\n  + gl. STREAM_DRAW: 写⼊⼀次，绘制若干次\r\n  + gl. DYNAMIC_DRAW: 写⼊多次，绘制多次\r\n\r\n`gl.vertexAttribPointer(location, size, type, normalized, stride, offset)` 分配缓冲区对象给location这个attribute变量 并指定数据格式等细节\r\n* location: attribute 变量的存储位置\r\n* size: 指定每个顶点所使⽤数据的个数\r\n* type: 指定数据格式\r\n  + gl. FLOAT：浮点型\r\n  + gl. UNSIGNED_BYTE：⽆符号字节\r\n  + gl. SHORT：短整型\r\n  + gl. UNSIGNED_SHORT：无符号短整型\r\n  + gl. INT：整型\r\n  + gl. UNSIGNED_INT：无符号整型\r\n* normalized: 表示是否将数据归⼀化到 [0, 1] [-1, 1] 这个区间\r\n* stride：两个相邻顶点之间的字节数\r\n* offset：数据偏移量\r\n\r\n`gl.enableVertexAttribArray(location)` 启用attribute变量\r\n* location: attribute 变量的存储地址\r\n\r\n`gl.disableVertexAttribArray(aPosition)` 禁⽤attribute变量\r\n\r\n#### 缓冲区使用流程\r\n\r\n1. 创建顶点数据\r\n2. 创建缓冲区对象\r\n3. 绑定缓冲区对象\r\n4. 写入数据到缓冲区\r\n5. 分配缓冲区对象给一个attribute变量\r\n6. 启用这个attribute变量\r\n\r\n缓冲区执行过程\r\n\r\n![缓冲区执行过程](image-14.png)\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.1 画正方形\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n    attribute vec4 aPosition;\n    void main() {\n      gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n      gl_PointSize = 10.0;\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n    void main() {\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst js = /*js*/ `\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n\n    const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\");\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    const aPointSize = gl.getAttribLocation(program, 'aPointSize');\n  \n    const points = new Float32Array([\n      -0.5, -0.5,\n      0.5, -0.5,\n      -0.5,  0.5,\n      0.5,  0.5,\n    ])\n    \n    const buffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n\n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n\n    gl.enableVertexAttribArray(aPosition)\n    // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\n\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n`;\nconst html = /*html*/ `\n    <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n    </canvas>\n    <script>\n      { // 限制变量定义域\n        ${js}\n      }\n    </script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "    <canvas id=\"5c9c2dc0-a885-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "    </canvas>",
                                "    <script>",
                                "      { // 限制变量定义域",
                                "        ",
                                "    const ctx = document.getElementById('5c9c2dc0-a885-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "",
                                "    const program = initShader(gl, \"\\n    attribute vec4 aPosition;\\n    void main() {\\n      gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n      gl_PointSize = 10.0;\\n    }\\n\", \"\\n    void main() {\\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\");",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const aPointSize = gl.getAttribLocation(program, 'aPointSize');",
                                "  ",
                                "    const points = new Float32Array([",
                                "      -0.5, -0.5,",
                                "      0.5, -0.5,",
                                "      -0.5,  0.5,",
                                "      0.5,  0.5,",
                                "    ])",
                                "    ",
                                "    const buffer = gl.createBuffer();",
                                "",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "    // gl.vertexAttrib2f(aPosition, 0.0, 0.0)",
                                "",
                                "    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);",
                                "",
                                "      }",
                                "    </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "![gl. TRIANGLE_STRIP](image-15.png)\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.2 图形平移\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "平移矩阵的推导过程\n\n![矩阵平移](image-16.png)\n\n首先，定义平移变换的基本公式为：\n\n$ x' = x + x_1 $\n\n$ y' = y + y_1 $\n\n$ z' = z + z_1 $\n\n$ w = 1 $ \n\n这里 $ w $ 是齐次坐标的一部分，使得变换可以用矩阵乘法表示。\n\n接着，我们将这些变换映射到齐次坐标系中的矩阵变换中：\n\n$\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz \\\\\nw\n\\end{bmatrix}\n$ *\n$\n\\begin{bmatrix}\na & b & c & d \\\\\ne & f & g & h \\\\\ni & j & k & l \\\\\nm & n & o & p\n\\end{bmatrix}\n$ =\n$\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\nz' \\\\\nw'\n\\end{bmatrix}\n$\n\n$ ax + by + cz + dw = x' $\n\n$ ex + fy + gz + hw = y' $\n\n$ ix + jy + kz + lw = z' $\n\n$ mx + ny + oz + pw = w' $\n\n通过代入 $ x', y', z', w $ 的定义，我们可以解出矩阵的各个元素：\n\n1. 代入 $ x' = x + x_1 $ 到 $ ax + by + cz + dw = x' $ 得到 $ a = 1, b = 0, c = 0, d = x_1 $。\n2. 代入 $ y' = y + y_1 $ 到 $ ex + fy + gz + hw = y' $ 得到 $ e = 0, f = 1, g = 0, h = y_1 $。\n3. 代入 $ z' = z + z_1 $ 到 $ ix + jy + kz + lw = z' $ 得到 $ i = 0, j = 0, k = 1, l = z_1 $。\n4. 由于 $ w $ 始终为 1，所以 $ mx + ny + oz + pw = w' $ 得到 $ 0x + 0y + 0z + 1w = 1 $。\n\n因此，整个平移变换的齐次坐标矩阵是：\n\n$ \n\\begin{pmatrix}\n1 & 0 & 0 & x_1 \\\\\n0 & 1 & 0 & y_1 \\\\\n0 & 0 & 1 & z_1 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}\n$\n\n在数学中矩阵的表示是行主序的 就如上面得到的矩阵一样\n\n但是在webgl中因为一些历史问题需要换成列主序\n\n行主序换成列主序 具体做法是交换矩阵的行和列 即矩阵转置\n\n转置后的列主序矩阵如下\n\n$\n\\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\nx_1 & y_1 & z_1 & 1\n\\end{pmatrix}\n$\n\n转换成js代码如下\n\n```js\n    function getTranslateMatrix(x = 0, y = 0, z = 0) {\n      return new Float32Array([\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        x, y, z, 1,\n      ])\n    }\n```\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "平移矩阵的应用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n    attribute vec4 aPosition;\n    uniform mat4 mat;\n    void main() {\n      gl_Position = mat * aPosition;\n      gl_PointSize = 10.0;\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n    void main() {\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst js = /*js*/ `\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n\n    const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\");\n\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    const mat = gl.getUniformLocation(program, 'mat');\n  \n    const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    0.0,  0.5,\n    ])\n  \n    const buffer = gl.createBuffer();\n  \n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  \n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  \n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  \n    gl.enableVertexAttribArray(aPosition)\n  \n    let x = -1;\n    function animation() {\n    x += 0.01;\n    if (x > 1) {\n      x = -1;\n    }\n  \n    const matrix = getTranslateMatrix(x, x);\n    gl.uniformMatrix4fv(mat, false, matrix);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n  \n    requestAnimationFrame(animation);\n    }\n  \n    animation();\n`;\nconst html = /*html*/ `\n    <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n    </canvas>\n    <script>\n      // 平移矩阵\n      function getTranslateMatrix(x = 0,y = 0,z = 0) {\n        return new Float32Array([\n          1.0,0.0,0.0,0.0,\n          0.0,1.0,0.0,0.0,\n          0.0,0.0,1.0,0.0,\n            x,  y,  z,  1,\n        ])\n      } \n      { // 限制变量定义域\n        ${js}\n      }\n    </script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "    <canvas id=\"90a34fd0-a886-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "    </canvas>",
                                "    <script>",
                                "      // 平移矩阵",
                                "      function getTranslateMatrix(x = 0,y = 0,z = 0) {",
                                "        return new Float32Array([",
                                "          1.0,0.0,0.0,0.0,",
                                "          0.0,1.0,0.0,0.0,",
                                "          0.0,0.0,1.0,0.0,",
                                "            x,  y,  z,  1,",
                                "        ])",
                                "      } ",
                                "      { // 限制变量定义域",
                                "        ",
                                "    const ctx = document.getElementById('90a34fd0-a886-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "",
                                "    const program = initShader(gl, \"\\n    attribute vec4 aPosition;\\n    uniform mat4 mat;\\n    void main() {\\n      gl_Position = mat * aPosition;\\n      gl_PointSize = 10.0;\\n    }\\n\", \"\\n    void main() {\\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\");",
                                "",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const mat = gl.getUniformLocation(program, 'mat');",
                                "  ",
                                "    const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "    ])",
                                "  ",
                                "    const buffer = gl.createBuffer();",
                                "  ",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "  ",
                                "    let x = -1;",
                                "    function animation() {",
                                "    x += 0.01;",
                                "    if (x > 1) {",
                                "      x = -1;",
                                "    }",
                                "  ",
                                "    const matrix = getTranslateMatrix(x, x);",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "  ",
                                "    requestAnimationFrame(animation);",
                                "    }",
                                "  ",
                                "    animation();",
                                "",
                                "      }",
                                "    </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2.3 图形缩放\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "缩放矩阵推导过程\n\n![Alt text](image-19.png)\n\n首先，定义平移变换的基本公式为：\n\n$ x' = Tx * x $\n\n$ y' = Ty * y $\n\n$ z' = Tz * z $\n\n$ w = 1 $ \n\n这里 $ w $ 是齐次坐标的一部分，使得变换可以用矩阵乘法表示。\n\n接着，我们将这些变换映射到齐次坐标系中的矩阵变换中：\n\n$\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz \\\\\nw\n\\end{bmatrix}\n$ *\n$\n\\begin{bmatrix}\na & b & c & d \\\\\ne & f & g & h \\\\\ni & j & k & l \\\\\nm & n & o & p\n\\end{bmatrix}\n$ =\n$\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\nz' \\\\\nw'\n\\end{bmatrix}\n$           \n\n$ ax + by + cz + dw = x' $\n\n$ ex + fy + gz + hw = y' $\n\n$ ix + jy + kz + lw = z' $\n\n$ mx + ny + oz + pw = w' $\n\n通过代入 $ x', y', z', w $ 的定义，我们可以解出矩阵的各个元素：\n\n1. 代入 $ x' = Tx * x $ 到 $ ax + by + cz + dw = x' $ 得到 $ a = Tx, b = 0,  c = 0,  d = 0 $。\n2. 代入 $ y' = Ty * y $ 到 $ ex + fy + gz + hw = y' $ 得到 $ e = 0,  f = Ty, g = 0,  h = 0 $。\n3. 代入 $ z' = Tz * z $ 到 $ ix + jy + kz + lw = z' $ 得到 $ i = 0,  j = 0,  k = Tz, l = 0 $。\n4. 由于 $ w $ 始终为 1,  故 $ mx + ny + oz + pw = w' $ 得到 $ p = 1 $。\n\n因此，整个平移变换的齐次坐标矩阵是：\n\n$ \n\\begin{pmatrix}\nTx & 0 & 0 & x_1 \\\\\n0 & Ty & 0 & y_1 \\\\\n0 & 0 & Tz & z_1 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}\n$\n\n这是一个对称矩阵 列主序与行主序一致\n\n转换成js代码如下\n\n```js\nfunction getScaleMatrix(tx = 1, ty = 1, tz = 1) {\n    return new Float32Array([\n      tx, 0.0, 0.0, 0.0,\n      0.0, ty, 0.0, 0.0,\n      0.0, 0.0, tz, 0.0,\n      0.0, 0.0, 0.0, 1,\n    ])\n}\n```\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "缩放矩阵的应用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n    attribute vec4 aPosition;\n    uniform mat4 mat;\n    void main() {\n      gl_Position = mat * aPosition;\n      gl_PointSize = 10.0;\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n    void main() {\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst js = /*js*/ `\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n\n    const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\");\n\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    const mat = gl.getUniformLocation(program, 'mat');\n  \n    const points = new Float32Array([\n      -0.5, -0.5,\n      0.5, -0.5,\n      0.0,  0.5,\n    ])\n  \n    const buffer = gl.createBuffer();\n  \n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  \n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  \n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  \n    gl.enableVertexAttribArray(aPosition)\n  \n    let x = 0.1;\n    function animation() {\n    x += 0.01;\n    if (x > 1.5) {\n      x = 0.1;\n    }\n  \n    const matrix = getScaleMatrix(x, x);\n    // 参数 location transpose array\n    gl.uniformMatrix4fv(mat, false, matrix);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n  \n    requestAnimationFrame(animation);\n    }\n  \n    animation();\n`;\nconst html = /*html*/ `\n    <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n    </canvas>\n    <script>\n      // 缩放矩阵\n      function getScaleMatrix(tx = 1, ty = 1, tz = 1) {\n        return new Float32Array([\n          tx, 0.0, 0.0, 0.0,\n          0.0, ty, 0.0, 0.0,\n          0.0, 0.0, tz, 0.0,\n          0.0, 0.0, 0.0, 1,\n        ])\n      }\n      { // 限制变量定义域\n        ${js}\n      }\n    </script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "    <canvas id=\"946bc980-a886-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "    </canvas>",
                                "    <script>",
                                "      // 缩放矩阵",
                                "      function getScaleMatrix(tx = 1, ty = 1, tz = 1) {",
                                "        return new Float32Array([",
                                "          tx, 0.0, 0.0, 0.0,",
                                "          0.0, ty, 0.0, 0.0,",
                                "          0.0, 0.0, tz, 0.0,",
                                "          0.0, 0.0, 0.0, 1,",
                                "        ])",
                                "      }",
                                "      { // 限制变量定义域",
                                "        ",
                                "    const ctx = document.getElementById('946bc980-a886-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "",
                                "    const program = initShader(gl, \"\\n    attribute vec4 aPosition;\\n    uniform mat4 mat;\\n    void main() {\\n      gl_Position = mat * aPosition;\\n      gl_PointSize = 10.0;\\n    }\\n\", \"\\n    void main() {\\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\");",
                                "",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const mat = gl.getUniformLocation(program, 'mat');",
                                "  ",
                                "    const points = new Float32Array([",
                                "      -0.5, -0.5,",
                                "      0.5, -0.5,",
                                "      0.0,  0.5,",
                                "    ])",
                                "  ",
                                "    const buffer = gl.createBuffer();",
                                "  ",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "  ",
                                "    let x = 0.1;",
                                "    function animation() {",
                                "    x += 0.01;",
                                "    if (x > 1.5) {",
                                "      x = 0.1;",
                                "    }",
                                "  ",
                                "    const matrix = getScaleMatrix(x, x);",
                                "    // 参数 location transpose array",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "  ",
                                "    requestAnimationFrame(animation);",
                                "    }",
                                "  ",
                                "    animation();",
                                "",
                                "      }",
                                "    </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "旋转矩阵的推导过程\r\n\r\n![Alt text](image-20.png)\r\n\r\n顶点A (x, y)\r\n\r\n$ x = R * cos(α) $\r\n\r\n$ y = R * sin(α) $\r\n\r\n$ z = 0 $\r\n\r\n顶点A' (x', y')\r\n\r\n$$\r\n\\begin{align*}\r\n&x' = R * \\cos(α + β) \\\\\r\n&\\phantom{x'} = R * ( \\cos(α)*\\cos(β) - \\sin(α)*\\sin(β)) \\\\\r\n&\\phantom{x'} = R*\\cos(α)*\\cos(β) - R*\\sin(α)*\\sin(β)\r\n\\end{align*}\r\n$$\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "旋转矩阵的应用"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n    attribute vec4 aPosition;\n    uniform mat4 mat;\n    void main() {\n        gl_Position = mat * aPosition;\n        gl_PointSize = 10.0;\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n    void main() {\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst js = /*js*/ `\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n\n    const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\");\n\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    const mat = gl.getUniformLocation(program, 'mat');\n\n    const points = new Float32Array([\n        -0.5, -0.5,\n        0.5, -0.5,\n        0.0,  0.5,\n    ])\n    \n    const buffer = gl.createBuffer();\n    \n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    \n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n    \n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n    \n    gl.enableVertexAttribArray(aPosition)\n    \n    let x = 0;\n    function animation() {\n        x += 0.01;\n    \n        const matrix = getRotateMatrix(x);\n        // gl.vertexAttrib1f(aTranslate, x);\n        gl.uniformMatrix4fv(mat, false, matrix);\n        gl.drawArrays(gl.TRIANGLES, 0, 3);\n    \n        requestAnimationFrame(animation);\n    }\n    \n    animation()\n    \n`;\nconst html = /*html*/ `\n    <canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n    </canvas>\n    <script>\n        // 绕z轴旋转的旋转矩阵\n        function getRotateMatrix(deg) {\n            return new Float32Array([\n            Math.cos(deg)  ,Math.sin(deg) ,0.0,0.0,\n            -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,\n            0.0,            0.0,            1.0,0.0,\n            0.0,            0.0,            0.0, 1,\n            ])\n        }\n        { // 限制变量定义域\n            ${js}\n        }\n    </script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "    <canvas id=\"97ae7160-a886-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "    </canvas>",
                                "    <script>",
                                "        // 绕z轴旋转的旋转矩阵",
                                "        function getRotateMatrix(deg) {",
                                "            return new Float32Array([",
                                "            Math.cos(deg)  ,Math.sin(deg) ,0.0,0.0,",
                                "            -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "            0.0,            0.0,            1.0,0.0,",
                                "            0.0,            0.0,            0.0, 1,",
                                "            ])",
                                "        }",
                                "        { // 限制变量定义域",
                                "            ",
                                "    const ctx = document.getElementById('97ae7160-a886-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "",
                                "    const program = initShader(gl, \"\\n    attribute vec4 aPosition;\\n    uniform mat4 mat;\\n    void main() {\\n        gl_Position = mat * aPosition;\\n        gl_PointSize = 10.0;\\n    }\\n\", \"\\n    void main() {\\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\");",
                                "",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const mat = gl.getUniformLocation(program, 'mat');",
                                "",
                                "    const points = new Float32Array([",
                                "        -0.5, -0.5,",
                                "        0.5, -0.5,",
                                "        0.0,  0.5,",
                                "    ])",
                                "    ",
                                "    const buffer = gl.createBuffer();",
                                "    ",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "    ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "    ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "    ",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "    ",
                                "    let x = 0;",
                                "    function animation() {",
                                "        x += 0.01;",
                                "    ",
                                "        const matrix = getRotateMatrix(x);",
                                "        // gl.vertexAttrib1f(aTranslate, x);",
                                "        gl.uniformMatrix4fv(mat, false, matrix);",
                                "        gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "    ",
                                "        requestAnimationFrame(animation);",
                                "    }",
                                "    ",
                                "    animation()",
                                "    ",
                                "",
                                "        }",
                                "    </script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "矩阵复合\n\n矩阵A * 矩阵B 表示先进行B变换再进行A变换\n\n![矩阵乘法](image-21.png)\n\n```js\n// 矩阵复合函数\nfunction mixMatrix(A, B) {\n  const result = new Float32Array(16);\n\n  for (let i = 0; i < 4; i++) {\n    result[i] = A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3]\n    result[i + 4] = A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7]\n    result[i + 8] = A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11]\n    result[i + 12] = A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15]\n  }\n\n  return result;\n}\n```"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const { display } = require(\"node-kernel\");\nconst { v1: uuidv1 } = require(\"uuid\");\nconst canvas_id = uuidv1();\n// 着色器\n// 创建着色器源码\nconst VERTEX_SHADER_SOURCE = /*glsl */ `\n    attribute vec4 aPosition;\n    uniform mat4 mat;\n    void main() {\n    gl_Position = mat * aPosition;\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst FRAGMENT_SHADER_SOURCE = /*glsl */ `\n    void main() {\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n`.replace(/\\n/g, \"\\\\n\");\n\nconst js = /*js*/ `\n\n    function mixMatrix(A, B) {\n        const result = new Float32Array(16);\n    \n        for (let i = 0; i < 4; i++) {\n        result[i] = A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3]\n        result[i + 4] = A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7]\n        result[i + 8] = A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11]\n        result[i + 12] = A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15]\n        }\n    \n        return result;\n    }\n\n    const ctx = document.getElementById('${canvas_id}');\n    const gl = ctx.getContext('webgl');\n\n    const program = initShader(gl, \"${VERTEX_SHADER_SOURCE}\", \"${FRAGMENT_SHADER_SOURCE}\");\n\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    const mat = gl.getUniformLocation(program, 'mat');\n    const points = new Float32Array([\n        -0.5, -0.5,\n        0.5, -0.5,\n        0.0,  0.5,\n    ])\n    \n    const buffer = gl.createBuffer();\n    \n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    \n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n    \n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n    \n    gl.enableVertexAttribArray(aPosition)\n    \n    let deg = 0;\n    let translateX = -1;\n    let scaleX = 0.1;\n    function animation() {\n        deg += 0.01;\n        translateX += 0.01;\n        scaleX += 0.01;\n        \n        if (translateX > 1) {\n            translateX = -1;\n        }\n        \n        if (scaleX > 1.5) {\n            scaleX = 0.1;\n        }\n        \n        const translate = getTranslateMatrix(translateX);\n        const scale = getScaleMatrix(scaleX);\n        const rotate = getRotateMatrix(deg);\n        \n        const matrix = mixMatrix(mixMatrix(translate, scale), rotate);\n        gl.uniformMatrix4fv(mat, false, matrix);\n        gl.drawArrays(gl.TRIANGLES, 0, 3);\n        \n        requestAnimationFrame(animation);\n    }\n    \n    animation()\n`;\nconst html = /*html*/ `\n<canvas id=\"${canvas_id}\" width=\"400\" height=\"400\">\n    此浏览器不支持canvas\n</canvas>\n<script>\n    { // 限制变量定义域\n        ${js}\n    }\n</script>\n`;\ndisplay.html(html);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "<canvas id=\"b6b085d0-a886-11ee-b016-59e07913fb20\" width=\"400\" height=\"400\">",
                                "    此浏览器不支持canvas",
                                "</canvas>",
                                "<script>",
                                "    { // 限制变量定义域",
                                "        ",
                                "",
                                "    function mixMatrix(A, B) {",
                                "        const result = new Float32Array(16);",
                                "    ",
                                "        for (let i = 0; i < 4; i++) {",
                                "        result[i] = A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3]",
                                "        result[i + 4] = A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7]",
                                "        result[i + 8] = A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11]",
                                "        result[i + 12] = A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15]",
                                "        }",
                                "    ",
                                "        return result;",
                                "    }",
                                "",
                                "    const ctx = document.getElementById('b6b085d0-a886-11ee-b016-59e07913fb20');",
                                "    const gl = ctx.getContext('webgl');",
                                "",
                                "    const program = initShader(gl, \"\\n    attribute vec4 aPosition;\\n    uniform mat4 mat;\\n    void main() {\\n    gl_Position = mat * aPosition;\\n    }\\n\", \"\\n    void main() {\\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\");",
                                "",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const mat = gl.getUniformLocation(program, 'mat');",
                                "    const points = new Float32Array([",
                                "        -0.5, -0.5,",
                                "        0.5, -0.5,",
                                "        0.0,  0.5,",
                                "    ])",
                                "    ",
                                "    const buffer = gl.createBuffer();",
                                "    ",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "    ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "    ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "    ",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "    ",
                                "    let deg = 0;",
                                "    let translateX = -1;",
                                "    let scaleX = 0.1;",
                                "    function animation() {",
                                "        deg += 0.01;",
                                "        translateX += 0.01;",
                                "        scaleX += 0.01;",
                                "        ",
                                "        if (translateX > 1) {",
                                "            translateX = -1;",
                                "        }",
                                "        ",
                                "        if (scaleX > 1.5) {",
                                "            scaleX = 0.1;",
                                "        }",
                                "        ",
                                "        const translate = getTranslateMatrix(translateX);",
                                "        const scale = getScaleMatrix(scaleX);",
                                "        const rotate = getRotateMatrix(deg);",
                                "        ",
                                "        // const matrix = mixMatrix(mixMatrix(translate, scale), rotate);",
                                "        // const matrix = mixMatrix(translate, scale);",
                                "        const matrix = mixMatrix(scale, translate);",
                                "        gl.uniformMatrix4fv(mat, false, matrix);",
                                "        gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "        ",
                                "        requestAnimationFrame(animation);",
                                "    }",
                                "    ",
                                "    animation()",
                                "",
                                "    }",
                                "</script>",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}