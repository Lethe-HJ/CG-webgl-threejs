{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "## 1. 初识 webgl 与 canvas\r\n\r\n### 1.1 介绍 canvas\r\n\r\n`<canvas></canvas>`   是 HTML5 新增的一个 DOM 元素\r\n用途：显示 二维 和 三维 的图像\r\n二维图形可以使用 （ Canvas API 或 WebGL API）绘制\r\n三维图形使用 WebGL API 绘制\r\n\r\ncanvas api 绘图主要通过 `CanvasRenderingContext2D` 接口完成 `canvas.getContext('2d')`\r\n\r\nWebGL API 绘图主要通过 `WebGLRenderingContext` 接口完成 `canvas.getContext('webgl')` 或 `canvas.getContext('webgl2')`\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "gl.clearColor 与 gl.clear\r\n\r\n`gl.clearColor(r,g,b,a)` 指定清空 `<canvas>` 的颜⾊，接收四个参数（取值区间为 0.0~1.0）\r\n`gl.clear(buffer)`\r\n\r\nbuffer\r\n\r\n- `gl.COLOR_BUFFER_BIT` 清空颜色缓存 搭配`gl.clearColor(r,g,b,a)`使用\r\n- `gl.DEPTH_BUFFER_BIT` 清空深度缓冲区 搭配`gl.clearDepth(1.0)`使用\r\n- `gl.STENCIL_BUFFER_BIT` 清空模板缓冲区 搭配`gl.clearStencil(0)`使用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 1.3 示例 画一个点\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vextex = /*glsl */ `\r\n  // 必须要存在 main 函数\r\n  void main() {\r\n    // 要绘制的点的坐标\r\n    gl_Position = vec4(0.0,0.0,0.0,1.0); // (x/w, y/w, z/w)\r\n    // 点的大小\r\n    gl_PointSize = 30.0;\r\n  }\r\n`; // 顶点着色器\r\n\r\nconst fragment = /*glsl */ `\r\n  void main() {\r\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n  }\r\n`; // 片元着色器\r\n\r\nconst js_code = /*js*/ `\r\n    gl.attachShader(program, vertexShader)\r\n    gl.attachShader(program, fragmentShader)\r\n    gl.linkProgram(program)\r\n    gl.useProgram(program)\r\n    gl.drawArrays(gl.POINTS, 0, 1);\r\n`;\r\nconst { renderWebgl } = require(\"../../src/display.js\");\r\nrenderWebgl(vertex_code, fragment_code, js_code);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"ac814f80-b15b-11ee-9ab2-1397e8fc942a\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('ac814f80-b15b-11ee-9ab2-1397e8fc942a');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    uniform vec4 uPosition;\\n    attribute vec4 aPosition;\\n    void main() {\\n        gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n        gl_PointSize = 10.0;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    precision mediump float;\\n    uniform vec2 uColor;\\n    void main() {\\n        gl_FragColor = vec4(uColor.r, uColor.g, 0.0,1.0); // vec4\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    gl.attachShader(program, vertexShader)",
                                "    gl.attachShader(program, fragmentShader)",
                                "    gl.linkProgram(program)",
                                "    gl.useProgram(program)",
                                "    gl.drawArrays(gl.POINTS, 0, 1);",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 1.4 canvas 坐标系示意图\r\n\r\n![canvas坐标系示意图](image-9.png)\r\n\r\n### 1.5 webgl 三维坐标系示意图\r\n\r\n![webgl三维坐标系示意图](image-10.png)\r\n\r\n### 1.6 右手坐标系\r\n\r\n![右手坐标系](image-12.png)\r\n\r\n### 1.7 webgl 的绘图区域\r\n\r\n![绘图区域](image-11.png)\r\n\r\n关于旋转方向 如下图所示的方向规定为相对于该旋转轴的旋转正方向\r\n\r\n![关于旋转方向](image-13.png)\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 1.8 示例 画一个移动的点\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  void main() {\n    gl_Position = aPosition; \n    gl_PointSize = 30.0;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`;\n\nconst js_code = /*js*/ `\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    let x = 0;\n    setInterval(() => {\n        x+=0.1;\n        if(x>1.0) x=0;\n        gl.vertexAttrib1f(aPosition, x);\n        gl.drawArrays(gl.POINTS, 0, 1);\n    }, 200);\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"2e51b4c0-b10a-11ee-89c2-59d78a86c420\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('2e51b4c0-b10a-11ee-89c2-59d78a86c420');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    void main() {\\n        gl_Position = aPosition; \\n        gl_PointSize = 30.0;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    void main() {\\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "",
                                "    let x = 0;",
                                "    setInterval(() => {",
                                "        x+=0.1;",
                                "        if(x>1.0) x=0;",
                                "        gl.vertexAttrib1f(aPosition, x);",
                                "        gl.drawArrays(gl.POINTS, 0, 1);",
                                "    }, 200);",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "注意: attribute 变量只能在顶点着色器中使用，不能在片元着色器中使用\r\n\r\n`gl.vertexAttrib1f(location, v0)`\r\n\r\n`gl.vertexAttrib2f(location, v0, v1)`\r\n\r\n`gl.vertexAttrib3f(location, v0, v1, v2)`\r\n\r\n`gl.vertexAttrib4f(location, v0, v1, v2, v3)`\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 1.9 示例 通过鼠标点击绘制不同颜色的点\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  uniform vec4 uPosition;\n  attribute vec4 aPosition;\n  void main() {\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n    gl_PointSize = 10.0;\n  }\n`; // 顶点着色器\n\nconst fragment_code = /*glsl */ `\n  precision mediump float;\n  uniform vec2 uColor;\n  void main() {\n    gl_FragColor = vec4(uColor.r, uColor.g, 0.0,1.0); // vec4\n  }\n`; // 片元着色器\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const uColor = gl.getUniformLocation(program, 'uColor')\n  const points = []\n  ctx.onclick = function(ev) {\n    const x = ev.clientX\n    const y = ev.clientY\n    const domPosition = ev.target.getBoundingClientRect();\n    const domx = x - domPosition.left\n    const domy = y - domPosition.top;\n    const halfWidth = ctx.offsetWidth / 2\n    const halfHeight = ctx.offsetHeight / 2\n    const clickX = (domx - halfWidth) / halfWidth\n    const clickY = (halfHeight - domy) / halfHeight\n    points.push({ clickX, clickY });\n    for (let i = 0; i < points.length; i++) {\n      gl.vertexAttrib2f(aPosition, points[i].clickX, points[i].clickY)\n      gl.uniform2f(uColor, points[i].clickX, points[i].clickY)\n      gl.drawArrays(gl.POINTS, 0, 1);\n    }\n  }\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"4063d9d0-b15b-11ee-9ab2-1397e8fc942a\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('4063d9d0-b15b-11ee-9ab2-1397e8fc942a');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    uniform vec4 uPosition;\\n    attribute vec4 aPosition;\\n    void main() {\\n        gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n        gl_PointSize = 10.0;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    precision mediump float;\\n    uniform vec2 uColor;\\n    void main() {\\n        gl_FragColor = vec4(uColor.r, uColor.g, 0.0,1.0); // vec4\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const uColor = gl.getUniformLocation(program, 'uColor')",
                                "",
                                "    const points = []",
                                "    ctx.onclick = function(ev) {",
                                "      // 坐标",
                                "      const x = ev.clientX",
                                "      const y = ev.clientY",
                                "",
                                "      const domPosition = ev.target.getBoundingClientRect();",
                                "",
                                "      const domx = x - domPosition.left",
                                "      const domy = y - domPosition.top;",
                                "      const halfWidth = ctx.offsetWidth / 2",
                                "      const halfHeight = ctx.offsetHeight / 2",
                                "",
                                "      const clickX = (domx - halfWidth) / halfWidth",
                                "      const clickY = (halfHeight - domy) / halfHeight",
                                "",
                                "      points.push({",
                                "          clickX, clickY",
                                "      })",
                                "",
                                "      for (let i = 0; i < points.length; i++) {",
                                "          gl.vertexAttrib2f(aPosition, points[i].clickX, points[i].clickY)",
                                "          gl.uniform2f(uColor, points[i].clickX, points[i].clickY)",
                                "          gl.drawArrays(gl.POINTS, 0, 1);",
                                "      }",
                                "    }",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "`gl.uniform1f(location, v0)`\r\n\r\n`gl.uniform2f(location, v0, v1)`\r\n\r\n`gl.uniform3f(location, v0, v1, v2)`\r\n\r\n`gl.uniform4f(location, v0, v1, v2, v3)`\r\n\r\n参数介绍:\r\n\r\n    location:\r\n      指定 uniform变量的存储位置\r\n    v0,v1,v2,v3：\r\n      传入的四个分量的值\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.0 示例 使用缓冲区绘制点\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "多缓冲区\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  attribute float aPointSize;\n  void main() {\n    gl_Position = aPosition;\n    gl_PointSize = aPointSize;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const aPointSize = gl.getAttribLocation(program, 'aPointSize');\n  const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    0.0,  0.5,\n  ]);\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition);\n  const size = new Float32Array([\n    10.0, // 10.0\n    20.0, // 20.0\n    30.0, // 30.0\n  ]);\n  const sizeBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, size, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPointSize);\n  gl.drawArrays(gl.POINTS, 0, 3);\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"3841a6c0-b10a-11ee-89c2-59d78a86c420\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('3841a6c0-b10a-11ee-89c2-59d78a86c420');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    attribute float aPointSize;\\n    void main() {\\n        gl_Position = aPosition;\\n        gl_PointSize = aPointSize;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    void main() {\\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const aPointSize = gl.getAttribLocation(program, 'aPointSize');",
                                "    const points = new Float32Array([",
                                "      -0.5, -0.5,",
                                "      0.5, -0.5,",
                                "      0.0,  0.5,",
                                "    ]);",
                                "    const buffer = gl.createBuffer();",
                                "",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPosition);",
                                "",
                                "    const size = new Float32Array([",
                                "      10.0, // 10.0",
                                "      20.0, // 20.0",
                                "      30.0, // 30.0",
                                "    ]);",
                                "",
                                "    const sizeBuffer = gl.createBuffer();",
                                "",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);",
                                "  ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, size, gl.STATIC_DRAW);",
                                "  ",
                                "    gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, 0, 0);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPointSize);",
                                "",
                                "    ",
                                "    gl.drawArrays(gl.POINTS, 0, 3);",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "数据偏移\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  attribute float aPointSize;\n  void main() {\n    gl_Position = aPosition;\n    gl_PointSize = aPointSize;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const aPointSize = gl.getAttribLocation(program, 'aPointSize');\n  const points = new Float32Array([\n    -0.5, -0.5, 10.0, // 10.0\n    0.5, -0.5, 20.0, // 20.0\n    0.0,  0.5, 30.0, // 30.0\n  ]);\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  const BYTES = points.BYTES_PER_ELEMENT;\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 3, 0);\n  gl.enableVertexAttribArray(aPosition)\n  gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, BYTES * 3, BYTES * 2);\n  gl.enableVertexAttribArray(aPointSize)\n  gl.drawArrays(gl.POINTS, 0, 3);\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"3b049750-b10a-11ee-89c2-59d78a86c420\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('3b049750-b10a-11ee-89c2-59d78a86c420');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    attribute float aPointSize;\\n    void main() {\\n        gl_Position = aPosition;\\n        gl_PointSize = aPointSize;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    void main() {\\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const aPointSize = gl.getAttribLocation(program, 'aPointSize');",
                                "  ",
                                "    const points = new Float32Array([",
                                "    -0.5, -0.5, 10.0, // 10.0",
                                "    0.5, -0.5, 20.0, // 20.0",
                                "    0.0,  0.5, 30.0, // 30.0",
                                "    ])",
                                "  ",
                                "    const buffer = gl.createBuffer();",
                                "  ",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  ",
                                "    const BYTES = points.BYTES_PER_ELEMENT;",
                                "  ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 3, 0);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "  ",
                                "    gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, BYTES * 3, BYTES * 2);",
                                "  ",
                                "    gl.enableVertexAttribArray(aPointSize)",
                                "  ",
                                "    gl.drawArrays(gl.POINTS, 0, 3);",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "缓冲区对象是 WebGL 系统中的一块内存区域，可以一次性地向缓冲区对象中填充大量的顶点数据，然后将这些数据保存在其中，供顶点着色器使用\r\n在 webgl 中，需要处理⼤量的相同类型数据，所以引入类型化数组，这样程序就可以预知到数组中的数据类型， 提⾼性能。\r\n\r\n类型化数组类型\r\n\r\n- Int8Array: 8 位整型\r\n- UInt8Array: 8 位无符号整型\r\n- Int16Array: 16 位整型\r\n- UInt16Array:16 位无符号整型\r\n- Int32Array:32 位整型\r\n- UInt32Array:32 位无符号整型\r\n- Float32Array: 单精度 32 位浮点型\r\n- Float64Array: 双精度 64 位浮点型\r\n\r\n#### 缓冲区对象相关的 api\r\n\r\n`gl.createBuffer` 创建缓冲区对象\r\n\r\n`gl.bindBuffer(target, buffer)` 绑定缓冲区对象\r\n\r\n- buffer: 已经创建好的缓冲区对象\r\n- target：可以是如下两种\r\n  - gl. ARRAY_BUFFER: 表示缓冲区存储的是顶点的数据\r\n  - gl. ELEMENT_ARRAY_BUFFER: 表示缓冲区存储的是顶点的索引值\r\n\r\n`gl.bufferData(target, data, type)` 写入数据到缓冲区\r\n\r\n- target: 类型同 gl.bindBuffer 中的 target\r\n- data: 写⼊缓冲区的顶点数据，如程序中的 points\r\n- type: 表示如何使⽤缓冲区对象中的数据，分为以下⼏类\r\n  - gl. STATIC_DRAW: 写⼊⼀次，多次绘制\r\n  - gl. STREAM_DRAW: 写⼊⼀次，绘制若干次\r\n  - gl. DYNAMIC_DRAW: 写⼊多次，绘制多次\r\n\r\n`gl.vertexAttribPointer(location, size, type, normalized, stride, offset)` 分配缓冲区对象给 location 这个 attribute 变量 并指定数据格式等细节\r\n\r\n- location: attribute 变量的存储位置\r\n- size: 指定每个顶点所使⽤数据的个数\r\n- type: 指定数据格式\r\n  - gl. FLOAT：浮点型\r\n  - gl. UNSIGNED_BYTE：⽆符号字节\r\n  - gl. SHORT：短整型\r\n  - gl. UNSIGNED_SHORT：无符号短整型\r\n  - gl. INT：整型\r\n  - gl. UNSIGNED_INT：无符号整型\r\n- normalized: 表示是否将数据归⼀化到 [0, 1] [-1, 1] 这个区间\r\n- stride：两个相邻顶点之间的字节数\r\n- offset：数据偏移量\r\n\r\n`gl.enableVertexAttribArray(location)` 启用 attribute 变量\r\n\r\n- location: attribute 变量的存储地址\r\n\r\n`gl.disableVertexAttribArray(aPosition)` 禁⽤ attribute 变量\r\n\r\n#### 缓冲区使用流程\r\n\r\n1. 创建顶点数据\r\n2. 创建缓冲区对象\r\n3. 绑定缓冲区对象\r\n4. 写入数据到缓冲区\r\n5. 分配缓冲区对象给一个 attribute 变量\r\n6. 启用这个 attribute 变量\r\n\r\n缓冲区执行过程\r\n\r\n![缓冲区执行过程](image-14.png)\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.1 画正方形\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  void main() {\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n    gl_PointSize = 10.0;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const aPointSize = gl.getAttribLocation(program, 'aPointSize');\n  const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    -0.5,  0.5,\n    0.5,  0.5,\n  ]);\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition)\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\n  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"3ea7d5c0-b10a-11ee-89c2-59d78a86c420\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('3ea7d5c0-b10a-11ee-89c2-59d78a86c420');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    void main() {\\n      gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n      gl_PointSize = 10.0;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    void main() {\\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const aPointSize = gl.getAttribLocation(program, 'aPointSize');",
                                "  ",
                                "    const points = new Float32Array([",
                                "      -0.5, -0.5,",
                                "      0.5, -0.5,",
                                "      -0.5,  0.5,",
                                "      0.5,  0.5,",
                                "    ])",
                                "    ",
                                "    const buffer = gl.createBuffer();",
                                "",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "    // gl.vertexAttrib2f(aPosition, 0.0, 0.0)",
                                "",
                                "    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "三种不同三角形图元\r\n\r\n![gl. TRIANGLE_STRIP](image-15.png)\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.2 图形平移\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "平移矩阵的推导过程\r\n\r\n![矩阵平移](image-16.png)\r\n\r\n首先，定义平移变换的基本公式为：\r\n\r\n$ x' = x + x_1 $\r\n\r\n$ y' = y + y_1 $\r\n\r\n$ z' = z + z_1 $\r\n\r\n$ w = 1 $\r\n\r\n这里 $ w $ 是齐次坐标的一部分，使得变换可以用矩阵乘法表示。\r\n\r\n接着，我们将这些变换映射到齐次坐标系中的矩阵变换中：\r\n\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz \\\\\r\nw\r\n\\end{bmatrix}\r\n$ *\r\n$\r\n\\begin{bmatrix}\r\na & b & c & d \\\\\r\ne & f & g & h \\\\\r\ni & j & k & l \\\\\r\nm & n & o & p\r\n\\end{bmatrix}\r\n$ =\r\n$\r\n\\begin{bmatrix}\r\nx' \\\\\r\ny' \\\\\r\nz' \\\\\r\nw'\r\n\\end{bmatrix}\r\n$\r\n\r\n$ ax + by + cz + dw = x' $\r\n\r\n$ ex + fy + gz + hw = y' $\r\n\r\n$ ix + jy + kz + lw = z' $\r\n\r\n$ mx + ny + oz + pw = w' $\r\n\r\n通过代入 $ x', y', z', w $ 的定义，我们可以解出矩阵的各个元素：\r\n\r\n1. 代入 $ x' = x + x_1 $ 到 $ ax + by + cz + dw = x' $ 得到 $ a = 1, b = 0, c = 0, d = x_1 $。\r\n2. 代入 $ y' = y + y_1 $ 到 $ ex + fy + gz + hw = y' $ 得到 $ e = 0, f = 1, g = 0, h = y_1 $。\r\n3. 代入 $ z' = z + z_1 $ 到 $ ix + jy + kz + lw = z' $ 得到 $ i = 0, j = 0, k = 1, l = z_1 $。\r\n4. 由于 $ w $ 始终为 1，所以 $ mx + ny + oz + pw = w' $ 得到 $ 0x + 0y + 0z + 1w = 1 $。\r\n\r\n因此，整个平移变换的齐次坐标矩阵是：\r\n\r\n$\r\n\\begin{pmatrix}\r\n1 & 0 & 0 & x_1 \\\\\r\n0 & 1 & 0 & y_1 \\\\\r\n0 & 0 & 1 & z_1 \\\\\r\n0 & 0 & 0 & 1\r\n\\end{pmatrix}\r\n$\r\n\r\n在数学中矩阵的表示是行主序的 就如上面得到的矩阵一样\r\n\r\n但是在 webgl 中因为一些历史问题需要换成列主序\r\n\r\n行主序换成列主序 具体做法是交换矩阵的行和列 即矩阵转置\r\n\r\n转置后的列主序矩阵如下\r\n\r\n$\r\n\\begin{pmatrix}\r\n1 & 0 & 0 & 0 \\\\\r\n0 & 1 & 0 & 0 \\\\\r\n0 & 0 & 1 & 0 \\\\\r\nx_1 & y_1 & z_1 & 1\r\n\\end{pmatrix}\r\n$"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "平移矩阵的应用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  uniform mat4 mat;\n  void main() {\n    gl_Position = mat * aPosition;\n    gl_PointSize = 10.0;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const mat = gl.getUniformLocation(program, 'mat');\n  const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    0.0,  0.5,\n  ])\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition)\n  let x = -1;\n  function animation() {\n    x += 0.01;\n    if (x > 1) x = -1;\n    const matrix = getTranslateMatrix(x, x);\n    gl.uniformMatrix4fv(mat, false, matrix);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n    requestAnimationFrame(animation);\n  }\n  animation();\n`;\nconst { renderWebgl, declareFunction } = require(\"../../src/display.js\");\ndeclareFunction(/*js */ `\n  // 平移矩阵\n  function getTranslateMatrix(x = 0,y = 0,z = 0) {\n    return new Float32Array([\n      1.0,0.0,0.0,0.0,\n      0.0,1.0,0.0,0.0,\n      0.0,0.0,1.0,0.0,\n        x,  y,  z,  1,\n    ])\n  }\n`);\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <script>",
                                "            ",
                                "      // 平移矩阵",
                                "      function getTranslateMatrix(x = 0,y = 0,z = 0) {",
                                "        return new Float32Array([",
                                "          1.0,0.0,0.0,0.0,",
                                "          0.0,1.0,0.0,0.0,",
                                "          0.0,0.0,1.0,0.0,",
                                "            x,  y,  z,  1,",
                                "        ])",
                                "      }",
                                "",
                                "        </script>",
                                "    ",
                                "        <canvas id=\"9377e990-b10b-11ee-a80e-0926303e1540\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('9377e990-b10b-11ee-a80e-0926303e1540');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  uniform mat4 mat;\\n  void main() {\\n    gl_Position = mat * aPosition;\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "",
                                "  const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "  ])",
                                "",
                                "  const buffer = gl.createBuffer();",
                                "",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "",
                                "  let x = -1;",
                                "  function animation() {",
                                "    x += 0.01;",
                                "    if (x > 1) {",
                                "      x = -1;",
                                "    }",
                                "",
                                "    const matrix = getTranslateMatrix(x, x);",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "  ",
                                "    requestAnimationFrame(animation);",
                                "  }",
                                "  animation();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2.3 图形缩放\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "缩放矩阵推导过程\n\n![Alt text](image-19.png)\n\n首先，定义平移变换的基本公式为：\n\n$ x' = Tx * x $\n\n$ y' = Ty * y $\n\n$ z' = Tz * z $\n\n$ w = 1 $\n\n这里 $ w $ 是齐次坐标的一部分，使得变换可以用矩阵乘法表示。\n\n接着，我们将这些变换映射到齐次坐标系中的矩阵变换中：\n\n$\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz \\\\\nw\n\\end{bmatrix}\n$ *\n$\n\\begin{bmatrix}\na & b & c & d \\\\\ne & f & g & h \\\\\ni & j & k & l \\\\\nm & n & o & p\n\\end{bmatrix}\n$ =\n$\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\nz' \\\\\nw'\n\\end{bmatrix}\n$\n\n$ ax + by + cz + dw = x' $\n\n$ ex + fy + gz + hw = y' $\n\n$ ix + jy + kz + lw = z' $\n\n$ mx + ny + oz + pw = w' $\n\n通过代入 $ x', y', z', w $ 的定义，我们可以解出矩阵的各个元素：\n\n1. 代入 $ x' = Tx * x $ 到 $ ax + by + cz + dw = x' $ 得到 $ a = Tx, b = 0, c = 0, d = 0 $。\n2. 代入 $ y' = Ty * y $ 到 $ ex + fy + gz + hw = y' $ 得到 $ e = 0, f = Ty, g = 0, h = 0 $。\n3. 代入 $ z' = Tz * z $ 到 $ ix + jy + kz + lw = z' $ 得到 $ i = 0, j = 0, k = Tz, l = 0 $。\n4. 由于 $ w $ 始终为 1, 故 $ mx + ny + oz + pw = w' $ 得到 $ p = 1 $。\n\n因此，整个平移变换的齐次坐标矩阵是：\n\n$\n\\begin{pmatrix}\nTx & 0 & 0 & x_1 \\\\\n0 & Ty & 0 & y_1 \\\\\n0 & 0 & Tz & z_1 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}\n$\n\n这是一个对称矩阵 列主序与行主序一致\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "缩放矩阵的应用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// 着色器\n// 创建着色器源码\nconst vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  uniform mat4 mat;\n  void main() {\n    gl_Position = mat * aPosition;\n    gl_PointSize = 10.0;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const mat = gl.getUniformLocation(program, 'mat');\n  const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    0.0,  0.5,\n  ])\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition)\n  let x = 0.1;\n  function animation() {\n    x += 0.01;\n    if (x > 1.5) x = 0.1;\n    const matrix = getScaleMatrix(x, x);\n    // 参数 location transpose array\n    gl.uniformMatrix4fv(mat, false, matrix);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n    requestAnimationFrame(animation);\n  }\n  animation();\n`;\nconst { renderWebgl, declareFunction } = require(\"../../src/display.js\");\ndeclareFunction(/*js */ `\n  // 缩放矩阵\n  function getScaleMatrix(tx = 1, ty = 1, tz = 1) {\n    return new Float32Array([\n      tx, 0.0, 0.0, 0.0,\n      0.0, ty, 0.0, 0.0,\n      0.0, 0.0, tz, 0.0,\n      0.0, 0.0, 0.0, 1,\n    ])\n  }\n`);\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          ",
                                "  // 视图矩阵获取",
                                "  function getViewMatrix(",
                                "    eyex,",
                                "    eyey,",
                                "    eyez,",
                                "    lookAtx,",
                                "    lookAty,",
                                "    lookAtz,",
                                "    upx,",
                                "    upy,",
                                "    upz",
                                "  ) {",
                                "    // 视点",
                                "    const eye = new Float32Array([eyex, eyey, eyez]);",
                                "    // 目标点",
                                "    const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);",
                                "    // 上方向",
                                "    const up = new Float32Array([upx, upy, upz]);",
                                "",
                                "    // 确定z轴",
                                "    const z = minus(eye, lookAt);",
                                "",
                                "    normalized(z);",
                                "    normalized(up);",
                                "",
                                "    // 确定x轴",
                                "    const x = cross(z, up);",
                                "",
                                "    normalized(x);",
                                "    // 确定y轴",
                                "    const y = cross(x, z);",
                                "    // prettier-ignore",
                                "    return new Float32Array([",
                                "      x[0],       y[0],       z[0],       0,",
                                "      x[1],       y[1],       z[1],       0,",
                                "      x[2],       y[2],       z[2],       0,",
                                "      -dot(x,eye),-dot(y,eye),-dot(z,eye),1",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 绕z轴旋转的旋转矩阵",
                                "  function getRotateMatrix(deg) {",
                                "    return new Float32Array([",
                                "      Math.cos(deg),  Math.sin(deg) ,0.0,0.0,",
                                "      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "      0.0,            0.0,            1.0,0.0,",
                                "      0.0,            0.0,            0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 缩放矩阵",
                                "  function getScaleMatrix(tx = 1, ty = 1, tz = 1) {",
                                "    return new Float32Array([",
                                "      tx, 0.0, 0.0, 0.0,",
                                "      0.0, ty, 0.0, 0.0,",
                                "      0.0, 0.0, tz, 0.0,",
                                "      0.0, 0.0, 0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"9e7018e0-b5a2-11ee-b32f-57ef30c77b2d\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('9e7018e0-b5a2-11ee-b32f-57ef30c77b2d');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  uniform mat4 mat;\\n  void main() {\\n    gl_Position = mat * aPosition;\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "  const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "  ])",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  let x = 0.1;",
                                "  function animation() {",
                                "    x += 0.01;",
                                "    if (x > 1.5) x = 0.1;",
                                "    const matrix = getScaleMatrix(x, x);",
                                "    // 参数 location transpose array",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "    requestAnimationFrame(animation);",
                                "  }",
                                "  animation();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2.4 图形旋转"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "旋转矩阵的推导过程 我们先探讨围绕z轴旋转的情况\n\n![Alt text](image-20.png)\n\n顶点 A (x, y)\n\n$ x = R * cos(α) $\n\n$ y = R * sin(α) $\n\n$ z = 0 $\n\n顶点 A' (x', y')\n\n$$\n\\begin{align*}\n&x' = R * \\cos(α + β) \\\\\n&\\phantom{x'} = R * ( \\cos(α)*\\cos(β) - \\sin(α)*\\sin(β)) \\\\\n&\\phantom{x'} = R*\\cos(α)*\\cos(β) - R*\\sin(α)*\\sin(β) \\\\\n&将顶点A带入 \\\\\n&\\phantom{x'} = x*\\cos(β) - y*\\sin(β)\n\\end{align*}\n$$\n\n$$\n\\begin{align*}\n&y' = R * \\sin(α + β) \\\\\n&\\phantom{y'} = R * ( \\cos(β)*\\cos(α) + \\cos(α)*\\sin(β)) \\\\\n&\\phantom{y'} = R * \\sin(α)*\\cos(β) + R*\\cos(α)*\\sin(β) \\\\\n&将顶点A带入 \\\\\n&\\phantom{y'} = y*\\cos(β) - x*\\sin(β)\n\\end{align*}\n$$\n\n$$\nz' = z\n$$\n\n\n$ ax + by + cz + dw = x' $\n\n$ ex + fy + gz + hw = y' $\n\n$ ix + jy + kz + lw = z' $\n\n$ mx + ny + oz + pw = w' $\n\n得到矩阵\n\n绕z轴的旋转矩阵\n$\n\\begin{pmatrix}\n    \\cos(β) & \\sin(β) & 0 & 0 \\\\\n    \\sin(β) & \\cos(β) & 0 & 0 \\\\\n    0       & 0       & 1 & 0 \\\\\n    0       & 0       & 0 & 1\\\\\n\\end{pmatrix}\n$\n\n可以看出来绕z轴即z轴的内容不变（第三行和第三列的内容不变）\n\n类似地 得出其余两轴的旋转矩阵\n\n绕y轴的旋转矩阵\n$\n\\begin{pmatrix}\n    \\cos(β) & 0 & \\sin(β) & 0 \\\\\n    0       & 1 & 0       & 0 \\\\\n    \\sin(β) & 1 & \\cos(β) & 0 \\\\\n    0       & 0 & 0       & 1 \\\\\n\\end{pmatrix}\n$\n\n绕x轴的旋转矩阵\n$\n\\begin{pmatrix}\n    1 & 0       & 0       & 0 \\\\\n    0 & \\cos(β) & \\sin(β) & 0 \\\\\n    0 & \\sin(β) & \\cos(β) & 0 \\\\\n    0 & 0       & 0       & 0 \\\\\n\\end{pmatrix}\n$"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "旋转矩阵的应用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  uniform mat4 mat;\n  void main() {\n    gl_Position = mat * aPosition;\n    gl_PointSize = 10.0;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const mat = gl.getUniformLocation(program, 'mat');\n  const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    0.0,  0.5,\n  ])\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition)\n  \n  let x = 0;\n  function animation() {\n    x += 0.01;\n    const matrix = getRotateMatrix(x);\n    // gl.vertexAttrib1f(aTranslate, x);\n    gl.uniformMatrix4fv(mat, false, matrix);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n    requestAnimationFrame(animation);\n  }\n  animation()\n`;\n\nconst { renderWebgl, declareFunction } = require(\"../../src/display.js\");\ndeclareFunction(/*js */ `\n  // 绕z轴旋转的旋转矩阵\n  function getRotateMatrix(deg) {\n    return new Float32Array([\n      Math.cos(deg),  Math.sin(deg) ,0.0,0.0,\n      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,\n      0.0,            0.0,            1.0,0.0,\n      0.0,            0.0,            0.0, 1,\n    ])\n  }\n`);\nrenderWebgl(vertex_code, fragment_code, js_code);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          ",
                                "  // 视图矩阵获取",
                                "  function getViewMatrix(",
                                "    eyex,",
                                "    eyey,",
                                "    eyez,",
                                "    lookAtx,",
                                "    lookAty,",
                                "    lookAtz,",
                                "    upx,",
                                "    upy,",
                                "    upz",
                                "  ) {",
                                "    // 视点",
                                "    const eye = new Float32Array([eyex, eyey, eyez]);",
                                "    // 目标点",
                                "    const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);",
                                "    // 上方向",
                                "    const up = new Float32Array([upx, upy, upz]);",
                                "",
                                "    // 确定z轴",
                                "    const z = minus(eye, lookAt);",
                                "",
                                "    normalized(z);",
                                "    normalized(up);",
                                "",
                                "    // 确定x轴",
                                "    const x = cross(z, up);",
                                "",
                                "    normalized(x);",
                                "    // 确定y轴",
                                "    const y = cross(x, z);",
                                "    // prettier-ignore",
                                "    return new Float32Array([",
                                "      x[0],       y[0],       z[0],       0,",
                                "      x[1],       y[1],       z[1],       0,",
                                "      x[2],       y[2],       z[2],       0,",
                                "      -dot(x,eye),-dot(y,eye),-dot(z,eye),1",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 绕z轴旋转的旋转矩阵",
                                "  function getRotateMatrix(deg) {",
                                "    return new Float32Array([",
                                "      Math.cos(deg),  Math.sin(deg) ,0.0,0.0,",
                                "      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "      0.0,            0.0,            1.0,0.0,",
                                "      0.0,            0.0,            0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 缩放矩阵",
                                "  function getScaleMatrix(tx = 1, ty = 1, tz = 1) {",
                                "    return new Float32Array([",
                                "      tx, 0.0, 0.0, 0.0,",
                                "      0.0, ty, 0.0, 0.0,",
                                "      0.0, 0.0, tz, 0.0,",
                                "      0.0, 0.0, 0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 绕z轴旋转的旋转矩阵",
                                "  function getRotateMatrix(deg) {",
                                "    return new Float32Array([",
                                "      Math.cos(deg),  -Math.sin(deg) ,0.0,0.0,",
                                "      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "      0.0,            0.0,            1.0,0.0,",
                                "      0.0,            0.0,            0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 绕z轴旋转的旋转矩阵",
                                "  function getRotateMatrix(deg) {",
                                "    return new Float32Array([",
                                "      Math.cos(deg),  Math.sin(deg) ,0.0,0.0,",
                                "      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "      0.0,            0.0,            1.0,0.0,",
                                "      0.0,            0.0,            0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"7e6eaaf0-b5a4-11ee-b32f-57ef30c77b2d\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('7e6eaaf0-b5a4-11ee-b32f-57ef30c77b2d');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  uniform mat4 mat;\\n  void main() {\\n    gl_Position = mat * aPosition;\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "  const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "  ])",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  ",
                                "  let x = 0;",
                                "  function animation() {",
                                "    x += 0.01;",
                                "    const matrix = getRotateMatrix(x);",
                                "    // gl.vertexAttrib1f(aTranslate, x);",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "    requestAnimationFrame(animation);",
                                "  }",
                                "  animation()",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2.5 矩阵复合\r\n\r\n矩阵 A * 矩阵 B 表示先进行 B 变换再进行 A 变换\r\n\r\n![矩阵乘法](image-21.png)"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// 着色器\n// 创建着色器源码\nconst vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  uniform mat4 mat;\n  void main() {\n    gl_Position = mat * aPosition;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const mat = gl.getUniformLocation(program, 'mat');\n  const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    0.0,  0.5,\n  ])\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition)\n  let deg = 0;\n  let translateX = -1;\n  let scaleX = 0.1;\n  function animation() {\n    deg += 0.01;\n    translateX += 0.01;\n    scaleX += 0.01;\n    if (translateX > 1) translateX = -1;\n    if (scaleX > 1.5)  scaleX = 0.1;\n    const translate = getTranslateMatrix(translateX);\n    const scale = getScaleMatrix(scaleX);\n    const rotate = getRotateMatrix(deg);\n    const matrix = mixMatrix(mixMatrix(translate, scale), rotate);\n    gl.uniformMatrix4fv(mat, false, matrix);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n    requestAnimationFrame(animation);\n  }\n  animation()\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\ndeclareFunction(/*js */ `\n  function mixMatrix(A, B) {\n    const result = new Float32Array(16);\n    for (let i = 0; i < 4; i++) {\n      result[i] = A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3]\n      result[i + 4] = A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7]\n      result[i + 8] = A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11]\n      result[i + 12] = A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15]\n    }\n    return result;\n  }\n`);\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <script>",
                                "            ",
                                "    // 缩放矩阵",
                                "    function getScaleMatrix(tx = 1, ty = 1, tz = 1) {",
                                "        return new Float32Array([",
                                "            tx, 0.0, 0.0, 0.0,",
                                "            0.0, ty, 0.0, 0.0,",
                                "            0.0, 0.0, tz, 0.0,",
                                "            0.0, 0.0, 0.0, 1,",
                                "        ])",
                                "    }",
                                "",
                                "        </script>",
                                "    ",
                                "",
                                "        <script>",
                                "            ",
                                "  // 绕z轴旋转的旋转矩阵",
                                "  function getRotateMatrix(deg) {",
                                "    return new Float32Array([",
                                "    Math.cos(deg)  ,Math.sin(deg) ,0.0,0.0,",
                                "    -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "    0.0,            0.0,            1.0,0.0,",
                                "    0.0,            0.0,            0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "        </script>",
                                "    ",
                                "",
                                "        <script>",
                                "            ",
                                "    function mixMatrix(A, B) {",
                                "        const result = new Float32Array(16);",
                                "        for (let i = 0; i < 4; i++) {",
                                "            result[i] = A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3]",
                                "            result[i + 4] = A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7]",
                                "            result[i + 8] = A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11]",
                                "            result[i + 12] = A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15]",
                                "        }",
                                "        return result;",
                                "    }",
                                "",
                                "        </script>",
                                "    ",
                                "        <canvas id=\"82bf7cf0-b10e-11ee-b5c4-f3694e49a98a\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('82bf7cf0-b10e-11ee-b5c4-f3694e49a98a');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    uniform mat4 mat;\\n    void main() {\\n    gl_Position = mat * aPosition;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    void main() {\\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const mat = gl.getUniformLocation(program, 'mat');",
                                "    const points = new Float32Array([",
                                "        -0.5, -0.5,",
                                "        0.5, -0.5,",
                                "        0.0,  0.5,",
                                "    ])",
                                "    ",
                                "    const buffer = gl.createBuffer();",
                                "    ",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "    ",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "    ",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "    ",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "    ",
                                "    let deg = 0;",
                                "    let translateX = -1;",
                                "    let scaleX = 0.1;",
                                "    function animation() {",
                                "        deg += 0.01;",
                                "        translateX += 0.01;",
                                "        scaleX += 0.01;",
                                "        ",
                                "        if (translateX > 1) {",
                                "            translateX = -1;",
                                "        }",
                                "        ",
                                "        if (scaleX > 1.5) {",
                                "            scaleX = 0.1;",
                                "        }",
                                "        ",
                                "        const translate = getTranslateMatrix(translateX);",
                                "        const scale = getScaleMatrix(scaleX);",
                                "        const rotate = getRotateMatrix(deg);",
                                "        ",
                                "        const matrix = mixMatrix(mixMatrix(translate, scale), rotate);",
                                "        gl.uniformMatrix4fv(mat, false, matrix);",
                                "        gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "        ",
                                "        requestAnimationFrame(animation);",
                                "    }",
                                "    ",
                                "    animation()",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2.6 示例 百叶窗特效\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  varying vec4 vPosition;\n  void main() {\n    vPosition = aPosition;\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n    gl_PointSize = 10.0;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  precision lowp float;\n  uniform float uHeight;\n  varying vec4 vPosition;\n  uniform float list[5]; // 声明一个数组变量\n\n  void main() {\n    for(int i = 0; i < 5; i++) {\n      if (vPosition.y > list[i + 1] && vPosition.y < list[i]) {\n        if (vPosition.y > uHeight - float(i) * 0.5) {\n          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n      }\n    }\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const uHeight = gl.getUniformLocation(program, 'uHeight');\n  const uList = gl.getUniformLocation(program,'list');\n\n  gl.uniform1fv(uList, [1.0, 0.5, 0.0, -0.5, -1.0]);\n  const points = new Float32Array([\n    -1.0, -1.0,\n    1.0, -1.0,\n    -1.0,  1.0,\n    1.0,  1.0,\n  ])\n  \n  const buffer = gl.createBuffer();\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n\n  gl.enableVertexAttribArray(aPosition)\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\n\n  let value = 1;\n  function run() {\n    value -= 0.01;\n\n    gl.uniform1f(uHeight, value);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n    requestAnimationFrame(run)\n  }\n  run();\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"040bc430-b164-11ee-9ab2-1397e8fc942a\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('040bc430-b164-11ee-9ab2-1397e8fc942a');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  varying vec4 vPosition;\\n  void main() {\\n    vPosition = aPosition;\\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  precision lowp float;\\n  uniform float uHeight;\\n  varying vec4 vPosition;\\n  uniform float list[5]; // 声明一个数组变量\\n\\n  void main() {\\n    for(int i = 0; i < 5; i++) {\\n      if (vPosition.y > list[i + 1] && vPosition.y < list[i]) {\\n        if (vPosition.y > uHeight - float(i) * 0.5) {\\n          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n        }\\n      }\\n    }\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const uHeight = gl.getUniformLocation(program, 'uHeight');",
                                "  const uList = gl.getUniformLocation(program,'list');",
                                "",
                                "  gl.uniform1fv(uList, [1.0, 0.5, 0.0, -0.5, -1.0]);",
                                "  const points = new Float32Array([",
                                "    -1.0, -1.0,",
                                "    1.0, -1.0,",
                                "    -1.0,  1.0,",
                                "    1.0,  1.0,",
                                "  ])",
                                "  ",
                                "  const buffer = gl.createBuffer();",
                                "",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)",
                                "",
                                "  let value = 1;",
                                "  function run() {",
                                "    value -= 0.01;",
                                "",
                                "    gl.uniform1f(uHeight, value);",
                                "    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);",
                                "",
                                "    requestAnimationFrame(run)",
                                "  }",
                                "  run();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2.7 示例 淡入淡出特效\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  void main() {\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n    gl_PointSize = 10.0;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  precision lowp float;\n  uniform float uOpacity;\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,uOpacity);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const uOpacity = gl.getUniformLocation(program, 'uOpacity');\n\n  const points = new Float32Array([\n    -1.0, -1.0,\n    1.0, -1.0,\n    -1.0,  1.0,\n    1.0,  1.0,\n  ])\n\n  const buffer = gl.createBuffer();\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n\n  gl.enableVertexAttribArray(aPosition)\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\n\n  let value = 0;\n  function run() {\n    value += 0.01;\n    gl.uniform1f(uOpacity, value);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    requestAnimationFrame(run)\n  }\n  run();\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"1b693630-b164-11ee-9ab2-1397e8fc942a\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('1b693630-b164-11ee-9ab2-1397e8fc942a');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  void main() {\\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  precision lowp float;\\n  uniform float uOpacity;\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,uOpacity);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const uOpacity = gl.getUniformLocation(program, 'uOpacity');",
                                "",
                                "  const points = new Float32Array([",
                                "    -1.0, -1.0,",
                                "    1.0, -1.0,",
                                "    -1.0,  1.0,",
                                "    1.0,  1.0,",
                                "  ])",
                                "",
                                "  const buffer = gl.createBuffer();",
                                "",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)",
                                "",
                                "  let value = 0;",
                                "  function run() {",
                                "    value += 0.01;",
                                "    gl.uniform1f(uOpacity, value);",
                                "    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);",
                                "    requestAnimationFrame(run)",
                                "  }",
                                "  run();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  varying vec4 vPosition;\n  void main() {\n    vPosition = aPosition;\n\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n    gl_PointSize = 10.0;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  precision lowp float;\n  uniform float uHeight;\n  varying vec4 vPosition;\n\n  void main() {\n    // 向上卷 vPosition.y > uHeight   uHeight 的取值范围 -1.0 1.0\n    // 向下卷 vPosition.y < uHeight   uHeight 的取值范围 -1.0 1.0\n    // 向左卷 vPosition.x < uHeight   uHeight 的取值范围 -1.0 1.0\n    // 向右卷 vPosition.x > uHeight   uHeight 的取值范围 -1.0 1.0\n    // 左下-右上\n    // vPosition.x > uHeight && vPosition.y > uHeight\n    // uHeight 从 -1.0 到 1.0\n\n    if (vPosition.y > uHeight) {\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const uHeight = gl.getUniformLocation(program, 'uHeight');\n\n  const points = new Float32Array([\n    -1.0, -1.0,\n    1.0, -1.0,\n    -1.0,  1.0,\n    1.0,  1.0,\n  ])\n\n  const buffer = gl.createBuffer();\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n\n  gl.enableVertexAttribArray(aPosition)\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\n  \n  let value = -1;\n  function run() {\n    value += 0.01;\n    gl.uniform1f(uHeight, value);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    requestAnimationFrame(run)\n  }\n  run();\n`;\n\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"873138e0-b164-11ee-9ab2-1397e8fc942a\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('873138e0-b164-11ee-9ab2-1397e8fc942a');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  varying vec4 vPosition;\\n  void main() {\\n    vPosition = aPosition;\\n\\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  precision lowp float;\\n  uniform float uHeight;\\n  varying vec4 vPosition;\\n\\n  void main() {\\n    // 向上卷 vPosition.y > uHeight   uHeight 的取值范围 -1.0 1.0\\n    // 向下卷 vPosition.y < uHeight   uHeight 的取值范围 -1.0 1.0\\n    // 向左卷 vPosition.x < uHeight   uHeight 的取值范围 -1.0 1.0\\n    // 向右卷 vPosition.x > uHeight   uHeight 的取值范围 -1.0 1.0\\n    // 左下-右上\\n    // vPosition.x > uHeight && vPosition.y > uHeight\\n    // uHeight 从 -1.0 到 1.0\\n\\n    if (vPosition.y > uHeight) {\\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n    } else {\\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);\\n    }\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const uHeight = gl.getUniformLocation(program, 'uHeight');",
                                "",
                                "  const points = new Float32Array([",
                                "    -1.0, -1.0,",
                                "    1.0, -1.0,",
                                "    -1.0,  1.0,",
                                "    1.0,  1.0,",
                                "  ])",
                                "",
                                "  const buffer = gl.createBuffer();",
                                "",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)",
                                "  ",
                                "  let value = -1;",
                                "  function run() {",
                                "    value += 0.01;",
                                "    gl.uniform1f(uHeight, value);",
                                "    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);",
                                "    requestAnimationFrame(run)",
                                "  }",
                                "  run();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2.8 示例 使用 varing 变量来绘制彩色三角形\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  varying vec4 vColor;\n  void main() {\n    vColor = aPosition;\n    gl_Position = aPosition;\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  precision lowp float;\n  varying vec4 vColor;\n\n  void main() {\n    gl_FragColor = vColor;\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    0.0,  0.5,\n  ])\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition)\n  gl.drawArrays(gl.TRIANGLES, 0, 3);\n`;\n\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.9 webgl绘制流程\r\n\r\n![Alt text](image-22.png)\r\n\r\n1. 图元装配过程： 将独⽴的顶点坐标装配成几何图形，图形的类别由 gl.drawArrays() 第⼀个参数确定\r\n2. 光栅化：这⼀步是将装配好的图形转换为片元\r\n3. 剔除：对于不透明物体，背⾯对于观察者来说是不可⻅的。那么在渲染过程中，就会将不可⻅的部分剔除， 不参与绘制。节省渲染开销。\r\n4. 裁剪：在可视范围之外的事物是看不到的。图形⽣成后，有的部分可能位于可视范围之外，这⼀部分会被剪裁掉，不参与绘制\r\n\r\n### 3.0 纹理坐标\r\n\r\n![Alt text](image-23.png)\r\n\r\n在 webgl ⾥需要通过纹理坐标和图形顶点坐标的映射关系来确定贴图\r\n\r\n![Alt text](image-24.png)\r\n\r\n创建纹理对象\r\n\r\n纹理对象主要⽤于存储纹理图像数据。\r\n\r\n由于图像坐标和纹理坐标的差异,需要进行 Y 轴翻转\r\n\r\n![Alt text](image-25.png)"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  attribute vec4 aTex;\n  varying vec2 vTex;\n  void main() {\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n    vTex = vec2(aTex.x, aTex.y);\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  precision lowp float;\n  uniform sampler2D uSampler;\n  varying vec2 vTex;\n  void main() {\n    gl_FragColor = texture2D(uSampler, vTex);\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const aTex = gl.getAttribLocation(program, 'aTex');\n  const uSampler = gl.getUniformLocation(program, 'uSampler');\n\n  const points = new Float32Array([\n    -0.5,  0.5, 0.0, 1.0,\n    -0.5, -0.5, 0.0, 0.0,\n    0.5,  0.5, 1.0, 1.0,\n    0.5, -0.5, 1.0, 0.0,\n  ])\n\n  const buffer = gl.createBuffer();\n  const BYTES = points.BYTES_PER_ELEMENT;\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 4, 0);\n  gl.enableVertexAttribArray(aPosition)\n  gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, BYTES * 4, BYTES * 2);\n  gl.enableVertexAttribArray(aTex)\n  const img = new Image();\n  img.src = '../../assets/content.png';\n  img.onload = function() {\n    const texture = gl.createTexture(); // 创建纹理对象\n    // gl.deletTexture(textrue); // 删除纹理对象的方式\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 翻转 图片 Y轴\n    gl.activeTexture(gl.TEXTURE0); // 激活0号纹理单元 Webgl 是通过纹理单元来管理纹理对象,每个纹理单元管理⼀张纹理图像\n\n    /**\n     * 绑定纹理对象\n     * @param { gl.TEXTURE_2D | gl.TEXTURE_CUBE_MAP } type \n     * @param { Texture } texture\n     **/ \n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    /**\n     * 处理放大缩小的逻辑\n     * @param { gl.TEXTURE_2D | gl.TEXTURE_CUBE_MAP } type \n     * @param {\n     *   gl.TEXTURE_MAG_FILTER 放⼤\n     *  |gl.TEXTURE_MIN_FILTER 缩⼩\n     *  |gl.TEXTURE_WRAP_S 横向（⽔平填充）\n     *  |gl.TEXTURE_WRAP_T 纵向（垂直填充）\n     * } pname\n     * @param {\n     *  gl.NEAREST 使用像素颜色值\n     * |gl.LINEAR 使用四周的加权平均值\n     * |gl.REPEAT 平铺重复\n     * |gl.MIRRORED_REPEAT 镜像对称\n     * |gl.CLAMP_TO_EDGE 边缘延伸\n     * }\n     **/ \n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n\n    // 横向 纵向 平铺的方式\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n\n    /**\n     * 配置纹理图像\n     * @param { gl.TEXTURE_2D | gl.TEXTURE_CUBE_MAP } type\n     * @param { 0 } level\n     * @param {\n     *  gl.RGB\n     * |gl.RGBA\n     * |gl.ALPHA\n     * |gl.LUMINANCE 使用物体表面的 红绿蓝 分量的加权平均值来计算\n     * |gl.LUMINANCE_ALPHA\n     * } internalformat\n     * @param { 同internalformat } format\n     * @param {\n     *  gl.UNSIGNED_BYTE\n     * |gl.UNSIGNED_SHORT_5_6_5\n     * |gl.UNSIGNED_SHORT_4_4_4_4\n     * |gl.UNSIGNED_SHORT_5_5_5_1\n     * } dataType\n     * @param { Image } 图片对象\n     */\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);\n    gl.uniform1i(uSampler, 0);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 3.1 纹理融合"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  attribute vec4 aTex;\n  varying vec2 vTex;\n  void main() {\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n    vTex = vec2(aTex.x, aTex.y);\n  }\n`;\n\nconst fragment_code = /*glsl */ `\n  precision lowp float;\n  uniform sampler2D uSampler;\n  uniform sampler2D uSampler1;\n  varying vec2 vTex;\n  void main() {\n    vec4 c1 = texture2D(uSampler, vTex);\n    vec4 c2 = texture2D(uSampler1, vTex);\n    gl_FragColor = c1 * c2;\n  }\n`;\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const aTex = gl.getAttribLocation(program, 'aTex');\n  const uSampler = gl.getUniformLocation(program, 'uSampler');\n  const uSampler1 = gl.getUniformLocation(program, 'uSampler1');\n  const points = new Float32Array([\n    -0.5,  0.5, 0.0, 1.0,\n    -0.5, -0.5, 0.0, 0.0,\n      0.5,  0.5, 1.0, 1.0,\n      0.5, -0.5, 1.0, 0.0,\n  ]);\n  const buffer = gl.createBuffer();\n  const BYTES = points.BYTES_PER_ELEMENT;\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 4, 0);\n  gl.enableVertexAttribArray(aPosition)\n  gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, BYTES * 4, BYTES * 2);\n  gl.enableVertexAttribArray(aTex);\n  \n  function getImage(url, location, index) {\n    return new Promise(resolve => {\n      const img = new Image();\n      img.onload = function() {\n        const texture = gl.createTexture(); // 创建纹理对象\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 翻转 图片 Y轴\n        gl.activeTexture(gl['TEXTURE'+index]); // 开启一个纹理单元\n        gl.bindTexture(gl.TEXTURE_2D, texture); // 绑定纹理对象\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // 处理放大缩小的逻辑\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); // 横向 纵向 平铺的方式\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img); // 配置纹理图像\n        gl.uniform1i(location, index);\n        resolve();\n      }\n      img.src = url;\n    })\n  }\n  const border = getImage('../../assets/border.png', uSampler, 0);\n  const content = getImage('../../assets/content.png', uSampler1, 1);\n  Promise.all([border, content]).then(() => {\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  })\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"88883ce0-b513-11ee-9c09-f7a3db12889d\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('88883ce0-b513-11ee-9c09-f7a3db12889d');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  attribute vec4 aTex;\\n  varying vec2 vTex;\\n  void main() {\\n    gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n    vTex = vec2(aTex.x, aTex.y);\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  precision lowp float;\\n  uniform sampler2D uSampler;\\n  uniform sampler2D uSampler1;\\n  varying vec2 vTex;\\n  void main() {\\n    vec4 c1 = texture2D(uSampler, vTex);\\n    vec4 c2 = texture2D(uSampler1, vTex);\\n    gl_FragColor = c1 * c2;\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const aTex = gl.getAttribLocation(program, 'aTex');",
                                "  const uSampler = gl.getUniformLocation(program, 'uSampler');",
                                "  const uSampler1 = gl.getUniformLocation(program, 'uSampler1');",
                                "  const points = new Float32Array([",
                                "    -0.5,  0.5, 0.0, 1.0,",
                                "    -0.5, -0.5, 0.0, 0.0,",
                                "      0.5,  0.5, 1.0, 1.0,",
                                "      0.5, -0.5, 1.0, 0.0,",
                                "  ]);",
                                "  const buffer = gl.createBuffer();",
                                "  const BYTES = points.BYTES_PER_ELEMENT;",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 4, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, BYTES * 4, BYTES * 2);",
                                "  gl.enableVertexAttribArray(aTex);",
                                "  ",
                                "  function getImage(url, location, index) {",
                                "    return new Promise(resolve => {",
                                "      const img = new Image();",
                                "      img.onload = function() {",
                                "        const texture = gl.createTexture(); // 创建纹理对象",
                                "        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 翻转 图片 Y轴",
                                "        gl.activeTexture(gl['TEXTURE'+index]); // 开启一个纹理单元",
                                "        gl.bindTexture(gl.TEXTURE_2D, texture); // 绑定纹理对象",
                                "        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // 处理放大缩小的逻辑",
                                "        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)",
                                "        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); // 横向 纵向 平铺的方式",
                                "        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);",
                                "        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img); // 配置纹理图像",
                                "        gl.uniform1i(location, index);",
                                "        resolve();",
                                "      }",
                                "      img.src = url;",
                                "    })",
                                "  }",
                                "  const border = getImage('../../assets/border.png', uSampler, 0);",
                                "  const content = getImage('../../assets/content.png', uSampler1, 1);",
                                "  Promise.all([border, content]).then(() => {",
                                "    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);",
                                "  })",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 3.2 示例 放大镜\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n    attribute vec4 aPosition;\n    attribute vec4 aTex;\n    varying vec2 vTex;\n    varying vec4 vPosition;\n    void main() {\n        vPosition = aPosition;\n        gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\n        vTex = vec2(aTex.x, aTex.y);\n    }\n`;\n\nconst fragment_code = /*glsl */ `\n    precision lowp float;\n    uniform sampler2D uSampler;\n    varying vec2 vTex;\n    uniform vec2 lookAt; // 观察点的坐标\n    varying vec4 vPosition;\n\n    void main() {\n        vec2 uv = vTex;\n        float fOpacity = 0.0;\n        float dis = distance(lookAt, vec2(vPosition)); // 判断当前点和 lookAt 的距离\n        if (dis > 0.2) {\n            fOpacity = 0.05;\n        } else {\n            fOpacity = 1.0;\n            vec2 diff = vPosition.xy - lookAt;\n            uv.x -= diff.x * 0.2;\n            uv.y += diff.y * 0.2;\n        }\n        vec4 color = texture2D(uSampler, uv);\n        gl_FragColor = vec4(color.xyz * fOpacity, fOpacity);\n    }\n`;\n\nconst js_code = /*js*/ `\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    const aTex = gl.getAttribLocation(program, 'aTex');\n    const uSampler = gl.getUniformLocation(program, 'uSampler');\n    const lookAt = gl.getUniformLocation(program, 'lookAt');\n    const points = new Float32Array([\n        -0.9,  0.9, 0.0, 1.0,\n        -0.9, -0.9, 0.0, 0.0,\n        0.9,  0.9, 1.0, 1.0,\n        0.9, -0.9, 1.0, 0.0,\n    ])\n    const buffer = gl.createBuffer();\n    const BYTES = points.BYTES_PER_ELEMENT;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 4, 0);\n    gl.enableVertexAttribArray(aPosition)\n    gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, BYTES * 4, BYTES * 2);\n    gl.enableVertexAttribArray(aTex)\n    const img = new Image();\n    img.onload = function() {\n        const texture = gl.createTexture(); // 创建纹理对象\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 翻转 图片 Y轴\n        gl.activeTexture(gl.TEXTURE0); // 开启一个纹理单元\n        gl.bindTexture(gl.TEXTURE_2D, texture); // 绑定纹理对象\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // 处理放大缩小的逻辑\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); \n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); // 横向 纵向 平铺的方式\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img); // 配置纹理图像\n        gl.uniform1i(uSampler, 0);\n    }\n    img.src = '../../assets/content.png'\n    function draw() {\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        requestAnimationFrame(draw)\n    }\n    draw()\n    document.onmousemove = (ev) => {\n        const x = ev.clientX\n        const y = ev.clientY\n        const domPosition = ev.target.getBoundingClientRect();\n        const domx = x - domPosition.left\n        const domy = y - domPosition.top;\n        const halfWidth = ctx.offsetWidth / 2\n        const halfHeight = ctx.offsetHeight / 2\n        const clickX = (domx - halfWidth) / halfWidth\n        const clickY = (halfHeight - domy) / halfHeight\n        gl.uniform2fv(lookAt, [clickX, clickY]);\n    }\n`;\nconst { renderWebgl } = require(\"../../src/display.js\");\nrenderWebgl(vertex_code, fragment_code, js_code);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"26eac5b0-b159-11ee-9ab2-1397e8fc942a\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('26eac5b0-b159-11ee-9ab2-1397e8fc942a');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    // 只传递顶点数据\\n    attribute vec4 aPosition;\\n    attribute vec4 aTex;\\n    varying vec2 vTex;\\n    varying vec4 vPosition;\\n    void main() {\\n        vPosition = aPosition;\\n        gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\\n        vTex = vec2(aTex.x, aTex.y);\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    precision lowp float;\\n    uniform sampler2D uSampler;\\n    varying vec2 vTex;\\n    uniform vec2 lookAt; // 观察点的坐标\\n    varying vec4 vPosition;\\n\\n    void main() {\\n        vec2 uv = vTex;\\n        float fOpacity = 0.0;\\n        // 1. 判断当前点和 lookAt 的距离\\n        float dis = distance(lookAt, vec2(vPosition));\\n        if (dis > 0.2) {\\n            fOpacity = 0.05;\\n        } else {\\n            fOpacity = 1.0;\\n            vec2 diff = vPosition.xy - lookAt;\\n            uv.x -= diff.x * 0.2;\\n            uv.y += diff.y * 0.2;\\n        }\\n        vec4 color = texture2D(uSampler, uv);\\n        gl_FragColor = vec4(color.xyz * fOpacity, fOpacity);\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const aTex = gl.getAttribLocation(program, 'aTex');",
                                "    const uSampler = gl.getUniformLocation(program, 'uSampler');",
                                "    const lookAt = gl.getUniformLocation(program, 'lookAt');",
                                "    const points = new Float32Array([",
                                "        -0.9,  0.9, 0.0, 1.0,",
                                "        -0.9, -0.9, 0.0, 0.0,",
                                "        0.9,  0.9, 1.0, 1.0,",
                                "        0.9, -0.9, 1.0, 0.0,",
                                "    ])",
                                "    const buffer = gl.createBuffer();",
                                "    const BYTES = points.BYTES_PER_ELEMENT;",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 4, 0);",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "    gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, BYTES * 4, BYTES * 2);",
                                "    gl.enableVertexAttribArray(aTex)",
                                "    const img = new Image();",
                                "    img.onload = function() {",
                                "        const texture = gl.createTexture(); // 创建纹理对象",
                                "        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 翻转 图片 Y轴",
                                "        gl.activeTexture(gl.TEXTURE0); // 开启一个纹理单元",
                                "        gl.bindTexture(gl.TEXTURE_2D, texture); // 绑定纹理对象",
                                "        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // 处理放大缩小的逻辑",
                                "        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); ",
                                "        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); // 横向 纵向 平铺的方式",
                                "        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)",
                                "        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img); // 配置纹理图像",
                                "        gl.uniform1i(uSampler, 0);",
                                "    }",
                                "    img.src = '../../assets/content.png'",
                                "    function draw() {",
                                "        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);",
                                "        requestAnimationFrame(draw)",
                                "    }",
                                "    draw()",
                                "    document.onmousemove = (ev) => {",
                                "        const x = ev.clientX",
                                "        const y = ev.clientY",
                                "        const domPosition = ev.target.getBoundingClientRect();",
                                "        const domx = x - domPosition.left",
                                "        const domy = y - domPosition.top;",
                                "        const halfWidth = ctx.offsetWidth / 2",
                                "        const halfHeight = ctx.offsetHeight / 2",
                                "        const clickX = (domx - halfWidth) / halfWidth",
                                "        const clickY = (halfHeight - domy) / halfHeight",
                                "        gl.uniform2fv(lookAt, [clickX, clickY]);",
                                "    }",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "## 2 glsl语言基础\r\n\r\n### 2.1 特性\r\n大小写敏感\r\n强制分号\r\n强类型语言\r\n变量不能以gl_,webgl_,_webgl_开头\r\n浮点数1必须要表示为1.0\r\n### 2.2 类型转换函数\r\nint()\r\nfloat()\r\nbool()\r\n\r\n### 2.3 运算符\r\n\r\n![运算符](2024-01-13-15-05-31.png)\r\n\r\n### 2.4 矢量和矩阵\r\n\r\n`vec2` `vec3` `vec4` 用来表示具有 2，3，4 个浮点数元素的矢量\r\n`ivec2` `ivec3` `ivec4` 用来表示具有 2，3，4 个整型元素的矢量\r\n`bvec2` `bvec3` `bvec4` 用来表示具有 2，3，4 个布尔值元素的矢量\r\n使用`x y z w`等属性来访问顶点坐标的分量        \r\n使用`s t p q`等属性来访问纹理坐标的分量        \r\n这些属性也可以通过混合的方式取值\r\n例如:\r\n\r\n```glsl\r\nvec4 position = vec4(0.1, 0.2, 0.3, 1.0);\r\nposition.x; // 0.1\r\npositon.xz; // vec2(0.1, 0.3)\r\npositon.xyz; // vec2(0.1, 0.2, 0.3)\r\n```\r\n\r\n`mat2` `mat3` `mat4` 用来表示具有2 * 2， 3 * 3， 4 * 4 的浮点数元素的矩阵\r\n\r\n```glsl\r\nmat4 m = mat4(\r\n    1.0, 5.0,  9.0, 13.0,\r\n    2.0, 6.0, 10.0, 14.0,\r\n    3.0, 7.0, 11.0, 15.0,\r\n    4.0, 8.0, 12.0, 16.0,\r\n); // 注意 输入参数必须是列主序\r\n```\r\n\r\n上面的代码表示的是如下的矩阵\r\n\r\n\r\n$\r\n\\begin{bmatrix}\r\n1.0 & 2.0 & 3.0 & 4.0 \\\\\r\n5.0 & 6.0 & 7.0 & 8.0 \\\\\r\n9.0 & 10.0 & 11.0 & 12.0 \\\\\r\n13.0 & 14.0 & 15.0 & 16.0\r\n\\end{bmatrix}\r\n$\r\n\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.5 纹理取样器\r\n\r\n纹理取样器只能声明为uniform变量\r\n\r\n`sampler2D` 二维纹理\r\n\r\n`samplerCube` 立方体纹理\r\n\r\n声明例子\r\n\r\n```glsl\r\nuniform sampler2D uSampler;\r\nuniform samplerCube uSamplerCube;\r\n\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.6 分支与循环\r\n\r\n`if else` `switch case` `for` `while` `do while` `continue` `break`的使用方式与js相同\r\n`discard` 在片元着色器中表示放弃当前片元直接处理下一个片元"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.7 函数\r\n\r\n```glsl\r\nfloat getFloat(){\r\n    return 1.1;\r\n}\r\n```\r\n\r\nglsl的常用的内置函数如下\r\n\r\n角度函数\r\n`radians` 角度转弧度\r\n`degress` 弧度转角度\r\n\r\n三角函数\r\n`sin` 正弦\r\n`cos` 余弦\r\n`tan` 正切\r\n`asin` 反正弦\r\n`acos` 反余弦\r\n`atan` 反正切\r\n\r\n指数函数\r\n`pow` 次方\r\n`exp` 自然对数\r\n`log` 对数\r\n`sqrt` 开平方\r\n`inversesqrt` 开平方的倒数\r\n\r\n通用函数\r\n`abs` 绝对值\r\n`min` 最小值\r\n`max` 最大值\r\n`mod` 取余数\r\n`sign` 取符号\r\n`floor` 向下取整\r\n`ceil` 向上取整\r\n`clamp` 限定范围\r\n`fract` 取小数部分\r\n\r\n几何函数\r\n`length(x)` 计算向量x的长度\r\n`distance(x, y)` 计算向量x,y之间的距离\r\n`dot(x, y)` 计算向量xy之间的点积\r\n`cross(x, y)` 计算向量xy的叉积\r\n`normalize(x)` 返回同向的单位向量\r\n\r\n矢量函数\r\n`any` 矢量的任意一个元素满足条件\r\n`all` 矢量的所有元素均满足条件\r\n`not` 逐元素布尔取反\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 2.8 存储限定词\r\n\r\n变量类型词\r\n`const` 常量\r\n\r\n存储类型词\r\nattribute 顶点着色器中的全局变量 表示逐顶点信息\r\nuniform 只读 两个着色器中都可 强调一致性 用于存储影响所有顶点的数据 例如变换矩阵等\r\nvarying 用于存储从顶点着色器传递给片元着色器的数据\r\n\r\n精度限定词\r\n`mediump float f` 限定变量f的精度 不推荐\r\n`precision mediump float` 限定着色器的默认精度\r\n其中 可选的精度枚举有 `highp mediump lowp`\r\n注意: 片元着色器中的float类型需要设置默认精度"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## 3 3D基础\n\n![](2024-01-13-16-20-57.png)\n\n![Alt text](image-26.png)\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n  attribute vec4 aPosition;\n  uniform mat4 mat;\n  void main() {\n    gl_Position = mat * aPosition;\n    gl_PointSize = 10.0;\n  }\n`; // 顶点着色器\n\nconst fragment_code = /*glsl */ `\n  void main() {\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }\n`; // 片元着色器\n\nconst js_code = /*js*/ `\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\n  const mat = gl.getUniformLocation(program, 'mat');\n\n  const points = new Float32Array([\n    -0.5, -0.5,\n    0.5, -0.5,\n    0.0,  0.5,\n  ])\n\n  const buffer = gl.createBuffer();\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n\n  gl.enableVertexAttribArray(aPosition)\n\n  let eyey = -0.1;\n  function animation() {\n    eyey += 0.01;\n    if (eyey > 1) {\n      eyey = -0.1;\n    }\n\n    const vm = getViewMatrix(0.0,eyey,0.2,0.0,0.0,0.0,0.0,0.6,0.0);\n    gl.uniformMatrix4fv(mat, false, vm);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n\n    requestAnimationFrame(animation);\n  }\n\n  animation()\n`;\n\nconst { renderWebgl, declareFunction } = require(\"../../src/display.js\");\ndeclareFunction(/*js */ `\n  // 视图矩阵获取\n  function getViewMatrix(\n    eyex,\n    eyey,\n    eyez,\n    lookAtx,\n    lookAty,\n    lookAtz,\n    upx,\n    upy,\n    upz\n  ) {\n    // 视点\n    const eye = new Float32Array([eyex, eyey, eyez]);\n    // 目标点\n    const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\n    // 上方向\n    const up = new Float32Array([upx, upy, upz]);\n\n    // 确定z轴\n    const z = minus(eye, lookAt);\n\n    normalized(z);\n    normalized(up);\n\n    // 确定x轴\n    const x = cross(z, up);\n\n    normalized(x);\n    // 确定y轴\n    const y = cross(x, z);\n    // prettier-ignore\n    return new Float32Array([\n      x[0],       y[0],       z[0],       0,\n      x[1],       y[1],       z[1],       0,\n      x[2],       y[2],       z[2],       0,\n      -dot(x,eye),-dot(y,eye),-dot(z,eye),1\n    ])\n  }\n`);\nrenderWebgl(vertex_code, fragment_code, js_code);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          ",
                                "  // 视图矩阵获取",
                                "  function getViewMatrix(",
                                "    eyex,",
                                "    eyey,",
                                "    eyez,",
                                "    lookAtx,",
                                "    lookAty,",
                                "    lookAtz,",
                                "    upx,",
                                "    upy,",
                                "    upz",
                                "  ) {",
                                "    // 视点",
                                "    const eye = new Float32Array([eyex, eyey, eyez]);",
                                "    // 目标点",
                                "    const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);",
                                "    // 上方向",
                                "    const up = new Float32Array([upx, upy, upz]);",
                                "",
                                "    // 确定z轴",
                                "    const z = minus(eye, lookAt);",
                                "",
                                "    normalized(z);",
                                "    normalized(up);",
                                "",
                                "    // 确定x轴",
                                "    const x = cross(z, up);",
                                "",
                                "    normalized(x);",
                                "    // 确定y轴",
                                "    const y = cross(x, z);",
                                "    // prettier-ignore",
                                "    return new Float32Array([",
                                "      x[0],       y[0],       z[0],       0,",
                                "      x[1],       y[1],       z[1],       0,",
                                "      x[2],       y[2],       z[2],       0,",
                                "      -dot(x,eye),-dot(y,eye),-dot(z,eye),1",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"720b44c0-b5a0-11ee-b32f-57ef30c77b2d\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('720b44c0-b5a0-11ee-b32f-57ef30c77b2d');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  uniform mat4 mat;\\n  void main() {\\n    gl_Position = mat * aPosition;\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "",
                                "  const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "  ])",
                                "",
                                "  const buffer = gl.createBuffer();",
                                "",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "",
                                "  let eyey = -0.1;",
                                "  function animation() {",
                                "    eyey += 0.01;",
                                "    if (eyey > 1) {",
                                "      eyey = -0.1;",
                                "    }",
                                "",
                                "    const vm = getViewMatrix(0.0,eyey,0.2,0.0,0.0,0.0,0.0,0.6,0.0);",
                                "    gl.uniformMatrix4fv(mat, false, vm);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "",
                                "    requestAnimationFrame(animation);",
                                "  }",
                                "",
                                "  animation()",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 3.1 正射投影\r\n\r\n\r\n正射投影是所有的物体投影线都垂直于最终的绘图表面\r\n\r\n![](2024-01-13-16-25-37.png)\r\n\r\n先尝试将x转换到x'\r\n对于左右区间 有`-1 < x' < 1` 以及`l < x < r`\r\n将x的不等式的左右两边也转化成 (-1, 1)  具体过程如下\r\n\r\n![](2024-01-13-16-36-19.png)\r\n\r\n从而得到x与x'的关系\r\n\r\n对于上下区间 远近区间也类似处理 可以得到y与y'的关系 以及z与z'的关系\r\n\r\n![](2024-01-13-16-44-20.png)"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 3.2 透视投影\r\n\r\n![](2024-01-13-16-48-14.png)\r\n\r\n先将透视投影的棱台映射为长方体\r\n\r\n![](2024-01-13-16-49-54.png)\r\n\r\n![](2024-01-13-16-50-12.png)\r\n\r\n\r\n由相似三角形得出\r\n\r\n$ x' = \\frac{n}{f}* x $\r\n\r\n$ y' = \\frac{n}{f}* y $\r\n\r\n$\r\n\\begin{bmatrix}\r\n\\frac{n}{f} & 0 & 0 \\\\\r\n0 & \\frac{n}{f} & 0 \\\\\r\n? & ? & ?\r\n\\end{bmatrix}\r\n$ *\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz\r\n\\end{bmatrix}\r\n$ =\r\n$\r\n\\begin{bmatrix}\r\n\\frac{n}{f} * x \\\\\r\n\\frac{n}{f} * y \\\\\r\n?\r\n\\end{bmatrix}\r\n$\r\n\r\n按照 齐次坐标的概念\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz \\\\\r\n1\r\n\\end{bmatrix}\r\n$\r\n与\r\n$\r\n\\begin{bmatrix}\r\nk*x \\\\\r\nk*y \\\\\r\nk*z \\\\\r\nk\r\n\\end{bmatrix}\r\n$\r\n是等价的\r\n\r\n$\r\n\\begin{bmatrix}\r\n\\frac{n}{f} * x \\\\\r\n\\frac{n}{f} * y \\\\\r\n? \\\\\r\n1\r\n\\end{bmatrix}\r\n$ =>\r\n$\r\n\\begin{bmatrix}\r\nn * x \\\\\r\nn * y \\\\\r\n? \\\\\r\nf\r\n\\end{bmatrix}\r\n$\r\n\r\n即\r\n\r\n$\r\n\\begin{bmatrix}\r\nn & 0 & 0 & 0\\\\\r\n0 &n & 0 & 0\\\\\r\n? & ? & ? & ?\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$ *\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz \\\\\r\n1 \r\n\\end{bmatrix}\r\n$ =\r\n$\r\n\\begin{bmatrix}\r\nn * x \\\\\r\nn * y \\\\\r\n? \\\\\r\nf\r\n\\end{bmatrix}\r\n$\r\n\r\n接下来我们看第三行\r\n\r\n按照正常的4*4矩阵\r\n$\r\n\\begin{bmatrix}\r\na & b & c & d \\\\\r\ne & f & g & h \\\\\r\ni & j & k & l \\\\\r\nm & n & o & p\r\n\\end{bmatrix}\r\n$\r\n\r\n我们假设第三行为\r\n$ i*x+j*y+k*z+l=z' $\r\n\r\n易知 i=0 j=0\r\n因为需要将梯形映射到长方体 所以z分量应该不变\r\n将z=-f 和z=-n 分别带入上式 可得\r\n$ k = b + f $\r\n\r\n$ d = n * f $\r\n\r\n从而梯形空间转向长方体空间的转换矩阵为\r\n\r\n$\r\n\\begin{bmatrix}\r\nn & 0 & 0 & 0\\\\\r\n0 &n & 0 & 0\\\\\r\n0 & 0 & n+f & nf\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$\r\n\r\n再利用前面的正射投影的矩阵得到透视投影矩阵\r\n\r\n$\r\n\\begin{bmatrix}\r\nn & 0 & 0 & 0\\\\\r\n0 &n & 0 & 0\\\\\r\n0 & 0 & n+f & nf\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$ * \r\n\r\n= \r\n$\r\n\\begin{bmatrix}\r\n\\frac{2n}{r-1} & 0 & 0 & 0\\\\\r\n0 & \\frac{2n}{t-b} & 0 & 0\\\\\r\n0 & 0 & \\frac{n+f}{n-f} & 2\\frac{nf}{n-f}\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$\r\n\r\n其中\r\n$ t = n * tan(\\frac{α}{2}) $\r\n\r\n$ b = -t $\r\n\r\n$ r = n * aspect * tan(\\frac{α}{2}) $\r\n\r\n$ l = -r $\r\n\r\n用上述变量进行替换得到最终的透视投影矩阵\r\n\r\n$\r\n\\begin{bmatrix}\r\n\\frac{1}{aspect * tan(\\frac{α}{2})} & 0 & 0 & 0\\\\\r\n0 & \\frac{1}{tan(\\frac{α}{2})} & 0 & 0\\\\\r\n0 & 0 & \\frac{n+f}{n-f} & 2\\frac{nf}{n-f}\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "vscode插件推荐\r\n\r\nGLSL lint\r\nShader languages support for VS Code\r\nglsl-canvas"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\n    attribute vec4 aPosition;\n    uniform mat4 mat;\n    void main() {\n        gl_Position = mat * aPosition;\n        gl_PointSize = 10.0;\n    }\n  `; // 顶点着色器\n\nconst fragment_code = /*glsl */ `\n    void main() {\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n  `; // 片元着色器\n\nconst js_code = /*js*/ `\n    const aPosition = gl.getAttribLocation(program, \"aPosition\");\n    const mat = gl.getUniformLocation(program, \"mat\");\n\n    const points = new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.0, 0.5]);\n\n    const buffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n\n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n\n    gl.enableVertexAttribArray(aPosition);\n\n    let eyey = -0.1;\n    function animation() {\n        eyey += 0.01;\n        if (eyey > 1) {\n            eyey = -0.1;\n        }\n        \n        const vm = getViewMatrix(0.0, eyey, 0.2, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0);\n        const ortho = getOrtho(-1, 1, 1, -1, 0, 20);\n        // const matrix = getTranslateMatrix(x, x);\n        // gl.vertexAttrib1f(aTranslate, x);\n        gl.uniformMatrix4fv(mat, false, mixMatrix(vm, ortho));\n        gl.drawArrays(gl.TRIANGLES, 0, 3);\n\n        requestAnimationFrame(animation);\n    }\n    animation();\n`;\n\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\nconst path = require(\"path\");\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\nrenderWebgl(vertex_code, fragment_code, js_code, libs);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          { // 限制变量定义域",
                                "              function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {",
                                "  const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "",
                                "  gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE); // 指定顶点着色器的源码",
                                "  gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE); // 指定片元着色器的源码",
                                "",
                                "  // 编译着色器",
                                "  gl.compileShader(vertexShader);",
                                "  gl.compileShader(fragmentShader);",
                                "",
                                "  // 创建一个程序对象",
                                "  const program = gl.createProgram();",
                                "",
                                "  gl.attachShader(program, vertexShader);",
                                "  gl.attachShader(program, fragmentShader);",
                                "",
                                "  gl.linkProgram(program);",
                                "",
                                "  gl.useProgram(program);",
                                "",
                                "  return program;",
                                "}",
                                "",
                                "// 平移矩阵",
                                "function getTranslateMatrix(x = 0, y = 0, z = 0) {",
                                "  // prettier-ignore",
                                "  return new Float32Array([",
                                "    1.0, 0.0, 0.0, 0.0,",
                                "    0.0, 1.0, 0.0, 0.0,",
                                "    0.0, 0.0, 1.0, 0.0,",
                                "    x  , y  , z  , 1,",
                                "  ])",
                                "}",
                                "// 缩放矩阵",
                                "function getScaleMatrix(x = 1, y = 1, z = 1) {",
                                "  // prettier-ignore",
                                "  return new Float32Array([",
                                "    x  , 0.0, 0.0, 0.0,",
                                "    0.0, y  , 0.0, 0.0,",
                                "    0.0, 0.0, z  , 0.0,",
                                "    0.0, 0.0, 0.0, 1,",
                                "  ])",
                                "}",
                                "// 绕z轴旋转的旋转矩阵",
                                "function getRotateMatrix(deg) {",
                                "  // prettier-ignore",
                                "  return new Float32Array([",
                                "    Math.cos(deg),  Math.sin(deg), 0.0,0.0,",
                                "    -Math.sin(deg), Math.cos(deg), 0.0,0.0,",
                                "    0.0,            0.0,           1.0,0.0,",
                                "    0.0,            0.0,           0.0, 1,",
                                "  ])",
                                "}",
                                "",
                                "// 矩阵复合函数",
                                "function mixMatrix(A, B) {",
                                "  const result = new Float32Array(16);",
                                "",
                                "  for (let i = 0; i < 4; i++) {",
                                "    result[i] =",
                                "      A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3];",
                                "    result[i + 4] =",
                                "      A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7];",
                                "    result[i + 8] =",
                                "      A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11];",
                                "    result[i + 12] =",
                                "      A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15];",
                                "  }",
                                "",
                                "  return result;",
                                "}",
                                "",
                                "// 归一化函数",
                                "function normalized(arr) {",
                                "  let sum = 0;",
                                "",
                                "  for (let i = 0; i < arr.length; i++) {",
                                "    sum += arr[i] * arr[i];",
                                "  }",
                                "",
                                "  const middle = Math.sqrt(sum);",
                                "",
                                "  for (let i = 0; i < arr.length; i++) {",
                                "    arr[i] = arr[i] / middle;",
                                "  }",
                                "}",
                                "",
                                "// 叉积函数 获取法向量",
                                "function cross(a, b) {",
                                "  return new Float32Array([",
                                "    a[1] * b[2] - a[2] * b[1],",
                                "    a[2] * b[0] - a[0] * b[2],",
                                "    a[0] * b[1] - a[1] * b[0],",
                                "  ]);",
                                "}",
                                "",
                                "// 点积函数 获取投影长度",
                                "function dot(a, b) {",
                                "  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];",
                                "}",
                                "",
                                "// 向量差",
                                "function minus(a, b) {",
                                "  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);",
                                "}",
                                "",
                                "// 视图矩阵获取",
                                "function getViewMatrix(",
                                "  eyex,",
                                "  eyey,",
                                "  eyez,",
                                "  lookAtx,",
                                "  lookAty,",
                                "  lookAtz,",
                                "  upx,",
                                "  upy,",
                                "  upz",
                                ") {",
                                "  // 视点",
                                "  const eye = new Float32Array([eyex, eyey, eyez]);",
                                "  // 目标点",
                                "  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);",
                                "  // 上方向",
                                "  const up = new Float32Array([upx, upy, upz]);",
                                "",
                                "  // 确定z轴",
                                "  const z = minus(eye, lookAt);",
                                "",
                                "  normalized(z);",
                                "  normalized(up);",
                                "",
                                "  // 确定x轴",
                                "  const x = cross(z, up);",
                                "",
                                "  normalized(x);",
                                "  // 确定y轴",
                                "  const y = cross(x, z);",
                                "  // prettier-ignore",
                                "  return new Float32Array([",
                                "    x[0],       y[0],       z[0],       0,",
                                "    x[1],       y[1],       z[1],       0,",
                                "    x[2],       y[2],       z[2],       0,",
                                "    -dot(x,eye),-dot(y,eye),-dot(z,eye),1",
                                "  ])",
                                "}",
                                "",
                                "// 获取正射投影矩阵",
                                "function getOrtho(l, r, t, b, n, f) {",
                                "  // prettier-ignore",
                                "  return new Float32Array([",
                                "    2 / (r - l), 0,           0,           0,",
                                "    0,           2/(t-b),     0,           0,",
                                "    0,           0,           -2/(f-n),    0,",
                                "    -(r+l)/(r-l),-(t+b)/(t-b),-(f+n)/(f-n),1",
                                "  ])",
                                "}",
                                "",
                                "// 获取透视投影矩阵",
                                "function getPerspective(fov, aspect, far, near) {",
                                "  fov = (fov * Math.PI) / 180;",
                                "  // prettier-ignore",
                                "  return new Float32Array([",
                                "    1/(aspect*Math.tan(fov / 2)), 0,                   0,                      0,",
                                "    0,                            1/(Math.tan(fov/2)), 0,                      0,",
                                "    0,                            0,                   -(far+near)/(far-near), -(2*far*near)/(far-near),",
                                "    0,                            0,                   -1,                     0,",
                                "  ])",
                                "}",
                                "",
                                "function distanceSelf(a, b) {",
                                "  const x = a[0] - b[0];",
                                "  const y = a[1] - b[1];",
                                "  const z = a[2] - b[2];",
                                "",
                                "  const v = x * x + y * y + z * z;",
                                "",
                                "  return Math.sqrt(v);",
                                "}",
                                "",
                                "          }",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"8998cac0-b41c-11ee-a843-ffaa4932d416\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('8998cac0-b41c-11ee-a843-ffaa4932d416');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    uniform mat4 mat;\\n    void main() {\\n        gl_Position = mat * aPosition;\\n        gl_PointSize = 10.0;\\n    }\\n  \"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    void main() {\\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n    }\\n  \"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, \"aPosition\");",
                                "    const mat = gl.getUniformLocation(program, \"mat\");",
                                "",
                                "    const points = new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.0, 0.5]);",
                                "",
                                "    const buffer = gl.createBuffer();",
                                "",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "",
                                "    gl.enableVertexAttribArray(aPosition);",
                                "",
                                "    let eyey = -0.1;",
                                "    function animation() {",
                                "        eyey += 0.01;",
                                "        if (eyey > 1) {",
                                "            eyey = -0.1;",
                                "        }",
                                "        ",
                                "        const vm = getViewMatrix(0.0, eyey, 0.2, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0);",
                                "        const ortho = getOrtho(-1, 1, 1, -1, 0, 20);",
                                "        // const matrix = getTranslateMatrix(x, x);",
                                "        // gl.vertexAttrib1f(aTranslate, x);",
                                "        gl.uniformMatrix4fv(mat, false, mixMatrix(vm, ortho));",
                                "        gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "",
                                "        requestAnimationFrame(animation);",
                                "    }",
                                "    animation();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "javascript",
            "source": [
                ""
            ],
            "outputs": []
        }
    ]
}