{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "### 1 图形平移\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "平移矩阵的推导过程\r\n\r\n![矩阵平移](./img/image-16.png)\r\n\r\n首先，定义平移变换的基本公式为：\r\n\r\n$ x' = x + x_1 $\r\n\r\n$ y' = y + y_1 $\r\n\r\n$ z' = z + z_1 $\r\n\r\n$ w = 1 $\r\n\r\n这里 $ w $ 是齐次坐标的一部分，使得变换可以用矩阵乘法表示。\r\n\r\n接着，我们将这些变换映射到齐次坐标系中的矩阵变换中：\r\n\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz \\\\\r\nw\r\n\\end{bmatrix}\r\n$ *\r\n$\r\n\\begin{bmatrix}\r\na & b & c & d \\\\\r\ne & f & g & h \\\\\r\ni & j & k & l \\\\\r\nm & n & o & p\r\n\\end{bmatrix}\r\n$ =\r\n$\r\n\\begin{bmatrix}\r\nx' \\\\\r\ny' \\\\\r\nz' \\\\\r\nw'\r\n\\end{bmatrix}\r\n$\r\n\r\n$ ax + by + cz + dw = x' $\r\n\r\n$ ex + fy + gz + hw = y' $\r\n\r\n$ ix + jy + kz + lw = z' $\r\n\r\n$ mx + ny + oz + pw = w' $\r\n\r\n通过代入 $ x', y', z', w $ 的定义，我们可以解出矩阵的各个元素：\r\n\r\n1. 代入 $ x' = x + x_1 $ 到 $ ax + by + cz + dw = x' $ 得到 $ a = 1, b = 0, c = 0, d = x_1 $。\r\n2. 代入 $ y' = y + y_1 $ 到 $ ex + fy + gz + hw = y' $ 得到 $ e = 0, f = 1, g = 0, h = y_1 $。\r\n3. 代入 $ z' = z + z_1 $ 到 $ ix + jy + kz + lw = z' $ 得到 $ i = 0, j = 0, k = 1, l = z_1 $。\r\n4. 由于 $ w $ 始终为 1，所以 $ mx + ny + oz + pw = w' $ 得到 $ 0x + 0y + 0z + 1w = 1 $。\r\n\r\n因此，整个平移变换的齐次坐标矩阵是：\r\n\r\n$\r\n\\begin{pmatrix}\r\n1 & 0 & 0 & x_1 \\\\\r\n0 & 1 & 0 & y_1 \\\\\r\n0 & 0 & 1 & z_1 \\\\\r\n0 & 0 & 0 & 1\r\n\\end{pmatrix}\r\n$\r\n\r\n在数学中矩阵的表示是行主序的 就如上面得到的矩阵一样\r\n\r\n但是在 webgl 中因为一些历史问题需要换成列主序\r\n\r\n行主序换成列主序 具体做法是交换矩阵的行和列 即矩阵转置\r\n\r\n转置后的列主序矩阵如下\r\n\r\n$\r\n\\begin{pmatrix}\r\n1 & 0 & 0 & 0 \\\\\r\n0 & 1 & 0 & 0 \\\\\r\n0 & 0 & 1 & 0 \\\\\r\nx_1 & y_1 & z_1 & 1\r\n\\end{pmatrix}\r\n$\r\n\r\njs实现\r\n\r\n```js\r\n  // 平移矩阵\r\n  function getTranslateMatrix(x = 0,y = 0,z = 0) {\r\n    return new Float32Array([\r\n      1.0,0.0,0.0,0.0,\r\n      0.0,1.0,0.0,0.0,\r\n      0.0,0.0,1.0,0.0,\r\n        x,  y,  z,  1,\r\n    ])\r\n  }\r\n\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "平移矩阵的应用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n  attribute vec4 aPosition;\r\n  uniform mat4 mat;\r\n  void main() {\r\n    gl_Position = mat * aPosition;\r\n    gl_PointSize = 10.0;\r\n  }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n  void main() {\r\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n  }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n  const points = new Float32Array([\r\n    -0.5, -0.5,\r\n    0.5, -0.5,\r\n    0.0,  0.5,\r\n  ]);\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition);\r\n  let x = -1;\r\n  function animation() {\r\n    x += 0.01;\r\n    if (x > 1) x = -1;\r\n    const matrix = getTranslateMatrix(x, x);\r\n    gl.uniformMatrix4fv(mat, false, matrix);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\r\n    requestAnimationFrame(animation);\r\n  }\r\n  animation();\r\n`;\r\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require('path');\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code, libs);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          { // 限制变量定义域",
                                "              function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {\r",
                                "  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r",
                                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r",
                                "\r",
                                "  gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE); // 指定顶点着色器的源码\r",
                                "  gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE); // 指定片元着色器的源码\r",
                                "\r",
                                "  // 编译着色器\r",
                                "  gl.compileShader(vertexShader);\r",
                                "  gl.compileShader(fragmentShader);\r",
                                "\r",
                                "  // 创建一个程序对象\r",
                                "  const program = gl.createProgram();\r",
                                "\r",
                                "  gl.attachShader(program, vertexShader);\r",
                                "  gl.attachShader(program, fragmentShader);\r",
                                "\r",
                                "  gl.linkProgram(program);\r",
                                "\r",
                                "  gl.useProgram(program);\r",
                                "\r",
                                "  return program;\r",
                                "}\r",
                                "\r",
                                "// 平移矩阵\r",
                                "function getTranslateMatrix(x = 0, y = 0, z = 0) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1.0, 0.0, 0.0, 0.0,\r",
                                "    0.0, 1.0, 0.0, 0.0,\r",
                                "    0.0, 0.0, 1.0, 0.0,\r",
                                "    x  , y  , z  , 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 缩放矩阵\r",
                                "function getScaleMatrix(x = 1, y = 1, z = 1) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x  , 0.0, 0.0, 0.0,\r",
                                "    0.0, y  , 0.0, 0.0,\r",
                                "    0.0, 0.0, z  , 0.0,\r",
                                "    0.0, 0.0, 0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 绕z轴旋转的旋转矩阵\r",
                                "function getRotateMatrix(deg) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    Math.cos(deg),  Math.sin(deg), 0.0,0.0,\r",
                                "    -Math.sin(deg), Math.cos(deg), 0.0,0.0,\r",
                                "    0.0,            0.0,           1.0,0.0,\r",
                                "    0.0,            0.0,           0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 矩阵复合函数\r",
                                "function mixMatrix(A, B) {\r",
                                "  const result = new Float32Array(16);\r",
                                "\r",
                                "  for (let i = 0; i < 4; i++) {\r",
                                "    result[i] =\r",
                                "      A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3];\r",
                                "    result[i + 4] =\r",
                                "      A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7];\r",
                                "    result[i + 8] =\r",
                                "      A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11];\r",
                                "    result[i + 12] =\r",
                                "      A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15];\r",
                                "  }\r",
                                "\r",
                                "  return result;\r",
                                "}\r",
                                "\r",
                                "// 归一化函数\r",
                                "function normalized(arr) {\r",
                                "  let sum = 0;\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    sum += arr[i] * arr[i];\r",
                                "  }\r",
                                "\r",
                                "  const middle = Math.sqrt(sum);\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    arr[i] = arr[i] / middle;\r",
                                "  }\r",
                                "}\r",
                                "\r",
                                "// 叉积函数 获取法向量\r",
                                "function cross(a, b) {\r",
                                "  return new Float32Array([\r",
                                "    a[1] * b[2] - a[2] * b[1],\r",
                                "    a[2] * b[0] - a[0] * b[2],\r",
                                "    a[0] * b[1] - a[1] * b[0],\r",
                                "  ]);\r",
                                "}\r",
                                "\r",
                                "// 点积函数 获取投影长度\r",
                                "function dot(a, b) {\r",
                                "  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r",
                                "}\r",
                                "\r",
                                "// 向量差\r",
                                "function minus(a, b) {\r",
                                "  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);\r",
                                "}\r",
                                "\r",
                                "// 视图矩阵获取\r",
                                "function getViewMatrix(\r",
                                "  eyex,\r",
                                "  eyey,\r",
                                "  eyez,\r",
                                "  lookAtx,\r",
                                "  lookAty,\r",
                                "  lookAtz,\r",
                                "  upx,\r",
                                "  upy,\r",
                                "  upz\r",
                                ") {\r",
                                "  // 视点\r",
                                "  const eye = new Float32Array([eyex, eyey, eyez]);\r",
                                "  // 目标点\r",
                                "  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\r",
                                "  // 上方向\r",
                                "  const up = new Float32Array([upx, upy, upz]);\r",
                                "\r",
                                "  // 确定z轴\r",
                                "  const z = minus(eye, lookAt);\r",
                                "\r",
                                "  normalized(z);\r",
                                "  normalized(up);\r",
                                "\r",
                                "  // 确定x轴\r",
                                "  const x = cross(z, up);\r",
                                "\r",
                                "  normalized(x);\r",
                                "  // 确定y轴\r",
                                "  const y = cross(x, z);\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x[0],       y[0],       z[0],       0,\r",
                                "    x[1],       y[1],       z[1],       0,\r",
                                "    x[2],       y[2],       z[2],       0,\r",
                                "    -dot(x,eye),-dot(y,eye),-dot(z,eye),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取正射投影矩阵\r",
                                "function getOrtho(l, r, t, b, n, f) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    2 / (r - l), 0,           0,           0,\r",
                                "    0,           2/(t-b),     0,           0,\r",
                                "    0,           0,           -2/(f-n),    0,\r",
                                "    -(r+l)/(r-l),-(t+b)/(t-b),-(f+n)/(f-n),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取透视投影矩阵\r",
                                "function getPerspective(fov, aspect, far, near) {\r",
                                "  fov = (fov * Math.PI) / 180;\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1/(aspect*Math.tan(fov / 2)), 0,                   0,                      0,\r",
                                "    0,                            1/(Math.tan(fov/2)), 0,                      0,\r",
                                "    0,                            0,                   -(far+near)/(far-near), -(2*far*near)/(far-near),\r",
                                "    0,                            0,                   -1,                     0,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "function distanceSelf(a, b) {\r",
                                "  const x = a[0] - b[0];\r",
                                "  const y = a[1] - b[1];\r",
                                "  const z = a[2] - b[2];\r",
                                "\r",
                                "  const v = x * x + y * y + z * z;\r",
                                "\r",
                                "  return Math.sqrt(v);\r",
                                "}\r",
                                "",
                                "          }",
                                "      </script>",
                                "  ",
                                "      <script>",
                                "          ",
                                "  // 平移矩阵",
                                "  function getTranslateMatrix(x = 0,y = 0,z = 0) {",
                                "    return new Float32Array([",
                                "      1.0,0.0,0.0,0.0,",
                                "      0.0,1.0,0.0,0.0,",
                                "      0.0,0.0,1.0,0.0,",
                                "        x,  y,  z,  1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"897d5530-bf2d-11ee-9e26-7f5748262c74\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('897d5530-bf2d-11ee-9e26-7f5748262c74');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  uniform mat4 mat;\\n  void main() {\\n    gl_Position = mat * aPosition;\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "  const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "  ]);",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition);",
                                "  let x = -1;",
                                "  function animation() {",
                                "    x += 0.01;",
                                "    if (x > 1) x = -1;",
                                "    const matrix = getTranslateMatrix(x, x);",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "    requestAnimationFrame(animation);",
                                "  }",
                                "  animation();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 2 图形缩放"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "缩放矩阵推导过程\r\n\r\n![Alt text](./img/image-19.png)\r\n\r\n首先，定义平移变换的基本公式为：\r\n\r\n$ x' = Tx * x $\r\n\r\n$ y' = Ty * y $\r\n\r\n$ z' = Tz * z $\r\n\r\n$ w = 1 $\r\n\r\n这里 $ w $ 是齐次坐标的一部分，使得变换可以用矩阵乘法表示。\r\n\r\n接着，我们将这些变换映射到齐次坐标系中的矩阵变换中：\r\n\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz \\\\\r\nw\r\n\\end{bmatrix}\r\n$ *\r\n$\r\n\\begin{bmatrix}\r\na & b & c & d \\\\\r\ne & f & g & h \\\\\r\ni & j & k & l \\\\\r\nm & n & o & p\r\n\\end{bmatrix}\r\n$ =\r\n$\r\n\\begin{bmatrix}\r\nx' \\\\\r\ny' \\\\\r\nz' \\\\\r\nw'\r\n\\end{bmatrix}\r\n$\r\n\r\n$ ax + by + cz + dw = x' $\r\n\r\n$ ex + fy + gz + hw = y' $\r\n\r\n$ ix + jy + kz + lw = z' $\r\n\r\n$ mx + ny + oz + pw = w' $\r\n\r\n通过代入 $ x', y', z', w $ 的定义，我们可以解出矩阵的各个元素：\r\n\r\n1. 代入 $ x' = Tx * x $ 到 $ ax + by + cz + dw = x' $ 得到 $ a = Tx, b = 0, c = 0, d = 0 $。\r\n2. 代入 $ y' = Ty * y $ 到 $ ex + fy + gz + hw = y' $ 得到 $ e = 0, f = Ty, g = 0, h = 0 $。\r\n3. 代入 $ z' = Tz * z $ 到 $ ix + jy + kz + lw = z' $ 得到 $ i = 0, j = 0, k = Tz, l = 0 $。\r\n4. 由于 $ w $ 始终为 1, 故 $ mx + ny + oz + pw = w' $ 得到 $ p = 1 $。\r\n\r\n因此，整个平移变换的齐次坐标矩阵是：\r\n\r\n$\r\n\\begin{pmatrix}\r\nTx & 0 & 0 & x_1 \\\\\r\n0 & Ty & 0 & y_1 \\\\\r\n0 & 0 & Tz & z_1 \\\\\r\n0 & 0 & 0 & 1\r\n\\end{pmatrix}\r\n$\r\n\r\n这是一个对称矩阵 列主序与行主序一致\r\n\r\njs代码实现缩放矩阵\r\n\r\n```js\r\n// 缩放矩阵\r\nfunction getScaleMatrix(tx = 1, ty = 1, tz = 1) {\r\n  return new Float32Array([\r\n    tx, 0.0, 0.0, 0.0,\r\n    0.0, ty, 0.0, 0.0,\r\n    0.0, 0.0, tz, 0.0,\r\n    0.0, 0.0, 0.0, 1,\r\n  ])\r\n}\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "缩放矩阵的应用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// 着色器\r\n// 创建着色器源码\r\nconst vertex_code = /*glsl */ `\r\n  attribute vec4 aPosition;\r\n  uniform mat4 mat;\r\n  void main() {\r\n    gl_Position = mat * aPosition;\r\n    gl_PointSize = 10.0;\r\n  }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n  void main() {\r\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n  }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n  const points = new Float32Array([\r\n    -0.5, -0.5,\r\n    0.5, -0.5,\r\n    0.0,  0.5,\r\n  ])\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n  let x = 0.1;\r\n  function animation() {\r\n    x += 0.01;\r\n    if (x > 1.5) x = 0.1;\r\n    const matrix = getScaleMatrix(x, x);\r\n    // 参数 location transpose array\r\n    gl.uniformMatrix4fv(mat, false, matrix);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\r\n    requestAnimationFrame(animation);\r\n  }\r\n  animation();\r\n`;\r\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require('path');\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          ",
                                "  // 平移矩阵",
                                "  function getTranslateMatrix(x = 0,y = 0,z = 0) {",
                                "    return new Float32Array([",
                                "      1.0,0.0,0.0,0.0,",
                                "      0.0,1.0,0.0,0.0,",
                                "      0.0,0.0,1.0,0.0,",
                                "        x,  y,  z,  1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"96189110-bf2d-11ee-9e26-7f5748262c74\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('96189110-bf2d-11ee-9e26-7f5748262c74');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  uniform mat4 mat;\\n  void main() {\\n    gl_Position = mat * aPosition;\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "  const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "  ])",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  let x = 0.1;",
                                "  function animation() {",
                                "    x += 0.01;",
                                "    if (x > 1.5) x = 0.1;",
                                "    const matrix = getScaleMatrix(x, x);",
                                "    // 参数 location transpose array",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "    requestAnimationFrame(animation);",
                                "  }",
                                "  animation();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 3 图形旋转"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "旋转矩阵的推导过程 我们先探讨围绕z轴旋转的情况\r\n\r\n![Alt text](./img/image-20.png)\r\n\r\n顶点 A (x, y)\r\n\r\n$ x = R * cos(α) $\r\n\r\n$ y = R * sin(α) $\r\n\r\n$ z = 0 $\r\n\r\n顶点 A' (x', y')\r\n\r\n$$\r\n\\begin{align*}\r\n&x' = R * \\cos(α + β) \\\\\r\n&\\phantom{x'} = R * ( \\cos(α)*\\cos(β) - \\sin(α)*\\sin(β)) \\\\\r\n&\\phantom{x'} = R*\\cos(α)*\\cos(β) - R*\\sin(α)*\\sin(β) \\\\\r\n&将顶点A带入 \\\\\r\n&\\phantom{x'} = x*\\cos(β) - y*\\sin(β)\r\n\\end{align*}\r\n$$\r\n\r\n$$\r\n\\begin{align*}\r\n&y' = R * \\sin(α + β) \\\\\r\n&\\phantom{y'} = R * ( \\cos(β)*\\cos(α) + \\cos(α)*\\sin(β)) \\\\\r\n&\\phantom{y'} = R * \\sin(α)*\\cos(β) + R*\\cos(α)*\\sin(β) \\\\\r\n&将顶点A带入 \\\\\r\n&\\phantom{y'} = y*\\cos(β) - x*\\sin(β)\r\n\\end{align*}\r\n$$\r\n\r\n$$\r\nz' = z\r\n$$\r\n\r\n\r\n$ ax + by + cz + dw = x' $\r\n\r\n$ ex + fy + gz + hw = y' $\r\n\r\n$ ix + jy + kz + lw = z' $\r\n\r\n$ mx + ny + oz + pw = w' $\r\n\r\n得到矩阵\r\n\r\n绕z轴的旋转矩阵\r\n$\r\n\\begin{pmatrix}\r\n    \\cos(β) & \\sin(β) & 0 & 0 \\\\\r\n    \\sin(β) & \\cos(β) & 0 & 0 \\\\\r\n    0       & 0       & 1 & 0 \\\\\r\n    0       & 0       & 0 & 1\\\\\r\n\\end{pmatrix}\r\n$\r\n\r\n可以看出来绕z轴即z轴的内容不变（第三行和第三列的内容不变）\r\n\r\n类似地 得出其余两轴的旋转矩阵\r\n\r\n绕y轴的旋转矩阵\r\n$\r\n\\begin{pmatrix}\r\n    \\cos(β) & 0 & \\sin(β) & 0 \\\\\r\n    0       & 1 & 0       & 0 \\\\\r\n    \\sin(β) & 1 & \\cos(β) & 0 \\\\\r\n    0       & 0 & 0       & 1 \\\\\r\n\\end{pmatrix}\r\n$\r\n\r\n绕x轴的旋转矩阵\r\n$\r\n\\begin{pmatrix}\r\n    1 & 0       & 0       & 0 \\\\\r\n    0 & \\cos(β) & \\sin(β) & 0 \\\\\r\n    0 & \\sin(β) & \\cos(β) & 0 \\\\\r\n    0 & 0       & 0       & 0 \\\\\r\n\\end{pmatrix}\r\n$\r\n\r\njs 实现\r\n\r\n```js\r\n  // 绕z轴旋转的旋转矩阵\r\n  function getRotateMatrix(deg) {\r\n    return new Float32Array([\r\n      Math.cos(deg),  Math.sin(deg) ,0.0,0.0,\r\n      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,\r\n      0.0,            0.0,            1.0,0.0,\r\n      0.0,            0.0,            0.0, 1,\r\n    ])\r\n  }\r\n\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "旋转矩阵的应用\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n  attribute vec4 aPosition;\r\n  uniform mat4 mat;\r\n  void main() {\r\n    gl_Position = mat * aPosition;\r\n    gl_PointSize = 10.0;\r\n  }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n  void main() {\r\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n  }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n  const points = new Float32Array([\r\n    -0.5, -0.5,\r\n    0.5, -0.5,\r\n    0.0,  0.5,\r\n  ])\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n  \r\n  let x = 0;\r\n  function animation() {\r\n    x += 0.01;\r\n    const matrix = getRotateMatrix(x);\r\n    // gl.vertexAttrib1f(aTranslate, x);\r\n    gl.uniformMatrix4fv(mat, false, matrix);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\r\n    requestAnimationFrame(animation);\r\n  }\r\n  animation()\r\n`;\r\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require('path');\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code, libs);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          ",
                                "  // 视图矩阵获取",
                                "  function getViewMatrix(",
                                "    eyex,",
                                "    eyey,",
                                "    eyez,",
                                "    lookAtx,",
                                "    lookAty,",
                                "    lookAtz,",
                                "    upx,",
                                "    upy,",
                                "    upz",
                                "  ) {",
                                "    // 视点",
                                "    const eye = new Float32Array([eyex, eyey, eyez]);",
                                "    // 目标点",
                                "    const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);",
                                "    // 上方向",
                                "    const up = new Float32Array([upx, upy, upz]);",
                                "",
                                "    // 确定z轴",
                                "    const z = minus(eye, lookAt);",
                                "",
                                "    normalized(z);",
                                "    normalized(up);",
                                "",
                                "    // 确定x轴",
                                "    const x = cross(z, up);",
                                "",
                                "    normalized(x);",
                                "    // 确定y轴",
                                "    const y = cross(x, z);",
                                "    // prettier-ignore",
                                "    return new Float32Array([",
                                "      x[0],       y[0],       z[0],       0,",
                                "      x[1],       y[1],       z[1],       0,",
                                "      x[2],       y[2],       z[2],       0,",
                                "      -dot(x,eye),-dot(y,eye),-dot(z,eye),1",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 绕z轴旋转的旋转矩阵",
                                "  function getRotateMatrix(deg) {",
                                "    return new Float32Array([",
                                "      Math.cos(deg),  Math.sin(deg) ,0.0,0.0,",
                                "      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "      0.0,            0.0,            1.0,0.0,",
                                "      0.0,            0.0,            0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 缩放矩阵",
                                "  function getScaleMatrix(tx = 1, ty = 1, tz = 1) {",
                                "    return new Float32Array([",
                                "      tx, 0.0, 0.0, 0.0,",
                                "      0.0, ty, 0.0, 0.0,",
                                "      0.0, 0.0, tz, 0.0,",
                                "      0.0, 0.0, 0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 绕z轴旋转的旋转矩阵",
                                "  function getRotateMatrix(deg) {",
                                "    return new Float32Array([",
                                "      Math.cos(deg),  -Math.sin(deg) ,0.0,0.0,",
                                "      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "      0.0,            0.0,            1.0,0.0,",
                                "      0.0,            0.0,            0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "",
                                "      <script>",
                                "          ",
                                "  // 绕z轴旋转的旋转矩阵",
                                "  function getRotateMatrix(deg) {",
                                "    return new Float32Array([",
                                "      Math.cos(deg),  Math.sin(deg) ,0.0,0.0,",
                                "      -Math.sin(deg)  ,Math.cos(deg) ,0.0,0.0,",
                                "      0.0,            0.0,            1.0,0.0,",
                                "      0.0,            0.0,            0.0, 1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"7e6eaaf0-b5a4-11ee-b32f-57ef30c77b2d\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('7e6eaaf0-b5a4-11ee-b32f-57ef30c77b2d');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  uniform mat4 mat;\\n  void main() {\\n    gl_Position = mat * aPosition;\\n    gl_PointSize = 10.0;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "  const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "  ])",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  ",
                                "  let x = 0;",
                                "  function animation() {",
                                "    x += 0.01;",
                                "    const matrix = getRotateMatrix(x);",
                                "    // gl.vertexAttrib1f(aTranslate, x);",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "    requestAnimationFrame(animation);",
                                "  }",
                                "  animation()",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 4 矩阵复合\r\n\r\n矩阵 A * 矩阵 B 表示先进行 B 变换再进行 A 变换\r\n\r\n![矩阵乘法](./img/image-21.png)\r\n\r\njs实现\r\n\r\n```js\r\n  function mixMatrix(A, B) {\r\n    const result = new Float32Array(16);\r\n    for (let i = 0; i < 4; i++) {\r\n      result[i] = A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3]\r\n      result[i + 4] = A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7]\r\n      result[i + 8] = A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11]\r\n      result[i + 12] = A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15]\r\n    }\r\n    return result;\r\n  }\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n  attribute vec4 aPosition;\r\n  uniform mat4 mat;\r\n  void main() {\r\n    gl_Position = mat * aPosition;\r\n  }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n  void main() {\r\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n  }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n  const points = new Float32Array([\r\n    -0.5, -0.5,\r\n    0.5, -0.5,\r\n    0.0,  0.5,\r\n  ])\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n  let deg = 0;\r\n  let translateX = -1;\r\n  let scaleX = 0.1;\r\n  function animation() {\r\n    deg += 0.01;\r\n    translateX += 0.01;\r\n    scaleX += 0.01;\r\n    if (translateX > 1) translateX = -1;\r\n    if (scaleX > 1.5)  scaleX = 0.1;\r\n    const translate = getTranslateMatrix(translateX);\r\n    const scale = getScaleMatrix(scaleX);\r\n    const rotate = getRotateMatrix(deg);\r\n    const matrix = mixMatrix(mixMatrix(translate, scale), rotate);\r\n    gl.uniformMatrix4fv(mat, false, matrix);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\r\n    requestAnimationFrame(animation);\r\n  }\r\n  animation()\r\n`;\r\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require('path');\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code, libs);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          { // 限制变量定义域",
                                "              function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {\r",
                                "  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r",
                                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r",
                                "\r",
                                "  gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE); // 指定顶点着色器的源码\r",
                                "  gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE); // 指定片元着色器的源码\r",
                                "\r",
                                "  // 编译着色器\r",
                                "  gl.compileShader(vertexShader);\r",
                                "  gl.compileShader(fragmentShader);\r",
                                "\r",
                                "  // 创建一个程序对象\r",
                                "  const program = gl.createProgram();\r",
                                "\r",
                                "  gl.attachShader(program, vertexShader);\r",
                                "  gl.attachShader(program, fragmentShader);\r",
                                "\r",
                                "  gl.linkProgram(program);\r",
                                "\r",
                                "  gl.useProgram(program);\r",
                                "\r",
                                "  return program;\r",
                                "}\r",
                                "\r",
                                "// 平移矩阵\r",
                                "function getTranslateMatrix(x = 0, y = 0, z = 0) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1.0, 0.0, 0.0, 0.0,\r",
                                "    0.0, 1.0, 0.0, 0.0,\r",
                                "    0.0, 0.0, 1.0, 0.0,\r",
                                "    x  , y  , z  , 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 缩放矩阵\r",
                                "function getScaleMatrix(x = 1, y = 1, z = 1) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x  , 0.0, 0.0, 0.0,\r",
                                "    0.0, y  , 0.0, 0.0,\r",
                                "    0.0, 0.0, z  , 0.0,\r",
                                "    0.0, 0.0, 0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 绕z轴旋转的旋转矩阵\r",
                                "function getRotateMatrix(deg) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    Math.cos(deg),  Math.sin(deg), 0.0,0.0,\r",
                                "    -Math.sin(deg), Math.cos(deg), 0.0,0.0,\r",
                                "    0.0,            0.0,           1.0,0.0,\r",
                                "    0.0,            0.0,           0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 矩阵复合函数\r",
                                "function mixMatrix(A, B) {\r",
                                "  const result = new Float32Array(16);\r",
                                "\r",
                                "  for (let i = 0; i < 4; i++) {\r",
                                "    result[i] =\r",
                                "      A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3];\r",
                                "    result[i + 4] =\r",
                                "      A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7];\r",
                                "    result[i + 8] =\r",
                                "      A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11];\r",
                                "    result[i + 12] =\r",
                                "      A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15];\r",
                                "  }\r",
                                "\r",
                                "  return result;\r",
                                "}\r",
                                "\r",
                                "// 归一化函数\r",
                                "function normalized(arr) {\r",
                                "  let sum = 0;\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    sum += arr[i] * arr[i];\r",
                                "  }\r",
                                "\r",
                                "  const middle = Math.sqrt(sum);\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    arr[i] = arr[i] / middle;\r",
                                "  }\r",
                                "}\r",
                                "\r",
                                "// 叉积函数 获取法向量\r",
                                "function cross(a, b) {\r",
                                "  return new Float32Array([\r",
                                "    a[1] * b[2] - a[2] * b[1],\r",
                                "    a[2] * b[0] - a[0] * b[2],\r",
                                "    a[0] * b[1] - a[1] * b[0],\r",
                                "  ]);\r",
                                "}\r",
                                "\r",
                                "// 点积函数 获取投影长度\r",
                                "function dot(a, b) {\r",
                                "  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r",
                                "}\r",
                                "\r",
                                "// 向量差\r",
                                "function minus(a, b) {\r",
                                "  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);\r",
                                "}\r",
                                "\r",
                                "// 视图矩阵获取\r",
                                "function getViewMatrix(\r",
                                "  eyex,\r",
                                "  eyey,\r",
                                "  eyez,\r",
                                "  lookAtx,\r",
                                "  lookAty,\r",
                                "  lookAtz,\r",
                                "  upx,\r",
                                "  upy,\r",
                                "  upz\r",
                                ") {\r",
                                "  // 视点\r",
                                "  const eye = new Float32Array([eyex, eyey, eyez]);\r",
                                "  // 目标点\r",
                                "  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\r",
                                "  // 上方向\r",
                                "  const up = new Float32Array([upx, upy, upz]);\r",
                                "\r",
                                "  // 确定z轴\r",
                                "  const z = minus(eye, lookAt);\r",
                                "\r",
                                "  normalized(z);\r",
                                "  normalized(up);\r",
                                "\r",
                                "  // 确定x轴\r",
                                "  const x = cross(z, up);\r",
                                "\r",
                                "  normalized(x);\r",
                                "  // 确定y轴\r",
                                "  const y = cross(x, z);\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x[0],       y[0],       z[0],       0,\r",
                                "    x[1],       y[1],       z[1],       0,\r",
                                "    x[2],       y[2],       z[2],       0,\r",
                                "    -dot(x,eye),-dot(y,eye),-dot(z,eye),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取正射投影矩阵\r",
                                "function getOrtho(l, r, t, b, n, f) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    2 / (r - l), 0,           0,           0,\r",
                                "    0,           2/(t-b),     0,           0,\r",
                                "    0,           0,           -2/(f-n),    0,\r",
                                "    -(r+l)/(r-l),-(t+b)/(t-b),-(f+n)/(f-n),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取透视投影矩阵\r",
                                "function getPerspective(fov, aspect, far, near) {\r",
                                "  fov = (fov * Math.PI) / 180;\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1/(aspect*Math.tan(fov / 2)), 0,                   0,                      0,\r",
                                "    0,                            1/(Math.tan(fov/2)), 0,                      0,\r",
                                "    0,                            0,                   -(far+near)/(far-near), -(2*far*near)/(far-near),\r",
                                "    0,                            0,                   -1,                     0,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "function distanceSelf(a, b) {\r",
                                "  const x = a[0] - b[0];\r",
                                "  const y = a[1] - b[1];\r",
                                "  const z = a[2] - b[2];\r",
                                "\r",
                                "  const v = x * x + y * y + z * z;\r",
                                "\r",
                                "  return Math.sqrt(v);\r",
                                "}\r",
                                "",
                                "          }",
                                "      </script>",
                                "  ",
                                "      <script>",
                                "          ",
                                "  // 平移矩阵",
                                "  function getTranslateMatrix(x = 0,y = 0,z = 0) {",
                                "    return new Float32Array([",
                                "      1.0,0.0,0.0,0.0,",
                                "      0.0,1.0,0.0,0.0,",
                                "      0.0,0.0,1.0,0.0,",
                                "        x,  y,  z,  1,",
                                "    ])",
                                "  }",
                                "",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"9bc40620-bf2e-11ee-9e26-7f5748262c74\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('9bc40620-bf2e-11ee-9e26-7f5748262c74');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n  attribute vec4 aPosition;\\n  uniform mat4 mat;\\n  void main() {\\n    gl_Position = mat * aPosition;\\n  }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  void main() {\\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "  const points = new Float32Array([",
                                "    -0.5, -0.5,",
                                "    0.5, -0.5,",
                                "    0.0,  0.5,",
                                "  ])",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  let deg = 0;",
                                "  let translateX = -1;",
                                "  let scaleX = 0.1;",
                                "  function animation() {",
                                "    deg += 0.01;",
                                "    translateX += 0.01;",
                                "    scaleX += 0.01;",
                                "    if (translateX > 1) translateX = -1;",
                                "    if (scaleX > 1.5)  scaleX = 0.1;",
                                "    const translate = getTranslateMatrix(translateX);",
                                "    const scale = getScaleMatrix(scaleX);",
                                "    const rotate = getRotateMatrix(deg);",
                                "    const matrix = mixMatrix(mixMatrix(translate, scale), rotate);",
                                "    gl.uniformMatrix4fv(mat, false, matrix);",
                                "    gl.drawArrays(gl.TRIANGLES, 0, 3);",
                                "    requestAnimationFrame(animation);",
                                "  }",
                                "  animation()",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 5 视图矩阵\r\n![](2024-01-13-16-20-57.png)\r\n\r\n![Alt text](./img/image-26.png)\r\n\r\n假设视点为eye(x,y,z)\r\n根据前面推导的平移矩阵得，从视点移动到坐标原点的变换矩阵为\r\n\r\n$\r\n\\begin{pmatrix}\r\n1 & 0 & 0 & -eye.x \\\\\r\n0 & 1 & 0 & -eye.y \\\\\r\n0 & 0 & 1 & -eye.z \\\\\r\n0 & 0 & 0 & 1\r\n\\end{pmatrix}\r\n$\r\n\r\n由视点和朝向确定z的方向\r\n\r\n由z方向和上方向确定x方向\r\n\r\n已知一组新的正交基的情况下直接用这组新的正交基构造基于旧基的旋转矩阵如下\r\n\r\n$\r\n\\begin{pmatrix}\r\nx[0] & x[1] & x[2] & 0 \\\\\r\ny[0] & y[1] & y[2] & 0 \\\\\r\nz[0] & z[1] & z[2] & 0 \\\\\r\n0 & 0 & 0 & 1\r\n\\end{pmatrix}\r\n$\r\n\r\n$\r\n\\begin{pmatrix}\r\n1 & 0 & 0 & -eye.x \\\\\r\n0 & 1 & 0 & -eye.y \\\\\r\n0 & 0 & 1 & -eye.z \\\\\r\n0 & 0 & 0 & 1\r\n\\end{pmatrix} \r\n$ * \r\n$\r\n\\begin{pmatrix}\r\nx[0] & x[1] & x[2] & 0 \\\\\r\ny[0] & y[1] & y[2] & 0 \\\\\r\nz[0] & z[1] & z[2] & 0 \\\\\r\n0 & 0 & 0 & 1\r\n\\end{pmatrix}\r\n$ = \r\n$\r\n\\begin{pmatrix}\r\nx[0] & x[1] & x[2] & -eye \\cdot x \\\\\r\ny[0] & y[1] & y[2] & -eye \\cdot y \\\\\r\nz[0] & z[1] & z[2] & -eye \\cdot z \\\\\r\n0 & 0 & 0 & 1\r\n\\end{pmatrix}\r\n$\r\n\r\n\r\n\r\n转换成列主序\r\n\r\n$\r\n\\begin{pmatrix}\r\nx[0] & y[0] & z[0] & 0 \\\\\r\nx[1] & y[1] & z[1] & 0 \\\\\r\nx[2] & y[2] & z[2] & 0 \\\\\r\n-eye \\cdot x & -eye \\cdot y & -eye \\cdot z & 1\r\n\\end{pmatrix}\r\n$\r\n\r\n\r\n```js\r\n\r\n// 归一化函数\r\nfunction normalized(arr) {\r\n  let sum = 0;\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    sum += arr[i] * arr[i];\r\n  }\r\n\r\n  const middle = Math.sqrt(sum);\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    arr[i] = arr[i] / middle;\r\n  }\r\n}\r\n\r\n// 叉积函数 获取法向量\r\nfunction cross(a, b) {\r\n  return new Float32Array([\r\n    a[1] * b[2] - a[2] * b[1],\r\n    a[2] * b[0] - a[0] * b[2],\r\n    a[0] * b[1] - a[1] * b[0],\r\n  ]);\r\n}\r\n\r\n// 点积函数 获取投影长度\r\nfunction dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n}\r\n\r\n// 向量差\r\nfunction minus(a, b) {\r\n  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);\r\n}\r\n\r\n// 视图矩阵获取\r\nfunction getViewMatrix(\r\n  eyex,\r\n  eyey,\r\n  eyez,\r\n  lookAtx,\r\n  lookAty,\r\n  lookAtz,\r\n  upx,\r\n  upy,\r\n  upz\r\n) {\r\n  // 视点\r\n  const eye = new Float32Array([eyex, eyey, eyez]);\r\n  // 目标点\r\n  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\r\n  // 上方向\r\n  const up = new Float32Array([upx, upy, upz]);\r\n\r\n  // 确定z轴\r\n  const z = minus(eye, lookAt);\r\n\r\n  normalized(z);\r\n  normalized(up);\r\n\r\n  // 确定x轴\r\n  const x = cross(z, up);\r\n\r\n  normalized(x);\r\n  // 确定y轴\r\n  const y = cross(x, z);\r\n  // prettier-ignore\r\n  return new Float32Array([\r\n    x[0],       y[0],       z[0],       0,\r\n    x[1],       y[1],       z[1],       0,\r\n    x[2],       y[2],       z[2],       0,\r\n    -dot(x,eye),-dot(y,eye),-dot(z,eye),1\r\n  ])\r\n}\r\n\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 6 正射投影矩阵\r\n\r\n\r\n正射投影是所有的物体投影线都垂直于最终的绘图表面\r\n\r\n![](./img/2024-01-13-16-25-37.png)\r\n\r\n先尝试将x转换到x'\r\n对于左右区间 有`-1 < x' < 1` 以及`l < x < r`\r\n将x的不等式的左右两边也转化成 (-1, 1)  具体过程如下\r\n\r\n$ 1 < x < r $\r\n\r\n先将左端变为0\r\n\r\n$ 0 < x - l < r - l $\r\n\r\n转换到[0, 2]\r\n\r\n$ 0 < \\frac{2x-2l}{r-l} < 2 $\r\n\r\n转换到[-1, 1]\r\n\r\n$ -1 < \\frac{2x-2l}{r-l} -1 < 1 $\r\n\r\n$ -1 < \\frac{2x-2l}{r-l} - \\frac{r-l}{r-l} < 1 $\r\n\r\n$ -1 < \\frac{2x-2l-r+l}{r-l} < 1 $\r\n\r\n$ -1 < \\frac{2x-r-l}{r-l} < 1 $\r\n\r\n$ -1 < \\frac{2x}{r-l} - \\frac{r+l}{r-1} < 1 $\r\n\r\n从而得到x与x'的关系\r\n\r\n$ x' = \\frac{2x}{r-l} - \\frac{r+l}{r-1} $\r\n\r\n对于上下区间 远近区间也类似处理 可以得到y与y'的关系 以及z与z'的关系\r\n\r\n$ y' = \\frac{2y}{t-b} - \\frac{t+b}{t-b} $\r\n\r\n$ z' = \\frac{-2z}{f-n} - \\frac{f+n}{r-1} $\r\n\r\n$\r\n\\begin{bmatrix}\r\n\\frac{2}{r-l} & 0 & 0 & -\\frac{r+l}{r-l}\\\\\r\n0 & \\frac{2}{t-b} & 0 & -\\frac{t+b}{t-b}\\\\\r\n0 & 0 & \\frac{-2}{f-n} & -\\frac{f+n}{f-n}\\\\ \r\n0 & 0 & 0 & 1\r\n\\end{bmatrix}\r\n$\r\n\r\n行列转换\r\n\r\n$\r\n\\begin{bmatrix}\r\n\\frac{2}{r-l} & 0 & 0 & 0\\\\\r\n0 & \\frac{2}{t-b} & 0 & 0\\\\\r\n0 & 0 & \\frac{-2}{f-n} & 0\\\\ \r\n-\\frac{r+l}{r-l} & -\\frac{t+b}{t-b} & -\\frac{f+n}{f-n} & 1\r\n\\end{bmatrix}\r\n$\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 7 透视投影\r\n\r\n![](2024-01-13-16-48-14.png)\r\n\r\n先将透视投影的棱台映射为长方体\r\n\r\n![](2024-01-13-16-49-54.png)\r\n\r\n![](2024-01-13-16-50-12.png)\r\n\r\n\r\n由相似三角形得出\r\n\r\n$ x' = \\frac{n}{f}* x $\r\n\r\n$ y' = \\frac{n}{f}* y $\r\n\r\n$\r\n\\begin{bmatrix}\r\n\\frac{n}{f} & 0 & 0 \\\\\r\n0 & \\frac{n}{f} & 0 \\\\\r\n? & ? & ?\r\n\\end{bmatrix}\r\n$ *\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz\r\n\\end{bmatrix}\r\n$ =\r\n$\r\n\\begin{bmatrix}\r\n\\frac{n}{f} * x \\\\\r\n\\frac{n}{f} * y \\\\\r\n?\r\n\\end{bmatrix}\r\n$\r\n\r\n按照 齐次坐标的概念\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz \\\\\r\n1\r\n\\end{bmatrix}\r\n$\r\n与\r\n$\r\n\\begin{bmatrix}\r\nk*x \\\\\r\nk*y \\\\\r\nk*z \\\\\r\nk\r\n\\end{bmatrix}\r\n$\r\n是等价的\r\n\r\n$\r\n\\begin{bmatrix}\r\n\\frac{n}{f} * x \\\\\r\n\\frac{n}{f} * y \\\\\r\n? \\\\\r\n1\r\n\\end{bmatrix}\r\n$ =>\r\n$\r\n\\begin{bmatrix}\r\nn * x \\\\\r\nn * y \\\\\r\n? \\\\\r\nf\r\n\\end{bmatrix}\r\n$\r\n\r\n即\r\n\r\n$\r\n\\begin{bmatrix}\r\nn & 0 & 0 & 0\\\\\r\n0 &n & 0 & 0\\\\\r\n? & ? & ? & ?\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$ *\r\n$\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz \\\\\r\n1 \r\n\\end{bmatrix}\r\n$ =\r\n$\r\n\\begin{bmatrix}\r\nn * x \\\\\r\nn * y \\\\\r\n? \\\\\r\nf\r\n\\end{bmatrix}\r\n$\r\n\r\n接下来我们看第三行\r\n\r\n按照正常的4*4矩阵\r\n$\r\n\\begin{bmatrix}\r\na & b & c & d \\\\\r\ne & f & g & h \\\\\r\ni & j & k & l \\\\\r\nm & n & o & p\r\n\\end{bmatrix}\r\n$\r\n\r\n我们假设第三行为\r\n$ i*x+j*y+k*z+l=z' $\r\n\r\n易知 i=0 j=0\r\n因为需要将梯形映射到长方体 所以z分量应该不变\r\n将z=-f 和z=-n 分别带入上式 可得\r\n$ k = b + f $\r\n\r\n$ d = n * f $\r\n\r\n从而梯形空间转向长方体空间的转换矩阵为\r\n\r\n$\r\n\\begin{bmatrix}\r\nn & 0 & 0 & 0\\\\\r\n0 &n & 0 & 0\\\\\r\n0 & 0 & n+f & nf\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$\r\n\r\n再利用前面的正射投影的矩阵得到透视投影矩阵\r\n\r\n$\r\n\\begin{bmatrix}\r\nn & 0 & 0 & 0\\\\\r\n0 &n & 0 & 0\\\\\r\n0 & 0 & n+f & nf\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$ * \r\n\r\n= \r\n$\r\n\\begin{bmatrix}\r\n\\frac{2n}{r-1} & 0 & 0 & 0\\\\\r\n0 & \\frac{2n}{t-b} & 0 & 0\\\\\r\n0 & 0 & \\frac{n+f}{n-f} & 2\\frac{nf}{n-f}\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$\r\n\r\n其中\r\n$ t = n * tan(\\frac{α}{2}) $\r\n\r\n$ b = -t $\r\n\r\n$ r = n * aspect * tan(\\frac{α}{2}) $\r\n\r\n$ l = -r $\r\n\r\n用上述变量进行替换得到最终的透视投影矩阵\r\n\r\n$\r\n\\begin{bmatrix}\r\n\\frac{1}{aspect * tan(\\frac{α}{2})} & 0 & 0 & 0\\\\\r\n0 & \\frac{1}{tan(\\frac{α}{2})} & 0 & 0\\\\\r\n0 & 0 & \\frac{n+f}{n-f} & 2\\frac{nf}{n-f}\\\\ \r\n0 & 0 & -1 & 0\r\n\\end{bmatrix}\r\n$"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 8 立方体绘制"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n    attribute vec4 aPosition;\r\n    attribute vec4 aColor;\r\n    varying vec4 vColor;\r\n\r\n    uniform mat4 mat;\r\n    void main() {\r\n        gl_Position = mat * aPosition;\r\n        vColor = aColor;\r\n    }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n    precision lowp float;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n        gl_FragColor = vColor;\r\n    }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n    const aColor = gl.getAttribLocation(program, 'aColor');\r\n    const mat = gl.getUniformLocation(program, 'mat');\r\n\r\n    // 顶点\r\n    const v0 = [1,1,1];\r\n    const v1 = [-1,1,1];\r\n    const v2 = [-1,-1,1];\r\n    const v3 = [1,-1,1];\r\n    const v4 = [1,-1,-1];\r\n    const v5 = [1,1,-1];\r\n    const v6 = [-1,1,-1];\r\n    const v7 = [-1,-1,-1];\r\n    /**\r\n     * 0_______3\r\n     * |       |\r\n     * |       |\r\n     * |_______|\r\n     * 1       2\r\n     */\r\n    // 共需6*6=36个顶点数据\r\n    const points = new Float32Array([\r\n        ...v0,...v1,...v2, ...v0,...v2, ...v3, // 前\r\n        ...v0,...v3,...v4, ...v0,...v4, ...v5, // 右\r\n        ...v0,...v5,...v6, ...v0,...v6, ...v1, // 上面\r\n        ...v1,...v6,...v7, ...v1,...v7, ...v2, // 左\r\n        ...v7,...v4,...v3, ...v7,...v3, ...v2, // 底\r\n        ...v4,...v7,...v6, ...v4,...v6, ...v5, // 后\r\n    ])\r\n\r\n    const buffer = gl.createBuffer();\r\n\r\n    const BYTES = points.BYTES_PER_ELEMENT;\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n\r\n    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\r\n\r\n    gl.enableVertexAttribArray(aPosition)\r\n\r\n    const colorData = new Float32Array([\r\n        1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,\r\n        0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,\r\n        0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,\r\n        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\r\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n        0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,\r\n    ])\r\n    const colorBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);\r\n    gl.enableVertexAttribArray(aColor)\r\n\r\n\r\n    let eyex = 3;\r\n    let eyey = 3;\r\n    let eyez = 5;\r\n\r\n    let deg = 0;\r\n    function draw() {\r\n        deg += 0.01;\r\n        const rotate = getRotateMatrix(deg);\r\n        const vm = getViewMatrix(eyex,eyey,eyez,0.0,0.0,0.0,0.0,0.6,0.0);\r\n        const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.uniformMatrix4fv(mat, false, mixMatrix(mixMatrix(perspective, vm), rotate));\r\n        gl.drawArrays(gl.TRIANGLES, 0, points.length / 3);\r\n\r\n        requestAnimationFrame(draw)\r\n    }\r\n\r\n    draw()\r\n`;\r\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require('path');\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code, libs);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          { // 限制变量定义域",
                                "              function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {\r",
                                "  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r",
                                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r",
                                "\r",
                                "  gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE); // 指定顶点着色器的源码\r",
                                "  gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE); // 指定片元着色器的源码\r",
                                "\r",
                                "  // 编译着色器\r",
                                "  gl.compileShader(vertexShader);\r",
                                "  gl.compileShader(fragmentShader);\r",
                                "\r",
                                "  // 创建一个程序对象\r",
                                "  const program = gl.createProgram();\r",
                                "\r",
                                "  gl.attachShader(program, vertexShader);\r",
                                "  gl.attachShader(program, fragmentShader);\r",
                                "\r",
                                "  gl.linkProgram(program);\r",
                                "\r",
                                "  gl.useProgram(program);\r",
                                "\r",
                                "  return program;\r",
                                "}\r",
                                "\r",
                                "// 平移矩阵\r",
                                "function getTranslateMatrix(x = 0, y = 0, z = 0) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1.0, 0.0, 0.0, 0.0,\r",
                                "    0.0, 1.0, 0.0, 0.0,\r",
                                "    0.0, 0.0, 1.0, 0.0,\r",
                                "    x  , y  , z  , 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 缩放矩阵\r",
                                "function getScaleMatrix(x = 1, y = 1, z = 1) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x  , 0.0, 0.0, 0.0,\r",
                                "    0.0, y  , 0.0, 0.0,\r",
                                "    0.0, 0.0, z  , 0.0,\r",
                                "    0.0, 0.0, 0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 绕z轴旋转的旋转矩阵\r",
                                "function getRotateMatrix(deg) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    Math.cos(deg),  Math.sin(deg), 0.0,0.0,\r",
                                "    -Math.sin(deg), Math.cos(deg), 0.0,0.0,\r",
                                "    0.0,            0.0,           1.0,0.0,\r",
                                "    0.0,            0.0,           0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 矩阵复合函数\r",
                                "function mixMatrix(A, B) {\r",
                                "  const result = new Float32Array(16);\r",
                                "\r",
                                "  for (let i = 0; i < 4; i++) {\r",
                                "    result[i] =\r",
                                "      A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3];\r",
                                "    result[i + 4] =\r",
                                "      A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7];\r",
                                "    result[i + 8] =\r",
                                "      A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11];\r",
                                "    result[i + 12] =\r",
                                "      A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15];\r",
                                "  }\r",
                                "\r",
                                "  return result;\r",
                                "}\r",
                                "\r",
                                "// 归一化函数\r",
                                "function normalized(arr) {\r",
                                "  let sum = 0;\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    sum += arr[i] * arr[i];\r",
                                "  }\r",
                                "\r",
                                "  const middle = Math.sqrt(sum);\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    arr[i] = arr[i] / middle;\r",
                                "  }\r",
                                "}\r",
                                "\r",
                                "// 叉积函数 获取法向量\r",
                                "function cross(a, b) {\r",
                                "  return new Float32Array([\r",
                                "    a[1] * b[2] - a[2] * b[1],\r",
                                "    a[2] * b[0] - a[0] * b[2],\r",
                                "    a[0] * b[1] - a[1] * b[0],\r",
                                "  ]);\r",
                                "}\r",
                                "\r",
                                "// 点积函数 获取投影长度\r",
                                "function dot(a, b) {\r",
                                "  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r",
                                "}\r",
                                "\r",
                                "// 向量差\r",
                                "function minus(a, b) {\r",
                                "  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);\r",
                                "}\r",
                                "\r",
                                "// 视图矩阵获取\r",
                                "function getViewMatrix(\r",
                                "  eyex,\r",
                                "  eyey,\r",
                                "  eyez,\r",
                                "  lookAtx,\r",
                                "  lookAty,\r",
                                "  lookAtz,\r",
                                "  upx,\r",
                                "  upy,\r",
                                "  upz\r",
                                ") {\r",
                                "  // 视点\r",
                                "  const eye = new Float32Array([eyex, eyey, eyez]);\r",
                                "  // 目标点\r",
                                "  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\r",
                                "  // 上方向\r",
                                "  const up = new Float32Array([upx, upy, upz]);\r",
                                "\r",
                                "  // 确定z轴\r",
                                "  const z = minus(eye, lookAt);\r",
                                "\r",
                                "  normalized(z);\r",
                                "  normalized(up);\r",
                                "\r",
                                "  // 确定x轴\r",
                                "  const x = cross(z, up);\r",
                                "\r",
                                "  normalized(x);\r",
                                "  // 确定y轴\r",
                                "  const y = cross(x, z);\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x[0],       y[0],       z[0],       0,\r",
                                "    x[1],       y[1],       z[1],       0,\r",
                                "    x[2],       y[2],       z[2],       0,\r",
                                "    -dot(x,eye),-dot(y,eye),-dot(z,eye),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取正射投影矩阵\r",
                                "function getOrtho(l, r, t, b, n, f) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    2 / (r - l), 0,           0,           0,\r",
                                "    0,           2/(t-b),     0,           0,\r",
                                "    0,           0,           -2/(f-n),    0,\r",
                                "    -(r+l)/(r-l),-(t+b)/(t-b),-(f+n)/(f-n),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取透视投影矩阵\r",
                                "function getPerspective(fov, aspect, far, near) {\r",
                                "  fov = (fov * Math.PI) / 180;\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1/(aspect*Math.tan(fov / 2)), 0,                   0,                      0,\r",
                                "    0,                            1/(Math.tan(fov/2)), 0,                      0,\r",
                                "    0,                            0,                   -(far+near)/(far-near), -(2*far*near)/(far-near),\r",
                                "    0,                            0,                   -1,                     0,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "function distanceSelf(a, b) {\r",
                                "  const x = a[0] - b[0];\r",
                                "  const y = a[1] - b[1];\r",
                                "  const z = a[2] - b[2];\r",
                                "\r",
                                "  const v = x * x + y * y + z * z;\r",
                                "\r",
                                "  return Math.sqrt(v);\r",
                                "}\r",
                                "",
                                "          }",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"5dbfbcc0-c1cc-11ee-8d70-11e90b105116\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('5dbfbcc0-c1cc-11ee-8d70-11e90b105116');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    attribute vec4 aColor;\\n    varying vec4 vColor;\\n\\n    uniform mat4 mat;\\n    void main() {\\n        gl_Position = mat * aPosition;\\n        vColor = aColor;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    precision lowp float;\\n    varying vec4 vColor;\\n\\n    void main() {\\n        gl_FragColor = vColor;\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "    const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "    const aColor = gl.getAttribLocation(program, 'aColor');",
                                "    const mat = gl.getUniformLocation(program, 'mat');",
                                "",
                                "    // 顶点",
                                "    const v0 = [1,1,1];",
                                "    const v1 = [-1,1,1];",
                                "    const v2 = [-1,-1,1];",
                                "    const v3 = [1,-1,1];",
                                "    const v4 = [1,-1,-1];",
                                "    const v5 = [1,1,-1];",
                                "    const v6 = [-1,1,-1];",
                                "    const v7 = [-1,-1,-1];",
                                "    const points = new Float32Array([",
                                "        ...v0,...v1,...v2, ...v0,...v2, ...v3, // 前",
                                "        ...v0,...v3,...v4, ...v0,...v4, ...v5, // 右",
                                "        ...v0,...v5,...v6, ...v0,...v6, ...v1, // 上面",
                                "        ...v1,...v6,...v7, ...v1,...v7, ...v2, // 左",
                                "        ...v7,...v4,...v3, ...v7,...v3, ...v2, // 底",
                                "        ...v4,...v7,...v6, ...v4,...v6, ...v5, // 后",
                                "    ])",
                                "",
                                "    const buffer = gl.createBuffer();",
                                "",
                                "    const BYTES = points.BYTES_PER_ELEMENT;",
                                "",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "",
                                "    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);",
                                "",
                                "    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);",
                                "",
                                "    gl.enableVertexAttribArray(aPosition)",
                                "",
                                "    const colorData = new Float32Array([",
                                "        1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,",
                                "        0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,",
                                "        0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,",
                                "        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,",
                                "        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,",
                                "        0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,",
                                "    ])",
                                "    const colorBuffer = gl.createBuffer();",
                                "    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);",
                                "    gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.STATIC_DRAW);",
                                "    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);",
                                "    gl.enableVertexAttribArray(aColor)",
                                "",
                                "",
                                "    let eyex = 3;",
                                "    let eyey = 3;",
                                "    let eyez = 5;",
                                "",
                                "    let deg = 0;",
                                "    function draw() {",
                                "        deg += 0.01;",
                                "        const rotate = getRotateMatrix(deg);",
                                "        const vm = getViewMatrix(eyex,eyey,eyez,0.0,0.0,0.0,0.0,0.6,0.0);",
                                "        const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);",
                                "        gl.enable(gl.DEPTH_TEST);",
                                "        gl.uniformMatrix4fv(mat, false, mixMatrix(mixMatrix(perspective, vm), rotate));",
                                "        gl.drawArrays(gl.TRIANGLES, 0, points.length / 3);",
                                "",
                                "        requestAnimationFrame(draw)",
                                "    }",
                                "",
                                "    draw()",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "#### 索引法"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n    attribute vec4 aPosition;\r\n    attribute vec4 aColor;\r\n    varying vec4 vColor;\r\n\r\n    uniform mat4 mat;\r\n    void main() {\r\n      gl_Position = mat * aPosition;\r\n      vColor = aColor;\r\n    }\r\n`;\r\n\r\nconst fragment_code = /*glsl */ `\r\n    precision lowp float;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n      gl_FragColor = vColor;\r\n    }\r\n`;\r\n\r\nconst js_code = /*js*/ `\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const aColor = gl.getAttribLocation(program, 'aColor');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n  // 需要6*4=24个顶点数据\r\n  const vertices = new Float32Array([\r\n    // 0123\r\n    1, 1, 1,\r\n    -1, 1,1,\r\n    -1,-1,1,\r\n    1,-1, 1,\r\n    // 0345\r\n    1, 1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    // 0156\r\n    1, 1, 1,\r\n    1, 1,-1,\r\n    -1,1,-1,\r\n    -1,1, 1,\r\n    // 1267\r\n    -1, 1, 1,\r\n    -1, 1,-1,\r\n    -1,-1,-1,\r\n    -1,-1, 1,\r\n    // 2347\r\n    -1,-1, 1,\r\n     1,-1, 1,\r\n     1,-1,-1,\r\n    -1,-1,-1,\r\n    // 4567\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    -1, 1,-1,\r\n    -1,-1,-1,\r\n  ])\r\n\r\n  /*\r\n    1, 1, 1,   0\r\n    -1, 1, 1,   1\r\n    -1,-1, 1,   2\r\n    1,-1, 1,   3\r\n    1,-1,-1,   4\r\n    1, 1,-1,   5\r\n    -1, 1,-1,   6\r\n    -1,-1,-1,   7\r\n  * */\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n  // 24个顶点对应的颜色数据\r\n  const colors = new Float32Array([\r\n    0.4,0.4,1.0,\r\n    0.4,0.4,1.0,\r\n    0.4,0.4,1.0,\r\n    0.4,0.4,1.0,\r\n    0.4,1.0,0.4,\r\n    0.4,1.0,0.4,\r\n    0.4,1.0,0.4,\r\n    0.4,1.0,0.4,\r\n    1.0,0.4,0.4,\r\n    1.0,0.4,0.4,\r\n    1.0,0.4,0.4,\r\n    1.0,0.4,0.4,\r\n    1.0,1.0,0.4,\r\n    1.0,1.0,0.4,\r\n    1.0,1.0,0.4,\r\n    1.0,1.0,0.4,\r\n    1.0,0.0,1.0,\r\n    1.0,0.0,1.0,\r\n    1.0,0.0,1.0,\r\n    1.0,0.0,1.0,\r\n    0.0,1.0,1.0,\r\n    0.0,1.0,1.0,\r\n    0.0,1.0,1.0,\r\n    0.0,1.0,1.0,\r\n  ])\r\n\r\n  const colorBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aColor)\r\n\r\n  const indeces = new Uint8Array([\r\n     0, 1, 2, 0, 2, 3,\r\n     4, 5, 6, 4, 6, 7,\r\n     8, 9,10, 8,10,11,\r\n    12,13,14,12,14,15,\r\n    16,17,18,16,18,19,\r\n    20,21,22,20,22,23,\r\n  ])\r\n  const indexBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);\r\n\r\n  let eyex = 3;\r\n  let eyey = 3;\r\n  let eyez = 5;\r\n\r\n  let deg = 0;\r\n  function draw() {\r\n    deg += 0.01;\r\n    const rotate = getRotateMatrix(deg);\r\n    const vm = getViewMatrix(eyex,eyey,eyez,0.0,0.0,0.0,0.0,0.6,0.0);\r\n    const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.uniformMatrix4fv(mat, false, mixMatrix(mixMatrix(perspective, vm), rotate));\r\n    gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);\r\n\r\n    requestAnimationFrame(draw)\r\n  }\r\n\r\n  draw()\r\n`;\r\nconst { renderWebgl } = require(\"../../src/display.js\");\r\nrenderWebgl(vertex_code, fragment_code, js_code);\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "        <canvas id=\"2c7e16c0-c1e0-11ee-9a38-5fe916272914\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('2c7e16c0-c1e0-11ee-9a38-5fe916272914');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    attribute vec4 aColor;\\n    varying vec4 vColor;\\n\\n    uniform mat4 mat;\\n    void main() {\\n      gl_Position = mat * aPosition;\\n      vColor = aColor;\\n    }\\n\"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    precision lowp float;\\n    varying vec4 vColor;\\n\\n    void main() {\\n      gl_FragColor = vColor;\\n    }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const aColor = gl.getAttribLocation(program, 'aColor');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "  // 需要6*4=24个顶点数据",
                                "  const vertices = new Float32Array([",
                                "    // 0123",
                                "    1, 1, 1,",
                                "    -1, 1,1,",
                                "    -1,-1,1,",
                                "    1,-1, 1,",
                                "    // 0345",
                                "    1, 1, 1,",
                                "    1,-1, 1,",
                                "    1,-1,-1,",
                                "    1, 1,-1,",
                                "    // 0156",
                                "    1, 1, 1,",
                                "    1, 1,-1,",
                                "    -1,1,-1,",
                                "    -1,1, 1,",
                                "    // 1267",
                                "    -1, 1, 1,",
                                "    -1, 1,-1,",
                                "    -1,-1,-1,",
                                "    -1,-1, 1,",
                                "    // 2347",
                                "    -1,-1, 1,",
                                "     1,-1, 1,",
                                "     1,-1,-1,",
                                "    -1,-1,-1,",
                                "    // 4567",
                                "    1,-1,-1,",
                                "    1, 1,-1,",
                                "    -1, 1,-1,",
                                "    -1,-1,-1,",
                                "  ])",
                                "",
                                "  /*",
                                "    1, 1, 1,   0",
                                "    -1, 1, 1,   1",
                                "    -1,-1, 1,   2",
                                "    1,-1, 1,   3",
                                "    1,-1,-1,   4",
                                "    1, 1,-1,   5",
                                "    -1, 1,-1,   6",
                                "    -1,-1,-1,   7",
                                "  * */",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "  // 24个顶点对应的颜色数据",
                                "  const colors = new Float32Array([",
                                "    0.4,0.4,1.0,",
                                "    0.4,0.4,1.0,",
                                "    0.4,0.4,1.0,",
                                "    0.4,0.4,1.0,",
                                "    0.4,1.0,0.4,",
                                "    0.4,1.0,0.4,",
                                "    0.4,1.0,0.4,",
                                "    0.4,1.0,0.4,",
                                "    1.0,0.4,0.4,",
                                "    1.0,0.4,0.4,",
                                "    1.0,0.4,0.4,",
                                "    1.0,0.4,0.4,",
                                "    1.0,1.0,0.4,",
                                "    1.0,1.0,0.4,",
                                "    1.0,1.0,0.4,",
                                "    1.0,1.0,0.4,",
                                "    1.0,0.0,1.0,",
                                "    1.0,0.0,1.0,",
                                "    1.0,0.0,1.0,",
                                "    1.0,0.0,1.0,",
                                "    0.0,1.0,1.0,",
                                "    0.0,1.0,1.0,",
                                "    0.0,1.0,1.0,",
                                "    0.0,1.0,1.0,",
                                "  ])",
                                "",
                                "  const colorBuffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aColor)",
                                "",
                                "  const indeces = new Uint8Array([",
                                "     0, 1, 2, 0, 2, 3,",
                                "     4, 5, 6, 4, 6, 7,",
                                "     8, 9,10, 8,10,11,",
                                "    12,13,14,12,14,15,",
                                "    16,17,18,16,18,19,",
                                "    20,21,22,20,22,23,",
                                "  ])",
                                "  const indexBuffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);",
                                "  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);",
                                "",
                                "  let eyex = 3;",
                                "  let eyey = 3;",
                                "  let eyez = 5;",
                                "",
                                "  let deg = 0;",
                                "  function draw() {",
                                "    deg += 0.01;",
                                "    const rotate = getRotateMatrix(deg);",
                                "    const vm = getViewMatrix(eyex,eyey,eyez,0.0,0.0,0.0,0.0,0.6,0.0);",
                                "    const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);",
                                "    gl.enable(gl.DEPTH_TEST);",
                                "    gl.uniformMatrix4fv(mat, false, mixMatrix(mixMatrix(perspective, vm), rotate));",
                                "    gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);",
                                "",
                                "    requestAnimationFrame(draw)",
                                "  }",
                                "",
                                "  draw()",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "html",
            "source": [
                "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>Title</title>\r\n  <script src=\"../lib/index.js\"></script>\r\n  <style>\r\n    * {\r\n      margin: 0;\r\n      padding: 0;\r\n    }\r\n\r\n    canvas{\r\n      margin: 50px auto 0;\r\n      display: block;\r\n      background: yellow;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n  <canvas id=\"canvas\" width=\"400\" height=\"400\">\r\n    此浏览器不支持canvas\r\n  </canvas>\r\n</body>\r\n</html>\r\n<script>\r\n\r\n  const ctx = document.getElementById('canvas')\r\n\r\n  const gl = ctx.getContext('webgl')\r\n\r\n  // 创建着色器源码\r\n  const VERTEX_SHADER_SOURCE = `\r\n    // 只传递顶点数据\r\n    attribute vec4 aPosition;\r\n    varying vec4 vPosition;\r\n    void main() {\r\n      gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\r\n      vPosition = aPosition;\r\n      gl_PointSize = 10.0;\r\n    }\r\n  `; // 顶点着色器\r\n\r\n  const FRAGMENT_SHADER_SOURCE = `\r\n    precision lowp float;\r\n    uniform float radius;\r\n    uniform float w;\r\n    uniform float h;\r\n    varying vec4 vPosition;\r\n\r\n    void setColor(float x, float y, vec2 target) {\r\n      float d = distance(vec2(target), vec2(x, y));\r\n\r\n      if (d > radius) {\r\n        discard;\r\n      } else {\r\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n      }\r\n    }\r\n\r\n    void main() {\r\n      float x = vPosition.x;\r\n      float y = vPosition.y;\r\n\r\n      // 左上\r\n      vec2 topLeft = vec2(-w + radius, h - radius);\r\n\r\n      // 右上\r\n      vec2 topRight = vec2(w - radius, h - radius);\r\n\r\n      // 左下\r\n      vec2 bottomLeft = vec2(-w + radius, -h + radius);\r\n\r\n      // 右下\r\n      vec2 bottomRight = vec2(w - radius, -h + radius);\r\n\r\n      if (x < topLeft.x && y > topLeft.y) {\r\n\r\n        setColor(x, y, topLeft);\r\n\r\n      } else if (x > topRight.x && y > topRight.y) {\r\n\r\n        setColor(x, y, topRight);\r\n\r\n      } else if (x < bottomLeft.x && y < bottomLeft.y) {\r\n\r\n        setColor(x, y, bottomLeft);\r\n\r\n      } else if (x > bottomRight.x && y < bottomRight.y) {\r\n\r\n        setColor(x, y, bottomRight);\r\n\r\n      } else {\r\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n      }\r\n    }\r\n  `; // 片元着色器\r\n\r\n  const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)\r\n\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const radius = gl.getUniformLocation(program, 'radius');\r\n  const w = gl.getUniformLocation(program, 'w');\r\n  const h = gl.getUniformLocation(program, 'h');\r\n\r\n  const size = 0.5;\r\n  const points = new Float32Array([\r\n    -size, -size,\r\n     size, -size,\r\n    -size,  size,\r\n     size,  size,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r\n\r\n  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n  gl.enableVertexAttribArray(aPosition)\r\n  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\r\n\r\n  gl.uniform1f(radius, 0.1);\r\n  gl.uniform1f(w, size);\r\n  gl.uniform1f(h, size);\r\n\r\n  const start = () => {\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n\r\n    requestAnimationFrame(start)\r\n  }\r\n\r\n  start();\r\n\r\n</script>\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<!DOCTYPE html>\r",
                                "<html lang=\"en\">\r",
                                "<head>\r",
                                "  <meta charset=\"UTF-8\">\r",
                                "  <title>Title</title>\r",
                                "  <script src=\"../lib/index.js\"></script>\r",
                                "  <style>\r",
                                "    * {\r",
                                "      margin: 0;\r",
                                "      padding: 0;\r",
                                "    }\r",
                                "\r",
                                "    canvas{\r",
                                "      margin: 50px auto 0;\r",
                                "      display: block;\r",
                                "      background: yellow;\r",
                                "    }\r",
                                "  </style>\r",
                                "</head>\r",
                                "<body>\r",
                                "  <canvas id=\"canvas\" width=\"400\" height=\"400\">\r",
                                "    此浏览器不支持canvas\r",
                                "  </canvas>\r",
                                "</body>\r",
                                "</html>\r",
                                "<script>\r",
                                "\r",
                                "  const ctx = document.getElementById('canvas')\r",
                                "\r",
                                "  const gl = ctx.getContext('webgl')\r",
                                "\r",
                                "  // 创建着色器源码\r",
                                "  const VERTEX_SHADER_SOURCE = `\r",
                                "    // 只传递顶点数据\r",
                                "    attribute vec4 aPosition;\r",
                                "    varying vec4 vPosition;\r",
                                "    void main() {\r",
                                "      gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)\r",
                                "      vPosition = aPosition;\r",
                                "      gl_PointSize = 10.0;\r",
                                "    }\r",
                                "  `; // 顶点着色器\r",
                                "\r",
                                "  const FRAGMENT_SHADER_SOURCE = `\r",
                                "    precision lowp float;\r",
                                "    uniform float radius;\r",
                                "    uniform float w;\r",
                                "    uniform float h;\r",
                                "    varying vec4 vPosition;\r",
                                "\r",
                                "    void setColor(float x, float y, vec2 target) {\r",
                                "      float d = distance(vec2(target), vec2(x, y));\r",
                                "\r",
                                "      if (d > radius) {\r",
                                "        discard;\r",
                                "      } else {\r",
                                "        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r",
                                "      }\r",
                                "    }\r",
                                "\r",
                                "    void main() {\r",
                                "      float x = vPosition.x;\r",
                                "      float y = vPosition.y;\r",
                                "\r",
                                "      // 左上\r",
                                "      vec2 topLeft = vec2(-w + radius, h - radius);\r",
                                "\r",
                                "      // 右上\r",
                                "      vec2 topRight = vec2(w - radius, h - radius);\r",
                                "\r",
                                "      // 左下\r",
                                "      vec2 bottomLeft = vec2(-w + radius, -h + radius);\r",
                                "\r",
                                "      // 右下\r",
                                "      vec2 bottomRight = vec2(w - radius, -h + radius);\r",
                                "\r",
                                "      if (x < topLeft.x && y > topLeft.y) {\r",
                                "\r",
                                "        setColor(x, y, topLeft);\r",
                                "\r",
                                "      } else if (x > topRight.x && y > topRight.y) {\r",
                                "\r",
                                "        setColor(x, y, topRight);\r",
                                "\r",
                                "      } else if (x < bottomLeft.x && y < bottomLeft.y) {\r",
                                "\r",
                                "        setColor(x, y, bottomLeft);\r",
                                "\r",
                                "      } else if (x > bottomRight.x && y < bottomRight.y) {\r",
                                "\r",
                                "        setColor(x, y, bottomRight);\r",
                                "\r",
                                "      } else {\r",
                                "        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r",
                                "      }\r",
                                "    }\r",
                                "  `; // 片元着色器\r",
                                "\r",
                                "  const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)\r",
                                "\r",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');\r",
                                "  const radius = gl.getUniformLocation(program, 'radius');\r",
                                "  const w = gl.getUniformLocation(program, 'w');\r",
                                "  const h = gl.getUniformLocation(program, 'h');\r",
                                "\r",
                                "  const size = 0.5;\r",
                                "  const points = new Float32Array([\r",
                                "    -size, -size,\r",
                                "     size, -size,\r",
                                "    -size,  size,\r",
                                "     size,  size,\r",
                                "  ])\r",
                                "\r",
                                "  const buffer = gl.createBuffer();\r",
                                "\r",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r",
                                "\r",
                                "  gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\r",
                                "\r",
                                "  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r",
                                "\r",
                                "  gl.enableVertexAttribArray(aPosition)\r",
                                "  // gl.vertexAttrib2f(aPosition, 0.0, 0.0)\r",
                                "\r",
                                "  gl.uniform1f(radius, 0.1);\r",
                                "  gl.uniform1f(w, size);\r",
                                "  gl.uniform1f(h, size);\r",
                                "\r",
                                "  const start = () => {\r",
                                "    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r",
                                "\r",
                                "    requestAnimationFrame(start)\r",
                                "  }\r",
                                "\r",
                                "  start();\r",
                                "\r",
                                "</script>\r",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "点光源光线：一个点向周围发出的光，如灯泡、火焰等。\r\n定义⼀个点光源光需要光源的位置、光线方向以及颜⾊。\r\n根据照射点的位置不同，光线的⽅向也不同。                      \r\n\r\n\r\n平行光：可以看成是无限远处的光源发出的光，如太阳光。\r\n因为离光源的位置特别远，所以到达被照物体时可以认为光线是平行的。\r\n只需要光照方向和光照颜色\r\n\r\n环境光：也就是间接光，是指光源发出后，经过其他物体各种发射，然后照到物体表面上的光线。\r\n环境光的强度差距非常小，没有必要精确计算光线强度。\r\n环境光是均匀照射到物体表⾯的，只需要定义光照颜色\r\n\r\n环境反射：环境反射是针对环境光而言的，在环境反射中，环境光照射物体是各方面均匀、强度相等的，反射的方向就是入射光的反方向。\r\n\r\n最终物体的颜色只跟入射光颜色和基底色有关。\r\n<环境反射光颜色>=<入射光颜色>*<表面基底色>\r\n \r\n\r\n 漫反射中反射光的颜色除了取决于入射光的颜色、表面的基底色，还有入射光与物体表面的法向量形成的入射角。\r\n令入射角为 α，漫反射光的颜色可以根据下式计算：\r\n<漫反射光颜色>=<⼊射光颜色>*<表面基底色>* cosα\r\n入射角 α 可以通过 光线方向和法线方向 的点积来计算：\r\n<光线方向>·<法线方向> = cosα\r\n<漫反射光颜⾊>=<入射光颜色>*<表⾯基底色>* (<光线方向>*<法线方向>)\r\n“光线方向”指的是⼊射方向的反方向，即从入射点指向光源方向。\r\n\r\n当漫反射和环境反射同时存在时，将两者加起来，就会得到物体最终被观察到的颜色：\r\n<表面的反射光颜色> = <漫反射光颜色>+<环境反射光颜色>\r\n\r\n"
            ],
            "outputs": []
        },
        {
            "language": "html",
            "source": [
                "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>Title</title>\r\n  <script src=\"../lib/index.js\"></script>\r\n  <style>\r\n    * {\r\n      margin: 0;\r\n      padding: 0;\r\n    }\r\n\r\n    canvas{\r\n      margin: 50px auto 0;\r\n      display: block;\r\n      background: yellow;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n<canvas id=\"canvas\" width=\"400\" height=\"400\">\r\n  此浏览器不支持canvas\r\n</canvas>\r\n</body>\r\n</html>\r\n<script>\r\n\r\n  const ctx = document.getElementById('canvas')\r\n\r\n  const gl = ctx.getContext('webgl')\r\n\r\n  // 创建着色器源码\r\n  const VERTEX_SHADER_SOURCE = `\r\n    attribute vec4 aPosition;\r\n    attribute vec4 aNormal;\r\n    varying vec4 vColor;\r\n\r\n    uniform mat4 mat;\r\n    void main() {\r\n      // 定义点光源的颜色\r\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\r\n\r\n      // 点光源的位置\r\n      vec3 uPointLightPosition = vec3(-5.0,6.0,10.0);\r\n\r\n      // 环境光\r\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\r\n\r\n      // 物体表面的颜色\r\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\r\n\r\n      // 顶点的世界坐标\r\n      vec4 vertexPosition = mat * aPosition;\r\n\r\n      // 点光源的方向\r\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\r\n\r\n      // 环境反射\r\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\r\n\r\n      // 计算入射角 光线方向和法线方向的点积\r\n      float dotDeg = dot(lightDirection, vec3(aNormal));\r\n\r\n      // 漫反射光的颜色\r\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\r\n\r\n      gl_Position = vertexPosition;\r\n      vColor = vec4(ambient + diffuseColor, aColor.a);\r\n    }\r\n  `; // 顶点着色器\r\n\r\n  const FRAGMENT_SHADER_SOURCE = `\r\n    precision lowp float;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `; // 片元着色器\r\n\r\n  const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)\r\n\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const aNormal = gl.getAttribLocation(program, 'aNormal');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n\r\n  const vertices = new Float32Array([\r\n    // 0123\r\n    1, 1, 1,\r\n    -1, 1, 1,\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    // 0345\r\n    1, 1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    // 0156\r\n    1, 1, 1,\r\n    1, 1, -1,\r\n    -1, 1,-1,\r\n    -1, 1,1,\r\n    // 1267\r\n    -1, 1, 1,\r\n    -1,1, -1,\r\n    -1, -1,-1,\r\n    -1,-1,1,\r\n    // 2347\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    -1,-1,-1,\r\n    // 4567\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    -1, 1,-1,\r\n    -1,-1,-1,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n\r\n  // 法向量\r\n  const normals = new Float32Array([\r\n    0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,\r\n    0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,\r\n    -1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,\r\n    1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,\r\n    0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,\r\n    0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,\r\n  ])\r\n  const normalBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aNormal)\r\n\r\n  const indeces = new Uint8Array([\r\n    0,1,2,0,2,3,\r\n    4,5,6,4,6,7,\r\n    8,9,10,8,10,11,\r\n    12,13,14,12,14,15,\r\n    16,17,18,16,18,19,\r\n    20,21,22,20,22,23,\r\n  ])\r\n  const indexBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);\r\n\r\n  const vm = getViewMatrix(3,3,5,0.0,0.0,0.0,0.0,0.6,0.0);\r\n  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\r\n  gl.enable(gl.DEPTH_TEST);\r\n  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));\r\n  gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);\r\n\r\n</script>\r\n"
            ],
            "outputs": []
        },
        {
            "language": "html",
            "source": [
                "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>Title</title>\r\n  <script src=\"../lib/index.js\"></script>\r\n  <style>\r\n    * {\r\n      margin: 0;\r\n      padding: 0;\r\n    }\r\n\r\n    canvas{\r\n      margin: 50px auto 0;\r\n      display: block;\r\n      background: yellow;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n<canvas id=\"canvas\" width=\"400\" height=\"400\">\r\n  此浏览器不支持canvas\r\n</canvas>\r\n</body>\r\n</html>\r\n<script>\r\n\r\n  const ctx = document.getElementById('canvas')\r\n\r\n  const gl = ctx.getContext('webgl')\r\n\r\n  // 创建着色器源码\r\n  const VERTEX_SHADER_SOURCE = `\r\n    attribute vec4 aPosition;\r\n    attribute vec4 aNormal;\r\n    varying vec4 vColor;\r\n\r\n    uniform mat4 mat;\r\n    void main() {\r\n      // 定义点光源的颜色\r\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\r\n\r\n      // 点光源的位置\r\n      vec3 uPointLightPosition = vec3(-5.0,6.0,10.0);\r\n\r\n      // 环境光\r\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\r\n\r\n      // 物体表面的颜色\r\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\r\n\r\n      // 顶点的世界坐标\r\n      vec4 vertexPosition = mat * aPosition;\r\n\r\n      // 点光源的方向\r\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\r\n\r\n      // 环境反射\r\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\r\n\r\n      // 计算入射角 光线方向和法线方向的点积\r\n      float dotDeg = dot(lightDirection, vec3(aNormal));\r\n\r\n      // 漫反射光的颜色\r\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\r\n\r\n      gl_Position = vertexPosition;\r\n      vColor = vec4(ambient + diffuseColor, aColor.a);\r\n    }\r\n  `; // 顶点着色器\r\n\r\n  const FRAGMENT_SHADER_SOURCE = `\r\n    precision lowp float;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `; // 片元着色器\r\n\r\n  const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)\r\n\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const aNormal = gl.getAttribLocation(program, 'aNormal');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n\r\n  const vertices = new Float32Array([\r\n    // 0123\r\n    1, 1, 1,\r\n    -1, 1, 1,\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    // 0345\r\n    1, 1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    // 0156\r\n    1, 1, 1,\r\n    1, 1, -1,\r\n    -1, 1,-1,\r\n    -1, 1,1,\r\n    // 1267\r\n    -1, 1, 1,\r\n    -1,1, -1,\r\n    -1, -1,-1,\r\n    -1,-1,1,\r\n    // 2347\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    -1,-1,-1,\r\n    // 4567\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    -1, 1,-1,\r\n    -1,-1,-1,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n\r\n  // 通过顶点来计算法向量 start =============\r\n  const res = []\r\n  for (let i = 0; i < vertices.length; i+=12) {\r\n    const item = cross(\r\n      [\r\n        vertices[i],\r\n        vertices[i+1],\r\n        vertices[i+2]\r\n      ],\r\n      [\r\n        vertices[i+3],\r\n        vertices[i+4],\r\n        vertices[i+5]\r\n      ])\r\n    for (let j = 0; j < 4; j++) {\r\n      res.push(...item)\r\n    }\r\n  }\r\n  // 法向量\r\n  const normals = new Float32Array(res)\r\n  // 通过顶点来计算法向量  end =============\r\n\r\n  const normalBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aNormal)\r\n\r\n  const indeces = new Uint8Array([\r\n    0,1,2,0,2,3,\r\n    4,5,6,4,6,7,\r\n    8,9,10,8,10,11,\r\n    12,13,14,12,14,15,\r\n    16,17,18,16,18,19,\r\n    20,21,22,20,22,23,\r\n  ])\r\n  const indexBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);\r\n\r\n  const vm = getViewMatrix(3,3,5,0.0,0.0,0.0,0.0,0.6,0.0);\r\n  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\r\n  gl.enable(gl.DEPTH_TEST);\r\n  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));\r\n  gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);\r\n\r\n</script>\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "vscode插件推荐\r\n\r\nGLSL lint\r\nShader languages support for VS Code\r\nglsl-canvas"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                ""
            ],
            "outputs": []
        }
    ]
}