{
    "cells": [
        {
            "language": "markdown",
            "source": [
<<<<<<< HEAD
                "点光源光线：一个点向周围发出的光，如灯泡、火焰等。\r\n定义⼀个点光源光需要光源的位置、光线方向以及颜⾊。\r\n根据照射点的位置不同，光线的⽅向也不同。                      \r\n\r\n\r\n平行光：可以看成是无限远处的光源发出的光，如太阳光。\r\n因为离光源的位置特别远，所以到达被照物体时可以认为光线是平行的。\r\n只需要光照方向和光照颜色\r\n\r\n环境光：也就是间接光，是指光源发出后，经过其他物体各种发射，然后照到物体表面上的光线。\r\n环境光的强度差距非常小，没有必要精确计算光线强度。\r\n环境光是均匀照射到物体表⾯的，只需要定义光照颜色\r\n\r\n环境反射：环境反射是针对环境光而言的，在环境反射中，环境光照射物体是各方面均匀、强度相等的，反射的方向就是入射光的反方向。\r\n\r\n最终物体的颜色只跟入射光颜色和基底色有关。\r\n\r\n$ 环境反射光颜色 = 入射光颜色 * 表面基底色 $\r\n \r\n\r\n 漫反射中反射光的颜色除了取决于入射光的颜色、表面的基底色，还有入射光与物体表面的法向量形成的入射角。\r\n令入射角为 α，漫反射光的颜色可以根据下式计算：\r\n\r\n$ 漫反射光颜色 = ⼊射光颜色 * 表面基底色 * cosα $\r\n\r\n入射角 α 可以通过 光线方向和法线方向 的点积来计算：\r\n\r\n$ 光线方向 · 法线方向  = cosα $\r\n\r\n$ 漫反射光颜⾊ = 入射光颜色 * 表⾯基底色 * (光线方向 * 法线方向) $\r\n\r\n“光线方向”指的是⼊射方向的反方向，即从入射点指向光源方向。\r\n\r\n当漫反射和环境反射同时存在时，将两者加起来，就会得到物体最终被观察到的颜色：\r\n\r\n$ 表面的反射光颜色 = 漫反射光颜色 + 环境反射光颜色 $\r\n\r\n"
=======
                "点光源光线：一个点向周围发出的光，如灯泡、火焰等。\n定义⼀个点光源光需要光源的位置、光线方向以及颜⾊。\n根据照射点的位置不同，光线的⽅向也不同。                      \n\n\n平行光：可以看成是无限远处的光源发出的光，如太阳光。\n因为离光源的位置特别远，所以到达被照物体时可以认为光线是平行的。\n只需要光照方向和光照颜色\n\n环境光：也就是间接光，是指光源发出后，经过其他物体各种发射，然后照到物体表面上的光线。\n环境光的强度差距非常小，没有必要精确计算光线强度。\n环境光是均匀照射到物体表⾯的，只需要定义光照颜色\n\n环境反射：环境反射是针对环境光而言的，在环境反射中，环境光照射物体是各方面均匀、强度相等的，反射的方向就是入射光的反方向。\n\n最终物体的颜色只跟入射光颜色和基底色有关。\n<环境反射光颜色>=<入射光颜色>*<表面基底色>\n \n\n 漫反射中反射光的颜色除了取决于入射光的颜色、表面的基底色，还有入射光与物体表面的法向量形成的入射角。\n令入射角为 α，漫反射光的颜色可以根据下式计算：\n<漫反射光颜色>=<⼊射光颜色>*<表面基底色>* cosα\n入射角 α 可以通过 光线方向和法线方向 的点积来计算：\n<光线方向>·<法线方向> = cosα\n<漫反射光颜⾊>=<入射光颜色>*<表⾯基底色>* (<光线方向>*<法线方向>)\n“光线方向”指的是⼊射方向的反方向，即从入射点指向光源方向。\n\n当漫反射和环境反射同时存在时，将两者加起来，就会得到物体最终被观察到的颜色：\n<表面的反射光颜色> = <漫反射光颜色>+<环境反射光颜色>\n\n"
>>>>>>> f95daa79deee13da833f7c14ccac32d9e9161b9b
            ],
            "outputs": []
        },
        {
<<<<<<< HEAD
            "language": "typescript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n    attribute vec4 aPosition;\r\n    attribute vec4 aNormal;\r\n    varying vec4 vColor;\r\n\r\n    uniform mat4 mat;\r\n    void main() {\r\n      // 定义点光源的颜色\r\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\r\n\r\n      // 点光源的位置\r\n      vec3 uPointLightPosition = vec3(-5.0,6.0,10.0);\r\n\r\n      // 环境光\r\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\r\n\r\n      // 物体表面的颜色\r\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\r\n\r\n      // 顶点的世界坐标\r\n      vec4 vertexPosition = mat * aPosition;\r\n\r\n      // 点光源的方向\r\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\r\n\r\n      // 环境反射\r\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\r\n\r\n      // 计算入射角 光线方向和法线方向的点积\r\n      float dotDeg = dot(lightDirection, vec3(aNormal));\r\n\r\n      // 漫反射光的颜色\r\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\r\n\r\n      gl_Position = vertexPosition;\r\n      vColor = vec4(ambient + diffuseColor, aColor.a);\r\n    }\r\n  `; // 顶点着色器\r\n\r\nconst fragment_code = /*glsl */ `\r\n  precision lowp float;\r\n  varying vec4 vColor;\r\n\r\n  void main() {\r\n    gl_FragColor = vColor;\r\n  }\r\n`; // 片元着色器\r\n\r\nconst js_code = /*js*/`\r\n\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const aNormal = gl.getAttribLocation(program, 'aNormal');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n\r\n  const vertices = new Float32Array([\r\n    // 0123\r\n    1, 1, 1,\r\n    -1, 1, 1,\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    // 0345\r\n    1, 1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    // 0156\r\n    1, 1, 1,\r\n    1, 1, -1,\r\n    -1, 1,-1,\r\n    -1, 1,1,\r\n    // 1267\r\n    -1, 1, 1,\r\n    -1,1, -1,\r\n    -1, -1,-1,\r\n    -1,-1,1,\r\n    // 2347\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    -1,-1,-1,\r\n    // 4567\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    -1, 1,-1,\r\n    -1,-1,-1,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n\r\n  // 法向量\r\n  const normals = new Float32Array([\r\n    0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,\r\n    0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,\r\n    -1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,\r\n    1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,\r\n    0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,\r\n    0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,\r\n  ])\r\n  const normalBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aNormal)\r\n\r\n  const indeces = new Uint8Array([\r\n    0,1,2,0,2,3,\r\n    4,5,6,4,6,7,\r\n    8,9,10,8,10,11,\r\n    12,13,14,12,14,15,\r\n    16,17,18,16,18,19,\r\n    20,21,22,20,22,23,\r\n  ])\r\n  const indexBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);\r\n\r\n  const vm = getViewMatrix(3,3,5,0.0,0.0,0.0,0.0,0.6,0.0);\r\n  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\r\n  gl.enable(gl.DEPTH_TEST);\r\n  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));\r\n  gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);\r\n`\r\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require(\"path\");\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code, libs);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          { // 限制变量定义域",
                                "              function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {\r",
                                "  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r",
                                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r",
                                "\r",
                                "  gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE); // 指定顶点着色器的源码\r",
                                "  gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE); // 指定片元着色器的源码\r",
                                "\r",
                                "  // 编译着色器\r",
                                "  gl.compileShader(vertexShader);\r",
                                "  gl.compileShader(fragmentShader);\r",
                                "\r",
                                "  // 创建一个程序对象\r",
                                "  const program = gl.createProgram();\r",
                                "\r",
                                "  gl.attachShader(program, vertexShader);\r",
                                "  gl.attachShader(program, fragmentShader);\r",
                                "\r",
                                "  gl.linkProgram(program);\r",
                                "\r",
                                "  gl.useProgram(program);\r",
                                "\r",
                                "  return program;\r",
                                "}\r",
                                "\r",
                                "// 平移矩阵\r",
                                "function getTranslateMatrix(x = 0, y = 0, z = 0) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1.0, 0.0, 0.0, 0.0,\r",
                                "    0.0, 1.0, 0.0, 0.0,\r",
                                "    0.0, 0.0, 1.0, 0.0,\r",
                                "    x  , y  , z  , 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 缩放矩阵\r",
                                "function getScaleMatrix(x = 1, y = 1, z = 1) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x  , 0.0, 0.0, 0.0,\r",
                                "    0.0, y  , 0.0, 0.0,\r",
                                "    0.0, 0.0, z  , 0.0,\r",
                                "    0.0, 0.0, 0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 绕z轴旋转的旋转矩阵\r",
                                "function getRotateMatrix(deg) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    Math.cos(deg),  Math.sin(deg), 0.0,0.0,\r",
                                "    -Math.sin(deg), Math.cos(deg), 0.0,0.0,\r",
                                "    0.0,            0.0,           1.0,0.0,\r",
                                "    0.0,            0.0,           0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 矩阵复合函数\r",
                                "function mixMatrix(A, B) {\r",
                                "  const result = new Float32Array(16);\r",
                                "\r",
                                "  for (let i = 0; i < 4; i++) {\r",
                                "    result[i] =\r",
                                "      A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3];\r",
                                "    result[i + 4] =\r",
                                "      A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7];\r",
                                "    result[i + 8] =\r",
                                "      A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11];\r",
                                "    result[i + 12] =\r",
                                "      A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15];\r",
                                "  }\r",
                                "\r",
                                "  return result;\r",
                                "}\r",
                                "\r",
                                "// 归一化函数\r",
                                "function normalized(arr) {\r",
                                "  let sum = 0;\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    sum += arr[i] * arr[i];\r",
                                "  }\r",
                                "\r",
                                "  const middle = Math.sqrt(sum);\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    arr[i] = arr[i] / middle;\r",
                                "  }\r",
                                "}\r",
                                "\r",
                                "// 叉积函数 获取法向量\r",
                                "function cross(a, b) {\r",
                                "  return new Float32Array([\r",
                                "    a[1] * b[2] - a[2] * b[1],\r",
                                "    a[2] * b[0] - a[0] * b[2],\r",
                                "    a[0] * b[1] - a[1] * b[0],\r",
                                "  ]);\r",
                                "}\r",
                                "\r",
                                "// 点积函数 获取投影长度\r",
                                "function dot(a, b) {\r",
                                "  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r",
                                "}\r",
                                "\r",
                                "// 向量差\r",
                                "function minus(a, b) {\r",
                                "  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);\r",
                                "}\r",
                                "\r",
                                "// 视图矩阵获取\r",
                                "function getViewMatrix(\r",
                                "  eyex,\r",
                                "  eyey,\r",
                                "  eyez,\r",
                                "  lookAtx,\r",
                                "  lookAty,\r",
                                "  lookAtz,\r",
                                "  upx,\r",
                                "  upy,\r",
                                "  upz\r",
                                ") {\r",
                                "  // 视点\r",
                                "  const eye = new Float32Array([eyex, eyey, eyez]);\r",
                                "  // 目标点\r",
                                "  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\r",
                                "  // 上方向\r",
                                "  const up = new Float32Array([upx, upy, upz]);\r",
                                "\r",
                                "  // 确定z轴\r",
                                "  const z = minus(eye, lookAt);\r",
                                "\r",
                                "  normalized(z);\r",
                                "  normalized(up);\r",
                                "\r",
                                "  // 确定x轴\r",
                                "  const x = cross(z, up);\r",
                                "\r",
                                "  normalized(x);\r",
                                "  // 确定y轴\r",
                                "  const y = cross(x, z);\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x[0],       y[0],       z[0],       0,\r",
                                "    x[1],       y[1],       z[1],       0,\r",
                                "    x[2],       y[2],       z[2],       0,\r",
                                "    -dot(x,eye),-dot(y,eye),-dot(z,eye),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取正射投影矩阵\r",
                                "function getOrtho(l, r, t, b, n, f) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    2 / (r - l), 0,           0,           0,\r",
                                "    0,           2/(t-b),     0,           0,\r",
                                "    0,           0,           -2/(f-n),    0,\r",
                                "    -(r+l)/(r-l),-(t+b)/(t-b),-(f+n)/(f-n),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "\r",
                                "// 获取透视投影矩阵\r",
                                "function getPerspective(fov, aspect, far, near) {\r",
                                "  fov = (fov * Math.PI) / 180;\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1/(aspect*Math.tan(fov / 2)), 0,                   0,                      0,\r",
                                "    0,                            1/(Math.tan(fov/2)), 0,                      0,\r",
                                "    0,                            0,                   -(far+near)/(far-near), -(2*far*near)/(far-near),\r",
                                "    0,                            0,                   -1,                     0,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "function distanceSelf(a, b) {\r",
                                "  const x = a[0] - b[0];\r",
                                "  const y = a[1] - b[1];\r",
                                "  const z = a[2] - b[2];\r",
                                "\r",
                                "  const v = x * x + y * y + z * z;\r",
                                "\r",
                                "  return Math.sqrt(v);\r",
                                "}\r",
                                "",
                                "          }",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"e4feabc0-c676-11ee-ab0e-c794e170a75e\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('e4feabc0-c676-11ee-ab0e-c794e170a75e');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    attribute vec4 aNormal;\\n    varying vec4 vColor;\\n\\n    uniform mat4 mat;\\n    void main() {\\n      // 定义点光源的颜色\\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\\n\\n      // 点光源的位置\\n      vec3 uPointLightPosition = vec3(-5.0,6.0,10.0);\\n\\n      // 环境光\\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\\n\\n      // 物体表面的颜色\\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\\n\\n      // 顶点的世界坐标\\n      vec4 vertexPosition = mat * aPosition;\\n\\n      // 点光源的方向\\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\\n\\n      // 环境反射\\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\\n\\n      // 计算入射角 光线方向和法线方向的点积\\n      float dotDeg = dot(lightDirection, vec3(aNormal));\\n\\n      // 漫反射光的颜色\\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\\n\\n      gl_Position = vertexPosition;\\n      vColor = vec4(ambient + diffuseColor, aColor.a);\\n    }\\n  \"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n  precision lowp float;\\n  varying vec4 vColor;\\n\\n  void main() {\\n    gl_FragColor = vColor;\\n  }\\n\"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const aNormal = gl.getAttribLocation(program, 'aNormal');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "",
                                "  const vertices = new Float32Array([",
                                "    // 0123",
                                "    1, 1, 1,",
                                "    -1, 1, 1,",
                                "    -1,-1, 1,",
                                "    1,-1, 1,",
                                "    // 0345",
                                "    1, 1, 1,",
                                "    1,-1, 1,",
                                "    1,-1,-1,",
                                "    1, 1,-1,",
                                "    // 0156",
                                "    1, 1, 1,",
                                "    1, 1, -1,",
                                "    -1, 1,-1,",
                                "    -1, 1,1,",
                                "    // 1267",
                                "    -1, 1, 1,",
                                "    -1,1, -1,",
                                "    -1, -1,-1,",
                                "    -1,-1,1,",
                                "    // 2347",
                                "    -1,-1, 1,",
                                "    1,-1, 1,",
                                "    1,-1,-1,",
                                "    -1,-1,-1,",
                                "    // 4567",
                                "    1,-1,-1,",
                                "    1, 1,-1,",
                                "    -1, 1,-1,",
                                "    -1,-1,-1,",
                                "  ])",
                                "",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "",
                                "  // 法向量",
                                "  const normals = new Float32Array([",
                                "    0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,",
                                "    0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,",
                                "    -1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,",
                                "    1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,",
                                "    0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,",
                                "    0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,",
                                "  ])",
                                "  const normalBuffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aNormal)",
                                "",
                                "  const indeces = new Uint8Array([",
                                "    0,1,2,0,2,3,",
                                "    4,5,6,4,6,7,",
                                "    8,9,10,8,10,11,",
                                "    12,13,14,12,14,15,",
                                "    16,17,18,16,18,19,",
                                "    20,21,22,20,22,23,",
                                "  ])",
                                "  const indexBuffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);",
                                "  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);",
                                "",
                                "  const vm = getViewMatrix(3,3,5,0.0,0.0,0.0,0.0,0.6,0.0);",
                                "  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);",
                                "  gl.enable(gl.DEPTH_TEST);",
                                "  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));",
                                "  gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### 拾取\r\n\r\n点击时，设置某个 uniform 的值，并且改变渲染颜色\r\n读取当前点击位置的像素，如果符合自定义像素，则为选中物体\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 雾化\r\n\r\n雾化，用来表示距离越远看的越模糊的现象。\r\n\r\n雾化实现是通过某点和视点之间的距离，距离越远雾化程度越⾼。这种雾化也称为线性雾化。某一点的雾化程度也成为雾化因⼦。\r\n\r\n![](./img/2024-02-08-20-12-19.png)\r\n\r\n雾化因子计算：雾化因子 = （终点 - 当前点） / （终点 - 起点）\r\n\r\n\r\n物体颜色计算：颜色 = 物体颜色 * 雾化因子 + 雾化颜色 * （ 1 - 雾化因子）\r\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const vertex_code = /*glsl */ `\r\n    attribute vec4 aPosition;\r\n    attribute vec4 aNormal;\r\n    varying vec4 vColor;\r\n\r\n    varying float vDist;\r\n\r\n    uniform mat4 mat;\r\n    void main() {\r\n      // 定义点光源的颜色\r\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\r\n\r\n      // 点光源的位置\r\n      vec3 uPointLightPosition = vec3(-5.2,5.6,5.0);\r\n\r\n      // 环境光\r\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\r\n\r\n      // 物体表面的颜色\r\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\r\n\r\n      // 顶点的世界坐标\r\n      vec4 vertexPosition = mat * aPosition;\r\n\r\n      // 点光源的方向\r\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\r\n\r\n      // 环境反射\r\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\r\n\r\n      // 计算入射角 光线方向和法线方向的点积\r\n      float dotDeg = dot(lightDirection, vec3(aNormal));\r\n\r\n      // 漫反射光的颜色\r\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\r\n\r\n      gl_Position = vertexPosition;\r\n      vColor = vec4(ambient + diffuseColor, aColor.a);\r\n      vDist = gl_Position.w;\r\n    }\r\n  `; // 顶点着色器\r\n\r\nconst fragment_code = /*glsl */ `\r\n    precision lowp float;\r\n    varying vec4 vColor;\r\n    varying float vDist;\r\n\r\n    // 雾化颜色\r\n    uniform vec3 uFogColor;\r\n    // 起点到终点的距离 第一个参数是起点   第二个是终点\r\n    uniform vec2 uFogDist;\r\n\r\n    void main() {\r\n      // 计算雾化因子\r\n      float fogFactor = (uFogDist.y - vDist) / (uFogDist.y - uFogDist.x);\r\n\r\n      // 看到的颜色是什么 物体颜色*雾化因子+雾化颜色*（1-雾化因子）\r\n      // mix 线性混合计算  mix(x,y,a) => { x * (1-a) + y * a }\r\n      vec3 color = mix(uFogColor, vec3(vColor), fogFactor);\r\n      gl_FragColor = vec4(color, vColor.a);\r\n    }\r\n  `; // 片元着色器\r\n\r\nconst js_code = /*js*/ `\r\n\r\n  const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n  const aNormal = gl.getAttribLocation(program, 'aNormal');\r\n  const mat = gl.getUniformLocation(program, 'mat');\r\n\r\n  const vertices = new Float32Array([\r\n    // 0123\r\n    1, 1, 1,\r\n    -1, 1, 1,\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    // 0345\r\n    1, 1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    // 0156\r\n    1, 1, 1,\r\n    1, 1, -1,\r\n    -1, 1,-1,\r\n    -1, 1,1,\r\n    // 1267\r\n    -1, 1, 1,\r\n    -1,1, -1,\r\n    -1, -1,-1,\r\n    -1,-1,1,\r\n    // 2347\r\n    -1,-1, 1,\r\n    1,-1, 1,\r\n    1,-1,-1,\r\n    -1,-1,-1,\r\n    // 4567\r\n    1,-1,-1,\r\n    1, 1,-1,\r\n    -1, 1,-1,\r\n    -1,-1,-1,\r\n  ])\r\n\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aPosition)\r\n\r\n  // 法向量\r\n  const normals = new Float32Array([\r\n    0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,\r\n    0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,\r\n    -1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,\r\n    1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,\r\n    0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,\r\n    0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,\r\n  ])\r\n  const normalBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\r\n  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);\r\n  gl.enableVertexAttribArray(aNormal)\r\n\r\n  const indeces = new Uint8Array([\r\n    0,1,2,0,2,3,\r\n    4,5,6,4,6,7,\r\n    8,9,10,8,10,11,\r\n    12,13,14,12,14,15,\r\n    16,17,18,16,18,19,\r\n    20,21,22,20,22,23,\r\n  ])\r\n  const indexBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);\r\n\r\n  const start = 0;\r\n  const end = 200;\r\n  const fogColor = new Float32Array([0.0,0.0,0.0]);\r\n  const fogDist = new Float32Array([start, end]);\r\n\r\n  const uFogColor = gl.getUniformLocation(program, 'uFogColor');\r\n  const uFogDist = gl.getUniformLocation(program, 'uFogDist');\r\n\r\n  gl.uniform3fv(uFogColor, fogColor);\r\n\r\n  const vm = getViewMatrix(3,3,5,0.0,0.0,0.0,0.0,0.6,0.0);\r\n  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\r\n  gl.enable(gl.DEPTH_TEST);\r\n  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));\r\n\r\n\r\n  function draw() {\r\n    fogDist[1] -= 1;\r\n    if (fogDist[1] < start) {\r\n      fogDist[1] = end;\r\n    }\r\n    gl.uniform2fv(uFogDist, fogDist);\r\n\r\n    gl.clearColor(0.0,0.0,0.0,1.0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);\r\n\r\n    requestAnimationFrame(draw)\r\n  }\r\n\r\n  draw();\r\n`;\r\n\r\nconst { renderWebgl, getLibs } = require(\"../../src/display.js\");\r\nconst path = require(\"path\");\r\nconst libs = getLibs(path.resolve(__dirname, \"../../src/libs.js\"));\r\nrenderWebgl(vertex_code, fragment_code, js_code, libs);\r\n\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/html",
                            "value": [
                                "<style> table, th, tr { text-align: left; }</style>",
                                "      <script>",
                                "          { // 限制变量定义域",
                                "              function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {\r",
                                "  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r",
                                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r",
                                "\r",
                                "  gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE); // 指定顶点着色器的源码\r",
                                "  gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE); // 指定片元着色器的源码\r",
                                "\r",
                                "  // 编译着色器\r",
                                "  gl.compileShader(vertexShader);\r",
                                "  gl.compileShader(fragmentShader);\r",
                                "\r",
                                "  // 创建一个程序对象\r",
                                "  const program = gl.createProgram();\r",
                                "\r",
                                "  gl.attachShader(program, vertexShader);\r",
                                "  gl.attachShader(program, fragmentShader);\r",
                                "\r",
                                "  gl.linkProgram(program);\r",
                                "\r",
                                "  gl.useProgram(program);\r",
                                "\r",
                                "  return program;\r",
                                "}\r",
                                "\r",
                                "// 平移矩阵\r",
                                "function getTranslateMatrix(x = 0, y = 0, z = 0) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1.0, 0.0, 0.0, 0.0,\r",
                                "    0.0, 1.0, 0.0, 0.0,\r",
                                "    0.0, 0.0, 1.0, 0.0,\r",
                                "    x  , y  , z  , 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 缩放矩阵\r",
                                "function getScaleMatrix(x = 1, y = 1, z = 1) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x  , 0.0, 0.0, 0.0,\r",
                                "    0.0, y  , 0.0, 0.0,\r",
                                "    0.0, 0.0, z  , 0.0,\r",
                                "    0.0, 0.0, 0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "// 绕z轴旋转的旋转矩阵\r",
                                "function getRotateMatrix(deg) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    Math.cos(deg),  Math.sin(deg), 0.0,0.0,\r",
                                "    -Math.sin(deg), Math.cos(deg), 0.0,0.0,\r",
                                "    0.0,            0.0,           1.0,0.0,\r",
                                "    0.0,            0.0,           0.0, 1,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 矩阵复合函数\r",
                                "function mixMatrix(A, B) {\r",
                                "  const result = new Float32Array(16);\r",
                                "\r",
                                "  for (let i = 0; i < 4; i++) {\r",
                                "    result[i] =\r",
                                "      A[i] * B[0] + A[i + 4] * B[1] + A[i + 8] * B[2] + A[i + 12] * B[3];\r",
                                "    result[i + 4] =\r",
                                "      A[i] * B[4] + A[i + 4] * B[5] + A[i + 8] * B[6] + A[i + 12] * B[7];\r",
                                "    result[i + 8] =\r",
                                "      A[i] * B[8] + A[i + 4] * B[9] + A[i + 8] * B[10] + A[i + 12] * B[11];\r",
                                "    result[i + 12] =\r",
                                "      A[i] * B[12] + A[i + 4] * B[13] + A[i + 8] * B[14] + A[i + 12] * B[15];\r",
                                "  }\r",
                                "\r",
                                "  return result;\r",
                                "}\r",
                                "\r",
                                "// 归一化函数\r",
                                "function normalized(arr) {\r",
                                "  let sum = 0;\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    sum += arr[i] * arr[i];\r",
                                "  }\r",
                                "\r",
                                "  const middle = Math.sqrt(sum);\r",
                                "\r",
                                "  for (let i = 0; i < arr.length; i++) {\r",
                                "    arr[i] = arr[i] / middle;\r",
                                "  }\r",
                                "}\r",
                                "\r",
                                "// 叉积函数 获取法向量\r",
                                "function cross(a, b) {\r",
                                "  return new Float32Array([\r",
                                "    a[1] * b[2] - a[2] * b[1],\r",
                                "    a[2] * b[0] - a[0] * b[2],\r",
                                "    a[0] * b[1] - a[1] * b[0],\r",
                                "  ]);\r",
                                "}\r",
                                "\r",
                                "// 点积函数 获取投影长度\r",
                                "function dot(a, b) {\r",
                                "  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r",
                                "}\r",
                                "\r",
                                "// 向量差\r",
                                "function minus(a, b) {\r",
                                "  return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);\r",
                                "}\r",
                                "\r",
                                "// 视图矩阵获取\r",
                                "function getViewMatrix(\r",
                                "  eyex,\r",
                                "  eyey,\r",
                                "  eyez,\r",
                                "  lookAtx,\r",
                                "  lookAty,\r",
                                "  lookAtz,\r",
                                "  upx,\r",
                                "  upy,\r",
                                "  upz\r",
                                ") {\r",
                                "  // 视点\r",
                                "  const eye = new Float32Array([eyex, eyey, eyez]);\r",
                                "  // 目标点\r",
                                "  const lookAt = new Float32Array([lookAtx, lookAty, lookAtz]);\r",
                                "  // 上方向\r",
                                "  const up = new Float32Array([upx, upy, upz]);\r",
                                "\r",
                                "  // 确定z轴\r",
                                "  const z = minus(eye, lookAt);\r",
                                "\r",
                                "  normalized(z);\r",
                                "  normalized(up);\r",
                                "\r",
                                "  // 确定x轴\r",
                                "  const x = cross(z, up);\r",
                                "\r",
                                "  normalized(x);\r",
                                "  // 确定y轴\r",
                                "  const y = cross(x, z);\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    x[0],       y[0],       z[0],       0,\r",
                                "    x[1],       y[1],       z[1],       0,\r",
                                "    x[2],       y[2],       z[2],       0,\r",
                                "    -dot(x,eye),-dot(y,eye),-dot(z,eye),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "// 获取正射投影矩阵\r",
                                "function getOrtho(l, r, t, b, n, f) {\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    2 / (r - l), 0,           0,           0,\r",
                                "    0,           2/(t-b),     0,           0,\r",
                                "    0,           0,           -2/(f-n),    0,\r",
                                "    -(r+l)/(r-l),-(t+b)/(t-b),-(f+n)/(f-n),1\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "\r",
                                "// 获取透视投影矩阵\r",
                                "function getPerspective(fov, aspect, far, near) {\r",
                                "  fov = (fov * Math.PI) / 180;\r",
                                "  // prettier-ignore\r",
                                "  return new Float32Array([\r",
                                "    1/(aspect*Math.tan(fov / 2)), 0,                   0,                      0,\r",
                                "    0,                            1/(Math.tan(fov/2)), 0,                      0,\r",
                                "    0,                            0,                   -(far+near)/(far-near), -(2*far*near)/(far-near),\r",
                                "    0,                            0,                   -1,                     0,\r",
                                "  ])\r",
                                "}\r",
                                "\r",
                                "function distanceSelf(a, b) {\r",
                                "  const x = a[0] - b[0];\r",
                                "  const y = a[1] - b[1];\r",
                                "  const z = a[2] - b[2];\r",
                                "\r",
                                "  const v = x * x + y * y + z * z;\r",
                                "\r",
                                "  return Math.sqrt(v);\r",
                                "}\r",
                                "",
                                "          }",
                                "      </script>",
                                "  ",
                                "        <canvas id=\"214309f0-c67c-11ee-ab0e-c794e170a75e\" width=\"400\" height=\"400\" style=\"border:1px solid grey\">",
                                "            此浏览器不支持canvas",
                                "        </canvas>",
                                "        <script>",
                                "            { // 限制变量定义域",
                                "                ",
                                "        const ctx = document.getElementById('214309f0-c67c-11ee-ab0e-c794e170a75e');",
                                "        const gl = ctx.getContext('webgl');",
                                "        const vertexShader = gl.createShader(gl.VERTEX_SHADER);",
                                "        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                                "    ",
                                "        gl.shaderSource(vertexShader,  \"\\n    attribute vec4 aPosition;\\n    attribute vec4 aNormal;\\n    varying vec4 vColor;\\n\\n    varying float vDist;\\n\\n    uniform mat4 mat;\\n    void main() {\\n      // 定义点光源的颜色\\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\\n\\n      // 点光源的位置\\n      vec3 uPointLightPosition = vec3(-5.2,5.6,5.0);\\n\\n      // 环境光\\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\\n\\n      // 物体表面的颜色\\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\\n\\n      // 顶点的世界坐标\\n      vec4 vertexPosition = mat * aPosition;\\n\\n      // 点光源的方向\\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\\n\\n      // 环境反射\\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\\n\\n      // 计算入射角 光线方向和法线方向的点积\\n      float dotDeg = dot(lightDirection, vec3(aNormal));\\n\\n      // 漫反射光的颜色\\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\\n\\n      gl_Position = vertexPosition;\\n      vColor = vec4(ambient + diffuseColor, aColor.a);\\n      vDist = gl_Position.w;\\n    }\\n  \"); // 指定顶点着色器的源码",
                                "        gl.shaderSource(fragmentShader,  \"\\n    precision lowp float;\\n    varying vec4 vColor;\\n    varying float vDist;\\n\\n    // 雾化颜色\\n    uniform vec3 uFogColor;\\n    // 起点到终点的距离 第一个参数是起点   第二个是终点\\n    uniform vec2 uFogDist;\\n\\n    void main() {\\n      // 计算雾化因子\\n      float fogFactor = (uFogDist.y - vDist) / (uFogDist.y - uFogDist.x);\\n\\n      // 看到的颜色是什么 物体颜色*雾化因子+雾化颜色*（1-雾化因子）\\n      // mix 线性混合计算  mix(x,y,a) => { x * (1-a) + y * a }\\n      vec3 color = mix(uFogColor, vec3(vColor), fogFactor);\\n      gl_FragColor = vec4(color, vColor.a);\\n    }\\n  \"); // 指定片元着色器的源码",
                                "    ",
                                "        // 编译着色器",
                                "        gl.compileShader(vertexShader);",
                                "        gl.compileShader(fragmentShader);",
                                "    ",
                                "        // 创建一个程序对象",
                                "        const program = gl.createProgram();",
                                "    ",
                                "        gl.attachShader(program, vertexShader);",
                                "        gl.attachShader(program, fragmentShader);",
                                "    ",
                                "        gl.linkProgram(program);",
                                "    ",
                                "        gl.useProgram(program);",
                                "    ",
                                "",
                                "  const aPosition = gl.getAttribLocation(program, 'aPosition');",
                                "  const aNormal = gl.getAttribLocation(program, 'aNormal');",
                                "  const mat = gl.getUniformLocation(program, 'mat');",
                                "",
                                "  const vertices = new Float32Array([",
                                "    // 0123",
                                "    1, 1, 1,",
                                "    -1, 1, 1,",
                                "    -1,-1, 1,",
                                "    1,-1, 1,",
                                "    // 0345",
                                "    1, 1, 1,",
                                "    1,-1, 1,",
                                "    1,-1,-1,",
                                "    1, 1,-1,",
                                "    // 0156",
                                "    1, 1, 1,",
                                "    1, 1, -1,",
                                "    -1, 1,-1,",
                                "    -1, 1,1,",
                                "    // 1267",
                                "    -1, 1, 1,",
                                "    -1,1, -1,",
                                "    -1, -1,-1,",
                                "    -1,-1,1,",
                                "    // 2347",
                                "    -1,-1, 1,",
                                "    1,-1, 1,",
                                "    1,-1,-1,",
                                "    -1,-1,-1,",
                                "    // 4567",
                                "    1,-1,-1,",
                                "    1, 1,-1,",
                                "    -1, 1,-1,",
                                "    -1,-1,-1,",
                                "  ])",
                                "",
                                "  const buffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aPosition)",
                                "",
                                "  // 法向量",
                                "  const normals = new Float32Array([",
                                "    0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,",
                                "    0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,",
                                "    -1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,",
                                "    1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,",
                                "    0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,",
                                "    0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,",
                                "  ])",
                                "  const normalBuffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);",
                                "  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);",
                                "  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);",
                                "  gl.enableVertexAttribArray(aNormal)",
                                "",
                                "  const indeces = new Uint8Array([",
                                "    0,1,2,0,2,3,",
                                "    4,5,6,4,6,7,",
                                "    8,9,10,8,10,11,",
                                "    12,13,14,12,14,15,",
                                "    16,17,18,16,18,19,",
                                "    20,21,22,20,22,23,",
                                "  ])",
                                "  const indexBuffer = gl.createBuffer();",
                                "  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);",
                                "  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);",
                                "",
                                "  const start = 0;",
                                "  const end = 200;",
                                "  const fogColor = new Float32Array([0.0,0.0,0.0]);",
                                "  const fogDist = new Float32Array([start, end]);",
                                "",
                                "  const uFogColor = gl.getUniformLocation(program, 'uFogColor');",
                                "  const uFogDist = gl.getUniformLocation(program, 'uFogDist');",
                                "",
                                "  gl.uniform3fv(uFogColor, fogColor);",
                                "",
                                "  const vm = getViewMatrix(3,3,5,0.0,0.0,0.0,0.0,0.6,0.0);",
                                "  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);",
                                "  gl.enable(gl.DEPTH_TEST);",
                                "  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));",
                                "",
                                "",
                                "  function draw() {",
                                "    fogDist[1] -= 1;",
                                "    if (fogDist[1] < start) {",
                                "      fogDist[1] = end;",
                                "    }",
                                "    gl.uniform2fv(uFogDist, fogDist);",
                                "",
                                "    gl.clearColor(0.0,0.0,0.0,1.0);",
                                "    gl.clear(gl.COLOR_BUFFER_BIT);",
                                "",
                                "    gl.enable(gl.DEPTH_TEST);",
                                "    gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);",
                                "",
                                "    requestAnimationFrame(draw)",
                                "  }",
                                "",
                                "  draw();",
                                "",
                                "            }",
                                "        </script>",
                                "    "
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
=======
            "language": "html",
            "source": [
                "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Title</title>\n    <script src=\"../lib/index.js\"></script>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n      }\n\n      canvas {\n        margin: 50px auto 0;\n        display: block;\n        background: yellow;\n      }\n    </style>\n  </head>\n  <body>\n    <canvas id=\"canvas\" width=\"400\" height=\"400\"> 此浏览器不支持canvas </canvas>\n  </body>\n</html>\n<script>\n  const ctx = document.getElementById(\"canvas\");\n\n  const gl = ctx.getContext(\"webgl\");\n\n  // 创建着色器源码\n  const VERTEX_SHADER_SOURCE = /*glsl*/ `\n    attribute vec4 aPosition;\n    attribute vec4 aNormal;\n    varying vec4 vColor;\n\n    uniform mat4 mat;\n    void main() {\n      // 定义点光源的颜色\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\n\n      // 点光源的位置\n      vec3 uPointLightPosition = vec3(-5.0,6.0,10.0);\n\n      // 环境光\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\n\n      // 物体表面的颜色\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\n\n      // 顶点的世界坐标\n      vec4 vertexPosition = mat * aPosition;\n\n      // 点光源的方向\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\n\n      // 环境反射\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\n\n      // 计算入射角 光线方向和法线方向的点积\n      float dotDeg = dot(lightDirection, vec3(aNormal));\n\n      // 漫反射光的颜色\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\n\n      gl_Position = vertexPosition;\n      vColor = vec4(ambient + diffuseColor, aColor.a);\n    }\n  `; // 顶点着色器\n\n  const FRAGMENT_SHADER_SOURCE = `\n    precision lowp float;\n    varying vec4 vColor;\n\n    void main() {\n      gl_FragColor = vColor;\n    }\n  `; // 片元着色器\n\n  const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE);\n\n  const aPosition = gl.getAttribLocation(program, \"aPosition\");\n  const aNormal = gl.getAttribLocation(program, \"aNormal\");\n  const mat = gl.getUniformLocation(program, \"mat\");\n\n  const vertices = new Float32Array([\n    // 0123\n    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1,\n    // 0345\n    1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,\n    // 0156\n    1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1,\n    // 1267\n    -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1,\n    // 2347\n    -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1,\n    // 4567\n    1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1,\n  ]);\n\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition);\n\n  // 法向量\n  const normals = new Float32Array([\n    0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0,\n    0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, -1.0, 0.0, 0.0, -1.0, 0.0,\n    0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,\n    0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,\n    0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,\n  ]);\n  const normalBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aNormal);\n\n  const indeces = new Uint8Array([\n    0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14,\n    15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23,\n  ]);\n  const indexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);\n\n  const vm = getViewMatrix(3, 3, 5, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0);\n  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\n  gl.enable(gl.DEPTH_TEST);\n  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));\n  gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);\n</script>\n"
            ],
            "outputs": []
>>>>>>> f95daa79deee13da833f7c14ccac32d9e9161b9b
        }
    ]
}