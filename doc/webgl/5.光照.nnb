{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "点光源光线：一个点向周围发出的光，如灯泡、火焰等。\n定义⼀个点光源光需要光源的位置、光线方向以及颜⾊。\n根据照射点的位置不同，光线的⽅向也不同。                      \n\n\n平行光：可以看成是无限远处的光源发出的光，如太阳光。\n因为离光源的位置特别远，所以到达被照物体时可以认为光线是平行的。\n只需要光照方向和光照颜色\n\n环境光：也就是间接光，是指光源发出后，经过其他物体各种发射，然后照到物体表面上的光线。\n环境光的强度差距非常小，没有必要精确计算光线强度。\n环境光是均匀照射到物体表⾯的，只需要定义光照颜色\n\n环境反射：环境反射是针对环境光而言的，在环境反射中，环境光照射物体是各方面均匀、强度相等的，反射的方向就是入射光的反方向。\n\n最终物体的颜色只跟入射光颜色和基底色有关。\n<环境反射光颜色>=<入射光颜色>*<表面基底色>\n \n\n 漫反射中反射光的颜色除了取决于入射光的颜色、表面的基底色，还有入射光与物体表面的法向量形成的入射角。\n令入射角为 α，漫反射光的颜色可以根据下式计算：\n<漫反射光颜色>=<⼊射光颜色>*<表面基底色>* cosα\n入射角 α 可以通过 光线方向和法线方向 的点积来计算：\n<光线方向>·<法线方向> = cosα\n<漫反射光颜⾊>=<入射光颜色>*<表⾯基底色>* (<光线方向>*<法线方向>)\n“光线方向”指的是⼊射方向的反方向，即从入射点指向光源方向。\n\n当漫反射和环境反射同时存在时，将两者加起来，就会得到物体最终被观察到的颜色：\n<表面的反射光颜色> = <漫反射光颜色>+<环境反射光颜色>\n\n"
            ],
            "outputs": []
        },
        {
            "language": "html",
            "source": [
                "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Title</title>\n    <script src=\"../lib/index.js\"></script>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n      }\n\n      canvas {\n        margin: 50px auto 0;\n        display: block;\n        background: yellow;\n      }\n    </style>\n  </head>\n  <body>\n    <canvas id=\"canvas\" width=\"400\" height=\"400\"> 此浏览器不支持canvas </canvas>\n  </body>\n</html>\n<script>\n  const ctx = document.getElementById(\"canvas\");\n\n  const gl = ctx.getContext(\"webgl\");\n\n  // 创建着色器源码\n  const VERTEX_SHADER_SOURCE = /*glsl*/ `\n    attribute vec4 aPosition;\n    attribute vec4 aNormal;\n    varying vec4 vColor;\n\n    uniform mat4 mat;\n    void main() {\n      // 定义点光源的颜色\n      vec3 uPointLightColor = vec3(1.0,1.0,0.0);\n\n      // 点光源的位置\n      vec3 uPointLightPosition = vec3(-5.0,6.0,10.0);\n\n      // 环境光\n      vec3 uAmbientLightColor = vec3(0.2,0.2,0.2);\n\n      // 物体表面的颜色\n      vec4 aColor = vec4(1.0,0.0,0.0,1.0);\n\n      // 顶点的世界坐标\n      vec4 vertexPosition = mat * aPosition;\n\n      // 点光源的方向\n      vec3 lightDirection = normalize(uPointLightPosition - vec3(vertexPosition));\n\n      // 环境反射\n      vec3 ambient = uAmbientLightColor * vec3(aColor);\n\n      // 计算入射角 光线方向和法线方向的点积\n      float dotDeg = dot(lightDirection, vec3(aNormal));\n\n      // 漫反射光的颜色\n      vec3 diffuseColor = uPointLightColor * vec3(aColor) * dotDeg;\n\n      gl_Position = vertexPosition;\n      vColor = vec4(ambient + diffuseColor, aColor.a);\n    }\n  `; // 顶点着色器\n\n  const FRAGMENT_SHADER_SOURCE = `\n    precision lowp float;\n    varying vec4 vColor;\n\n    void main() {\n      gl_FragColor = vColor;\n    }\n  `; // 片元着色器\n\n  const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE);\n\n  const aPosition = gl.getAttribLocation(program, \"aPosition\");\n  const aNormal = gl.getAttribLocation(program, \"aNormal\");\n  const mat = gl.getUniformLocation(program, \"mat\");\n\n  const vertices = new Float32Array([\n    // 0123\n    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1,\n    // 0345\n    1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,\n    // 0156\n    1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1,\n    // 1267\n    -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1,\n    // 2347\n    -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1,\n    // 4567\n    1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1,\n  ]);\n\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aPosition);\n\n  // 法向量\n  const normals = new Float32Array([\n    0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0,\n    0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, -1.0, 0.0, 0.0, -1.0, 0.0,\n    0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,\n    0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,\n    0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,\n  ]);\n  const normalBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(aNormal);\n\n  const indeces = new Uint8Array([\n    0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14,\n    15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23,\n  ]);\n  const indexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);\n\n  const vm = getViewMatrix(3, 3, 5, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0);\n  const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);\n  gl.enable(gl.DEPTH_TEST);\n  gl.uniformMatrix4fv(mat, false, mixMatrix(perspective, vm));\n  gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);\n</script>\n"
            ],
            "outputs": []
        }
    ]
}