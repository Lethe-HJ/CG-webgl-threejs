{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "# 堆\r\n\r\n![alt text](./img/image10.png)\r\n\r\n堆的特点:\r\n1. 堆是一种特殊的完全二叉树\r\n2. 所有的节点都大于等于(最大堆)或小于等于(最小堆)它的子节点\r\n\r\n\r\n```js\r\nclass MinHeap {\r\n    constructor() {\r\n        this.heap = [];\r\n    }\r\n    swap(i1, i2) {\r\n        const temp = this.heap[i1];\r\n        this.heap[i1] = this.heap[i2];\r\n        this.heap[i2] = temp;\r\n    }\r\n    getParentIndex(i) {\r\n        return (i - 1) >> 1;\r\n    }\r\n    getLeftIndex(i) {\r\n        return i * 2 + 1;\r\n    }\r\n    getRightIndex(i) {\r\n        return i * 2 + 2;\r\n    }\r\n    shiftUp(index) {\r\n        if (index == 0) { return; }\r\n        const parentIndex = this.getParentIndex(index);\r\n        if (this.heap[parentIndex] > this.heap[index]) {\r\n            this.swap(parentIndex, index);\r\n            this.shiftUp(parentIndex);\r\n        }\r\n    }\r\n    shiftDown(index) {\r\n        const leftIndex = this.getLeftIndex(index);\r\n        const rightIndex = this.getRightIndex(index);\r\n        if (this.heap[leftIndex] < this.heap[index]) {\r\n            this.swap(leftIndex, index);\r\n            this.shiftDown(leftIndex);\r\n        }\r\n        if (this.heap[rightIndex] < this.heap[index]) {\r\n            this.swap(rightIndex, index);\r\n            this.shiftDown(rightIndex);\r\n        }\r\n    }\r\n    insert(value) {\r\n        this.heap.push(value);\r\n        this.shiftUp(this.heap.length - 1);\r\n    }\r\n    pop() {\r\n        this.heap[0] = this.heap.pop();\r\n        this.shiftDown(0);\r\n    }\r\n    peek() {\r\n        return this.heap[0];\r\n    }\r\n    size() {\r\n        return this.heap.length;\r\n    }\r\n}\r\n\r\nconst h = new MinHeap();\r\nh.insert(3);\r\nh.insert(2);\r\nh.insert(1);\r\nh.pop();\r\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 题目 215. 数组中的第 K 个最大元素\r\n\r\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\r\n\r\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\r\n\r\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\r\n\r\n示例 1:\r\n\r\n输入: [3,2,1,5,6,4], k = 2\r\n输出: 5\r\n示例 2:\r\n\r\n输入: [3,2,3,1,2,4,5,5,6], k = 4\r\n输出: 4\r\n\r\n提示：\r\n\r\n1 <= k <= nums.length <= 105\r\n-104 <= nums[i] <= 104\r\n\r\n```js\r\nclass MinHeap {\r\n  constructor() {\r\n    this.heap = [];\r\n  }\r\n  swap(i1, i2) {\r\n    const temp = this.heap[i1];\r\n    this.heap[i1] = this.heap[i2];\r\n    this.heap[i2] = temp;\r\n  }\r\n  getParentIndex(i) {\r\n    return (i - 1) >> 1;\r\n  }\r\n  getLeftIndex(i) {\r\n    return i * 2 + 1;\r\n  }\r\n  getRightIndex(i) {\r\n    return i * 2 + 2;\r\n  }\r\n  shiftUp(index) {\r\n    if (index == 0) {\r\n      return;\r\n    }\r\n    const parentIndex = this.getParentIndex(index);\r\n    if (this.heap[parentIndex] > this.heap[index]) {\r\n      this.swap(parentIndex, index);\r\n      this.shiftUp(parentIndex);\r\n    }\r\n  }\r\n  shiftDown(index) {\r\n    const leftIndex = this.getLeftIndex(index);\r\n    const rightIndex = this.getRightIndex(index);\r\n    if (this.heap[leftIndex] < this.heap[index]) {\r\n      this.swap(leftIndex, index);\r\n      this.shiftDown(leftIndex);\r\n    }\r\n    if (this.heap[rightIndex] < this.heap[index]) {\r\n      this.swap(rightIndex, index);\r\n      this.shiftDown(rightIndex);\r\n    }\r\n  }\r\n  insert(value) {\r\n    this.heap.push(value);\r\n    this.shiftUp(this.heap.length - 1);\r\n  }\r\n  pop() {\r\n    this.heap[0] = this.heap.pop();\r\n    this.shiftDown(0);\r\n  }\r\n  peek() {\r\n    return this.heap[0];\r\n  }\r\n  size() {\r\n    return this.heap.length;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar findKthLargest = function (nums, k) {\r\n  const h = new Minheap();\r\n  nums.forEach((n) => {\r\n    h.insert(n);\r\n    if (h.size() > k) g.pop;\r\n  });\r\n  return h.peek();\r\n};\r\n```\r\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 题目 347. 前 K 个高频元素\r\n\r\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\r\n\r\n示例 1:\r\n\r\n输入: nums = [1,1,1,2,2,3], k = 2\r\n输出: [1,2]\r\n示例 2:\r\n\r\n输入: nums = [1], k = 1\r\n输出: [1]\r\n\r\n提示：\r\n\r\n1 <= nums.length <= 105\r\nk 的取值范围是 [1, 数组中不相同的元素的个数]\r\n题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\r\n\r\n进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。\r\n\r\n```js\r\nclass MinHeap {\r\n  constructor() {\r\n    this.heap = [];\r\n  }\r\n  swap(i1, i2) {\r\n    const temp = this.heap[i1];\r\n    this.heap[i1] = this.heap[i2];\r\n    this.heap[i2] = temp;\r\n  }\r\n  getParentIndex(i) {\r\n    return (i - 1) >> 1;\r\n  }\r\n  getLeftIndex(i) {\r\n    return i * 2 + 1;\r\n  }\r\n  getRightIndex(i) {\r\n    return i * 2 + 2;\r\n  }\r\n  shiftUp(index) {\r\n    if (index == 0) {\r\n      return;\r\n    }\r\n    const parentIndex = this.getParentIndex(index);\r\n    if (this.heap[parentIndex].value > this.heap[index].value) {\r\n      this.swap(parentIndex, index);\r\n      this.shiftUp(parentIndex);\r\n    }\r\n  }\r\n  shiftDown(index) {\r\n    const leftIndex = this.getLeftIndex(index);\r\n    const rightIndex = this.getRightIndex(index);\r\n    if (this.heap[leftIndex].value < this.heap[index].value) {\r\n      this.swap(leftIndex, index);\r\n      this.shiftDown(leftIndex);\r\n    }\r\n    if (this.heap[rightIndex].value < this.heap[index].value) {\r\n      this.swap(rightIndex, index);\r\n      this.shiftDown(rightIndex);\r\n    }\r\n  }\r\n  insert(value) {\r\n    this.heap.push(value);\r\n    this.shiftUp(this.heap.length - 1);\r\n  }\r\n  pop() {\r\n    this.heap[0] = this.heap.pop();\r\n    this.shiftDown(0);\r\n  }\r\n  peek() {\r\n    return this.heap[0];\r\n  }\r\n  size() {\r\n    return this.heap.length;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar topKFrequent = function (nums, k) {\r\n  const map = new Map();\r\n  nums.forEach((n) => {\r\n    map.set(n, map.has(n) ? map.get(n) + 1 : 1);\r\n  });\r\n  const h = new MinHeap();\r\n  map.forEach((value, key) => {\r\n    h.insert({ value, key });\r\n    if (h.size() > k) h.pop();\r\n  });\r\n  return h.heap.map(a => a.key);\r\n};\r\n```\r\n"
            ],
            "outputs": []
        }
    ]
}